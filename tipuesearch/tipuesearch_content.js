var tipuesearch = {"pages":[{"text":"OFF OFF OFF, Open source Finite volumes Fluid dynamics code OFF is a CFD code designed to be accurate, efficient and modular for solving, numerically, the Navier-Stokes equations of fluid dynamics by means of Finite Volume technique. It is written in standard (compliant) Fortran 2008 by means of OOP paradigm. OFF can be executed on parallel CPU-based architecture (shared memory multi-cores workstation, distributed memory cluster and hybrid distributed memory cluster based on shared memory nodes). A pure Fortran CFD solver for general purpose fluid dynamics problems OFF is a pure Fortran program; OFF is Fortran 2008+ standard compliant; OFF is OOP designed. Citing Please kindly cite OFF in your publications if it helps your research: @article { zaghi-2014 , author = {S. Zaghi} , title = {{OFF, Open source Finite volume Fluid dynamics code: A free, high-order solver based on parallel, modular, object-oriented Fortran API}} , journal = {Computer Physics Communications} , volume = {185} , number = {7} , pages = {2151--2194} , year = {2014} , issn = {0010-4655} , doi = {http://dx.doi.org/10.1016/j.cpc.2014.04.005} , url = {http://www.sciencedirect.com/science/article/pii/S0010465514001283} , } Compiler Support | What is OFF? | Install | Copyrights | Documentation | What is OFF? To be written. Go to Top or TOC Install A detailed set of procedures to install OFF is available into the official WiKi page . Before start the install procedure, please read the requirements and ChangeLog pages. Go to Top or TOC Copyrights OFF is an open source project, it is distributed under the GPL v3 . Anyone is interest to use, to develop or to contribute to OFF is welcome. Take a look at the contributing guidelines for starting to contribute to the project. Authors and contributors Auhors Giacomo Rossi Stefano Zaghi Contributors Francesco Salvadore Go to Top or TOC Documentation Comprehensive API documentation in HTML format is shipped alonside the code in the doc/html sub-directory here . The official WiKi is the other source of documentation. Main features To be written. Go to Top or TOC Developer Info Giacomo Rossi\nStefano Zaghi","tags":"","loc":"index.html","title":" OFF "},{"text":"OFF block object definition and implementation. This File Depends On sourcefile~~off_block_object.f90~~EfferentGraph sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_block_object.f90~~AfferentGraph sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_block_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_block_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_block_object Source Code off_block_object.f90 Source Code !< OFF block object definition and implementation. module off_block_object !< OFF block object definition and implementation. !< !< [[block_object]] is a Finite Volume block-structured class. !< !< It allows the easy handling of metrics data for the robust and efficient computation of numerical spatial !< operators in the framework of Finite Volume Methods (FVM). !< !< Let us assume that the fluid domain D is decomposed in N_b structured blocks D&#94;b, each subdivided in !< N_i \\times N_j \\times N_k disjoint hexahedrons D_{ijk}&#94;b such that \\bigcup D_{ijk}&#94;b = D&#94;b. !< The block class is designed to aid the computations of the spatial operators into each block: !<  !<\\frac{\\partial}{{\\partial t}}\\int\\limits_{V_{ijk}} {\\overrightarrow U dV}  = !<-\\sum\\limits_{s = 1}&#94;6 {\\int\\limits_{S_s} {\\left(\\overline{\\overline {F}}\\right) \\cdot \\overrightarrow n dS}} + !< \\int\\limits_{V_{ijk}} {\\overrightarrow {{Q}} dV}\\label{eq:rans-cons-num} !<  !< where S_s is the s&#94;{th} face of the finite volume D_{ijk} whose measure is V_{ijk}. !< !< A structured block is composed of hexahedron finite volumes with quadrilateral faces using the !< following internal numeration for nodes and faces: !<``` !< /|\\Z !<  |                            F(4)         _ F(6) !<  |                            /|\\          /! !<  |                        7    |          /    8 !<  |                         *------------------* !<  |                        /|   |        /    /| !<  |                       / |   |       /    / | !<  |                      /  |   |      /    /  | !<  |                     /   |   |     /    /   | !<  |                    /    |   |    +    /    | !<  |                   /     |   |        /     | !<  |                  /      |   +       /      | !<  |                 /      3|          /       |4 !<  |                /        * --------/--------* !<  |      F(1)<----/----+   /         /        / !<  |              *------------------*    +-------->F(2) !<  |             5|       /          |6      / !<  |              |      /           |      / !<  |              |     /        +   |     / !<  |              |    /         |   |    / !<  |              |   /      +   |   |   / !<  |              |  /      /    |   |  / !<  |              | /      /     |   | / !<  |              |/      /      |   |/ !<  |              *------------------* !<  |             1      /        |    2 !<  |                   /        \\|/ !<  |   _ Y           |/_       F(3) !<  |   /|         F(5) !<  |  / !<  | / !<  |/                                                    X !<  O-----------------------------------------------------> !<``` !< Each hexadron cells is faces-connected to its neighboring, thus the cells build a structured block with implicit !< connectivity, e.g. in 2D space a block could be as the following: !<``` !<                 _ J !<                 /|                          _____ !<               5+ ...*----*----*----*----*...     | !<               /    /    /    /    /    /         | !<              /    /    /    /    /    /          | !<            4+ ...*----*----*----*----*...        | !<            /    /    /    /    /    /            | !<           /    /    /    /    /    /             | !<         3+ ...*----*----*----*----*...           |  Structured block of 4x4 Finite Volumes !<         /    /    / FV /    /    /               | !<        /    /    /    /    /    /                | !<      2+ ...*----*----*----*----*...              | !<      /    /    /    /    /    /                  | !<     /    /    /    /    /    /                   | !<   1+ ...*----*----*----*----*...                 | !<   /     .    .    .    .    .                    | !<  /      .    .    .    .    .               _____ !< O-------+----+----+----+----+-------------> I !<         1    2    3    4    5 !<``` !< The nodes of cells are not required to be on the Cartesian coordinates, thus allowing a general !< curvilinear mesh: the are 3 implicit coordinate lines, *i*, *j* and *k* that are not required to be orthogonal. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use off_block_signature_object , only : block_signature_object use off_cell_object , only : cell_object use off_error_object , only : error_object use off_face_object , only : face_object use off_node_object , only : node_object use penf , only : FR8P , FI4P , I4P , I8P , R8P use vecfor , only : vector , ex , ey , ez use vtk_fortran , only : vtk_file implicit none private public :: block_object integer ( I4P ), parameter :: NO_ERROR = 0 !< No errors occurred. integer ( I4P ), parameter :: ERROR_BLOCK_COMPUTE_EXTENTS_FAILED = 1 !< Failed to compute block extents. integer ( I4P ), parameter :: ERROR_BLOCK_CREATE_FAILED = 2 !< Failed to create block. integer ( I4P ), parameter :: ERROR_BLOCK_DESTROY_FAILED = 3 !< Failed to destroy block. integer ( I4P ), parameter :: ERROR_BLOCK_CREATE_LINSPACE_FAILED = 4 !< Failed to create a uniform-spaced linear block. type :: block_object !< Block object class. type ( error_object ) :: error !< Errors handler. type ( block_signature_object ) :: signature !< Signature, namely id, level, dimensions, etc... type ( cell_object ), allocatable :: cell (:,:,:) !< Cell. type ( face_object ), allocatable :: face_i (:,:,:) !< Faces along I direction. type ( face_object ), allocatable :: face_j (:,:,:) !< Faces along I direction. type ( face_object ), allocatable :: face_k (:,:,:) !< Faces along I direction. type ( node_object ), allocatable :: node (:,:,:) !< Cell. contains ! public methods procedure , pass ( self ) :: cells_number !< Return the number of cells. procedure , pass ( self ) :: compute_space_operator !< Compute space operator. procedure , pass ( self ) :: create_linspace !< Create a Cartesian block with linearly spaced nodes. procedure , pass ( self ) :: destroy !< Destroy block. procedure , pass ( self ) :: interpolate_at_nodes !< Interpolate cell-centered variable at nodes. procedure , pass ( self ) :: initialize !< Initialize block. procedure , pass ( self ) :: load_nodes_from_file !< Load nodes from file. procedure , pass ( self ) :: nodes_number !< Return the number of nodes. procedure , pass ( self ) :: save_file_grid !< Save gird file. procedure , pass ( self ) :: save_nodes_into_file !< Save nodes into file. ! operators generic :: assignment ( = ) => block_assign_block !< Overload `=`. ! private methods procedure , pass ( lhs ), private :: block_assign_block !< Operator `=`. procedure , pass ( self ), private :: compute_extents !< Compute block extents. procedure , pass ( self ), private :: compute_faces_metrics !< Compute block faces metrics. procedure , pass ( self ), private :: compute_metrics !< Compute block metrics. procedure , pass ( self ), private :: compute_volumes !< Compute block volumes. procedure , pass ( self ), private :: correct_metrics !< Correct block metrics. procedure , pass ( self ), private :: node_to_center !< Compute cell centers coordinates from cell nodes. procedure , pass ( self ), private :: nullify_normals !< Nullify normals for 2D or 1D domains. procedure , pass ( self ), private :: save_file_grid_tec !< Save grid file in Tecplot format. procedure , pass ( self ), private :: save_file_grid_vtk !< Save grid file in VTK format. endtype block_object contains ! public methods elemental function cells_number ( self , with_ghosts ) result ( cells_number_ ) !< Return the number of cells. class ( block_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: cells_number_ !< Number of cells. cells_number_ = self % signature % cells_number ( with_ghosts = with_ghosts ) endfunction cells_number subroutine compute_space_operator ( self ) !, space_operator) !< Compute space operator. !< !< @TODO implement space operator. !< !< @TODO re-add elemental attribute. class ( block_object ), intent ( in ) :: self !< Block. ! class(conservative_object), intent(inout) :: space_operator(1:,1:,1:) !< Space operator. error stop 'error: block space operator to be implemented' endsubroutine compute_space_operator subroutine create_linspace ( self , emin , emax ) !< Create a Cartesian block with linearly spaced nodes. !< !< @note If the extents (emin, emax) of the block are not passed, the values already saved into the block are used. !< !< @TODO re-add elemental attribute. class ( block_object ), intent ( inout ) :: self !< Block. type ( vector ), intent ( in ), optional :: emin !< Coordinates of minimum abscissa of the block. type ( vector ), intent ( in ), optional :: emax !< Coordinates of maximum abscissa of the block. type ( vector ) :: delta !< Diagonal of block bounding-box. real ( R8P ) :: delta_x !< X component of diagonal of block bounding-box. real ( R8P ) :: delta_y !< Y component of diagonal of block bounding-box. real ( R8P ) :: delta_z !< Z component of diagonal of block bounding-box. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. self % error % status = ERROR_BLOCK_CREATE_LINSPACE_FAILED self % signature % is_cartesian = . true . if ( present ( emin )) self % signature % emin = emin if ( present ( emax )) self % signature % emax = emax associate ( gc => self % signature % gc , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) if ( self % signature % emin /= self % signature % emax ) then delta = ( self % signature % emax - self % signature % emin ) / ( ni * ex + nj * ey + nk * ez ) delta_x = delta . dot . ex delta_y = delta . dot . ey delta_z = delta . dot . ez do k = 0 - gc ( 5 ), nk + gc ( 6 ) do j = 0 - gc ( 3 ), nj + gc ( 4 ) do i = 0 - gc ( 1 ), ni + gc ( 2 ) self % node ( i , j , k )% vertex = self % signature % emin + ( i * delta_x ) * ex + ( j * delta_y ) * ey + ( k * delta_z ) * ez enddo enddo enddo call self % compute_metrics self % error % status = NO_ERROR endif endassociate endsubroutine create_linspace elemental subroutine destroy ( self ) !< Destroy block. class ( block_object ), intent ( inout ) :: self !< Block. type ( block_object ) :: fresh !< Fresh instance of block object. self = fresh if ( allocated ( self % cell )) then call self % cell % destroy deallocate ( self % cell ) endif if ( allocated ( self % face_i )) then call self % face_i % destroy deallocate ( self % face_i ) endif if ( allocated ( self % face_j )) then call self % face_j % destroy deallocate ( self % face_j ) endif if ( allocated ( self % face_k )) then call self % face_k % destroy deallocate ( self % face_k ) endif if ( allocated ( self % node )) then call self % node % destroy deallocate ( self % node ) endif endsubroutine destroy subroutine initialize ( self , signature , & id , level , gc , ni , nj , nk , & emin , emax , is_cartesian , is_null_x , is_null_y , is_null_z ) !< Initialize block. !< !< Assign block signature, allocate dynamic memory and set block features. class ( block_object ), intent ( inout ) :: self !< Block. type ( block_signature_object ), intent ( in ), optional :: signature !< Signature, namely id, level, dimensions, etc... integer ( I8P ), intent ( in ), optional :: id !< Unique (Morton) identification code. integer ( I4P ), intent ( in ), optional :: level !< Grid refinement level. integer ( I4P ), intent ( in ), optional :: gc ( 1 :) !< Number of ghost cells along each frame. integer ( I4P ), intent ( in ), optional :: ni !< Number of cells in I direction. integer ( I4P ), intent ( in ), optional :: nj !< Number of cells in J direction. integer ( I4P ), intent ( in ), optional :: nk !< Number of cells in K direction. type ( vector ), intent ( in ), optional :: emin !< Coordinates of minimum abscissa of the block. type ( vector ), intent ( in ), optional :: emax !< Coordinates of maximum abscissa of the block. logical , intent ( in ), optional :: is_cartesian !< Flag for checking if the block is Cartesian. logical , intent ( in ), optional :: is_null_x !< Nullify X direction (2D yz, 1D y or z domain). logical , intent ( in ), optional :: is_null_y !< Nullify Y direction (2D xy, 1D x or y domain). logical , intent ( in ), optional :: is_null_z !< Nullify Z direction (2D xy, 1D x or y domain). self % error % status = ERROR_BLOCK_CREATE_FAILED if ((. not .( present ( signature ))). and .& (. not .( present ( id ). and . present ( level ). and . present ( gc ). and . present ( ni ). and . present ( nj ). and . present ( nk )))) then error stop 'error: either signature or (id, level, gc, ni, nj, nk) tuple must be passed to a block initialized' endif call self % destroy call self % signature % initialize ( signature = signature , & id = id , level = level , gc = gc , ni = ni , nj = nj , nk = nk , & emin = emin , emax = emax , is_cartesian = is_cartesian , & is_null_x = is_null_x , is_null_y = is_null_y , is_null_z = is_null_z ) associate ( gc_ => self % signature % gc , ni_ => self % signature % ni , nj_ => self % signature % nj , nk_ => self % signature % nk ) allocate ( self % cell ( 1 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 1 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 1 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % face_i ( 0 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 1 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 1 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % face_j ( 1 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 0 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 1 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % face_k ( 1 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 1 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 0 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % node ( 0 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 0 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 0 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) endassociate self % error % status = NO_ERROR endsubroutine initialize pure subroutine interpolate_at_nodes ( self , var_cell , var_node ) !< Interpolate cell-centered variable at nodes. !< !< @note The interpolation is linear and based on the volume-weights. !< !< @note Only internal cells are considered, ghost ones are trimmed. class ( block_object ), intent ( in ) :: self !< Block. real ( R8P ), intent ( in ) :: var_cell ( 1 - self % signature % gc ( 1 ):, & 1 - self % signature % gc ( 3 ):, & 1 - self % signature % gc ( 5 ):) !< Cell-centered variable. real ( R8P ), intent ( out ) :: var_node ( 0 - self % signature % gc ( 1 ):, & 0 - self % signature % gc ( 3 ):, & 0 - self % signature % gc ( 5 ):) !< Node-centered variable. real ( R8P ), allocatable :: var_cell_framed (:,:,:) !< Cell-centered var framed. real ( R8P ), allocatable :: volume_framed (:,:,:) !< Volume framed. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( gc => self % signature % gc , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) ! building framed variable and volume allocate ( var_cell_framed ( 0 : ni + 1 , 0 : nj + 1 , 0 : nk + 1 )) ; var_cell_framed = 0._R8P var_cell_framed ( 1 : ni , 1 : nj , 1 : nk ) = var_cell ( 1 : ni , 1 : nj , 1 : nk ) allocate ( volume_framed ( 0 : ni + 1 , 0 : nj + 1 , 0 : nk + 1 )) ; volume_framed = 0._R8P volume_framed ( 1 : ni , 1 : nj , 1 : nk ) = self % cell ( 1 : ni , 1 : nj , 1 : nk )% volume ! check frames if ( gc ( 1 ) > 0 ) then var_cell_framed ( 0 , 1 : nj , 1 : nk ) = var_cell ( 0 , 1 : nj , 1 : nk ) volume_framed ( 0 , 1 : nj , 1 : nk ) = self % cell ( 0 , 1 : nj , 1 : nk )% volume endif if ( gc ( 2 ) > 0 ) then var_cell_framed ( ni + 1 , 1 : nj , 1 : nk ) = var_cell ( ni + 1 , 1 : nj , 1 : nk ) volume_framed ( ni + 1 , 1 : nj , 1 : nk ) = self % cell ( ni + 1 , 1 : nj , 1 : nk )% volume endif if ( gc ( 3 ) > 0 ) then var_cell_framed ( 1 : ni , 0 , 1 : nk ) = var_cell ( 1 : ni , 0 , 1 : nk ) volume_framed ( 1 : ni , 0 , 1 : nk ) = self % cell ( 1 : ni , 0 , 1 : nk )% volume endif if ( gc ( 4 ) > 0 ) then var_cell_framed ( ni , 1 : nj + 1 , 1 : nk ) = var_cell ( ni , 1 : nj + 1 , 1 : nk ) volume_framed ( ni , 1 : nj + 1 , 1 : nk ) = self % cell ( ni , 1 : nj + 1 , 1 : nk )% volume endif if ( gc ( 5 ) > 0 ) then var_cell_framed ( 1 : ni , 1 : nj , 0 ) = var_cell ( 1 : ni , 1 : nj , 0 ) volume_framed ( 1 : ni , 1 : nj , 0 ) = self % cell ( 1 : ni , 1 : nj , 0 )% volume endif if ( gc ( 6 ) > 0 ) then var_cell_framed ( ni , 1 : nj , 1 : nk + 1 ) = var_cell ( ni , 1 : nj , 1 : nk + 1 ) volume_framed ( ni , 1 : nj , 1 : nk + 1 ) = self % cell ( ni , 1 : nj , 1 : nk + 1 )% volume endif ! interpolate on nodes do k = 0 , nk do j = 0 , nj do i = 0 , ni var_node ( i , j , k ) = ( var_cell_framed ( i + 1 , j + 1 , k + 1 ) * volume_framed ( i + 1 , j + 1 , k + 1 ) & + var_cell_framed ( i , j + 1 , k + 1 ) * volume_framed ( i , j + 1 , k + 1 ) & + var_cell_framed ( i + 1 , j , k + 1 ) * volume_framed ( i + 1 , j , k + 1 ) & + var_cell_framed ( i , j , k + 1 ) * volume_framed ( i , j , k + 1 ) & + var_cell_framed ( i + 1 , j + 1 , k ) * volume_framed ( i + 1 , j + 1 , k ) & + var_cell_framed ( i , j + 1 , k ) * volume_framed ( i , j + 1 , k ) & + var_cell_framed ( i + 1 , j , k ) * volume_framed ( i + 1 , j , k ) & + var_cell_framed ( i , j , k ) * volume_framed ( i , j , k ))& / sum ( volume_framed ( i : i + 1 , j : j + 1 , k : k + 1 )) enddo enddo enddo endassociate endsubroutine interpolate_at_nodes subroutine load_nodes_from_file ( self , file_unit , pos ) !< Load nodes from file. class ( block_object ), intent ( inout ) :: self !< Block. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ), intent ( in ) :: pos !< Position to start the loading. read ( file_unit , pos = pos , iostat = self % error % status ) self % node % vertex % x , self % node % vertex % y , self % node % vertex % z call self % compute_extents endsubroutine load_nodes_from_file elemental function nodes_number ( self , with_ghosts ) result ( nodes_number_ ) !< Return the number of nodes. class ( block_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: nodes_number_ !< Number of cells. nodes_number_ = self % signature % nodes_number ( with_ghosts = with_ghosts ) endfunction nodes_number subroutine save_file_grid ( self , file_name , ascii , metrics , tecplot , vtk ) !< Save grid file file. class ( block_object ), intent ( inout ) :: self !< Block. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. logical , intent ( in ), optional :: tecplot !< Tecplot output format sentinel. logical , intent ( in ), optional :: vtk !< VTK output format sentinel. logical :: tecplot_ !< Tecplot format sentinel, local variable. logical :: vtk_ !< VTK format sentinel, local variable. tecplot_ = . false . ; if ( present ( tecplot )) tecplot_ = tecplot vtk_ = . false . ; if ( present ( vtk )) vtk_ = vtk if ( vtk_ ) call self % save_file_grid_vtk ( file_name = file_name , ascii = ascii , metrics = metrics ) endsubroutine save_file_grid subroutine save_nodes_into_file ( self , file_unit , pos ) !< Save nodes into file. class ( block_object ), intent ( inout ) :: self !< Block. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ), intent ( in ) :: pos !< Position to start the loading. write ( file_unit , pos = pos , iostat = self % error % status ) self % node % vertex % x , self % node % vertex % y , self % node % vertex % z endsubroutine save_nodes_into_file ! private methods pure subroutine block_assign_block ( lhs , rhs ) !< Operator `=`. class ( block_object ), intent ( inout ) :: lhs !< Left hand side. type ( block_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % signature = rhs % signature if ( allocated ( rhs % cell )) then if ( allocated ( lhs % cell )) then call lhs % cell % destroy deallocate ( lhs % cell ) endif lhs % cell = rhs % cell endif if ( allocated ( rhs % face_i )) then if ( allocated ( lhs % face_i )) then call lhs % face_i % destroy deallocate ( lhs % face_i ) endif lhs % face_i = rhs % face_i endif if ( allocated ( rhs % face_j )) then if ( allocated ( lhs % face_j )) then call lhs % face_j % destroy deallocate ( lhs % face_j ) endif lhs % face_j = rhs % face_j endif if ( allocated ( rhs % face_k )) then if ( allocated ( lhs % face_k )) then call lhs % face_k % destroy deallocate ( lhs % face_k ) endif lhs % face_k = rhs % face_k endif if ( allocated ( rhs % node )) then if ( allocated ( lhs % node )) then call lhs % node % destroy deallocate ( lhs % node ) endif lhs % node = rhs % node endif endsubroutine block_assign_block elemental subroutine compute_extents ( self ) !< Compute block extents. class ( block_object ), intent ( inout ) :: self !< Block. self % error % status = ERROR_BLOCK_COMPUTE_EXTENTS_FAILED associate ( ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) if ( allocated ( self % node )) then self % signature % emin % x = minval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % x ) self % signature % emin % y = minval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % y ) self % signature % emin % z = minval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % z ) self % signature % emax % x = maxval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % x ) self % signature % emax % y = maxval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % y ) self % signature % emax % z = maxval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % z ) self % error % status = NO_ERROR endif endassociate endsubroutine compute_extents elemental subroutine compute_faces_metrics ( self ) !< Compute block faces metrics. class ( block_object ), intent ( inout ) :: self !< Block. type ( vector ) :: triplet ( 1 : 4 ) !< Dummy vectors. real ( R8P ) :: signi !< Sign of direction of normals along I coordinate. real ( R8P ) :: signj !< Sign of direction of normals along J coordinate. real ( R8P ) :: signk !< Sign of direction of normals along K coordinate. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( node => self % node , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) i = max ( 1 , ni ) j = max ( 1 , nj ) k = max ( 1 , nk ) triplet ( 1 ) = node ( i , j , k )% vertex - node ( i , j - 1 , k - 1 )% vertex triplet ( 2 ) = node ( i , j - 1 , k )% vertex - node ( i , j , k - 1 )% vertex triplet ( 3 ) = triplet ( 1 ). cross . triplet ( 2 ) triplet ( 4 ) = ( 0.25_R8P * ( node ( i , j , k )% vertex + node ( i , j - 1 , k )% vertex + & node ( i , j , k - 1 )% vertex + node ( i , j - 1 , k - 1 )% vertex )) - & ( 0.25_R8P * ( node ( i - 1 , j , k )% vertex + node ( i - 1 , j - 1 , k )% vertex + & node ( i - 1 , j , k - 1 )% vertex + node ( i - 1 , j - 1 , k - 1 )% vertex )) signi = sign ( 1._R8P , ( triplet ( 3 ). dot . triplet ( 4 ))) triplet ( 1 ) = node ( i , j , k )% vertex - node ( i - 1 , j , k - 1 )% vertex triplet ( 2 ) = node ( i , j , k - 1 )% vertex - node ( i - 1 , j , k )% vertex triplet ( 3 ) = triplet ( 1 ). cross . triplet ( 2 ) triplet ( 4 ) = ( 0.25_R8P * ( node ( i , j , k )% vertex + node ( i - 1 , j , k )% vertex + & node ( i , j , k - 1 )% vertex + node ( i - 1 , j , k - 1 )% vertex )) - & ( 0.25_R8P * ( node ( i , j - 1 , k )% vertex + node ( i - 1 , j - 1 , k )% vertex + & node ( i , j - 1 , k - 1 )% vertex + node ( i - 1 , j - 1 , k - 1 )% vertex )) signj = sign ( 1._R8P , ( triplet ( 3 ). dot . triplet ( 4 ))) triplet ( 1 ) = node ( i , j , k )% vertex - node ( i - 1 , j - 1 , k )% vertex triplet ( 2 ) = node ( i - 1 , j , k )% vertex - node ( i , j - 1 , k )% vertex triplet ( 3 ) = triplet ( 1 ). cross . triplet ( 2 ) triplet ( 4 ) = ( 0.25_R8P * ( node ( i , j , k )% vertex + node ( i - 1 , j , k )% vertex + & node ( i , j - 1 , k )% vertex + node ( i - 1 , j - 1 , k )% vertex )) - & ( 0.25_R8P * ( node ( i , j , k - 1 )% vertex + node ( i - 1 , j , k - 1 )% vertex + & node ( i , j - 1 , k - 1 )% vertex + node ( i - 1 , j - 1 , k - 1 )% vertex )) signk = sign ( 1._R8P , ( triplet ( 3 ). dot . triplet ( 4 ))) do k = 1 , nk do j = 1 , nj do i = 0 , ni call self % face_i ( i , j , k )% compute_metrics ( pt1 = node ( i , j - 1 , k - 1 )% vertex , & pt2 = node ( i , j , k - 1 )% vertex , & pt3 = node ( i , j , k )% vertex , & pt4 = node ( i , j - 1 , k )% vertex , signd = signi ) enddo enddo enddo do k = 1 , nk do j = 0 , nj do i = 1 , ni call self % face_j ( i , j , k )% compute_metrics ( pt1 = node ( i - 1 , j , k - 1 )% vertex , & pt2 = node ( i - 1 , j , k )% vertex , & pt3 = node ( i , j , k )% vertex , & pt4 = node ( i , j , k - 1 )% vertex , signd = signj ) enddo enddo enddo do k = 0 , nk do j = 1 , nj do i = 1 , ni call self % face_k ( i , j , k )% compute_metrics ( pt1 = node ( i - 1 , j - 1 , k )% vertex , & pt2 = node ( i , j - 1 , k )% vertex , & pt3 = node ( i , j , k )% vertex , & pt4 = node ( i - 1 , j , k )% vertex , signd = signk ) enddo enddo enddo endassociate endsubroutine compute_faces_metrics subroutine compute_metrics ( self ) !< Compute block metrics. !< !< @TODO re-add elemental attribute. !< !< @TODO re-add metrics correction call. class ( block_object ), intent ( inout ) :: self !< Block. call self % compute_faces_metrics call self % compute_volumes ! call self%correct_metrics call self % nullify_normals endsubroutine compute_metrics elemental subroutine compute_volumes ( self ) !< Compute block volumes. !< !< The volume of each cell is computed using the formula: !<  !< v = [(\\vec n_7 - \\vec n_1) + (\\vec n_6 - \\vec n_0), (\\vec n_7 - \\vec n_2), (\\vec n_3 - \\vec n_0)] + !<     [(\\vec n_6 - \\vec n_0), (\\vec n_7 - \\vec n_2) + (\\vec n_5 - \\vec n_0), (\\vec n_7 - \\vec n_4)] + !<     [(\\vec n_7 - \\vec n_1), (\\vec n_5 - \\vec n_0), (\\vec n_7 - \\vec n_4) + (\\vec n_3 - \\vec n_0)] !<  !< where [\\vec A, \\vec B, \\vec C]=\\vec A \\cdot (\\vec B \\times \\vec C) is the triple product. !< !<### References !< !< [1] *Efficient computation of volume of hexahedral cells*, Grandy J., 1997. class ( block_object ), intent ( inout ) :: self !< Block. type ( vector ) :: triplet ( 1 : 9 ) !< Dummy vectors. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( node => self % node , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) do k = 1 , nk do j = 1 , nj do i = 1 , ni triplet ( 1 ) = node ( i , j , k )% vertex - node ( i , j - 1 , k - 1 )% vertex & + node ( i - 1 , j , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 2 ) = node ( i , j , k )% vertex - node ( i - 1 , j , k - 1 )% vertex triplet ( 3 ) = node ( i , j , k - 1 )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 4 ) = node ( i - 1 , j , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 5 ) = node ( i , j , k )% vertex - node ( i - 1 , j , k - 1 )% vertex & + node ( i , j - 1 , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 6 ) = node ( i , j , k )% vertex - node ( i - 1 , j - 1 , k )% vertex triplet ( 7 ) = node ( i , j , k )% vertex - node ( i , j - 1 , k - 1 )% vertex triplet ( 8 ) = node ( i , j - 1 , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 9 ) = node ( i , j , k )% vertex - node ( i - 1 , j - 1 , k )% vertex & + node ( i , j , k - 1 )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex self % cell ( i , j , k )% volume = (( triplet ( 1 ). dot .( triplet ( 2 ). cross . triplet ( 3 ))) + & ( triplet ( 4 ). dot .( triplet ( 5 ). cross . triplet ( 6 ))) + & ( triplet ( 7 ). dot .( triplet ( 8 ). cross . triplet ( 9 )))) / 1 2.0_R8P enddo enddo enddo endassociate endsubroutine compute_volumes subroutine correct_metrics ( self ) !> Correct the metrics. !< !< Check for boundary conditions and volumes issues. !< !< @TODO Implement correction. class ( block_object ), intent ( inout ) :: self !< Block. error stop 'error: block metrics correction to be implemented' endsubroutine correct_metrics pure function node_to_center ( self ) result ( center ) !< Compute cell centers coordinates from cell nodes. class ( block_object ), intent ( in ) :: self !< Block. type ( vector ), allocatable :: center (:,:,:) !< Cell centers coordinates. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( gc => self % signature % gc , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) allocate ( center ( 1 - gc ( 1 ) : ni + gc ( 2 ), 1 - gc ( 3 ) : nj + gc ( 4 ), 1 - gc ( 5 ) : nk + gc ( 6 ))) do k = 1 - gc ( 5 ), nk + gc ( 6 ) do j = 1 - gc ( 3 ), nj + gc ( 4 ) do i = 1 - gc ( 1 ), ni + gc ( 2 ) center ( i , j , k ) = ( self % node ( i , j , k )% vertex + & self % node ( i - 1 , j , k )% vertex + & self % node ( i , j - 1 , k )% vertex + & self % node ( i , j , k - 1 )% vertex + & self % node ( i - 1 , j - 1 , k - 1 )% vertex + & self % node ( i , j - 1 , k - 1 )% vertex + & self % node ( i - 1 , j , k - 1 )% vertex + & self % node ( i - 1 , j - 1 , k )% vertex ) * 0.125_R8P enddo enddo enddo endassociate endfunction node_to_center elemental subroutine nullify_normals ( self ) !< Nullify normals for 2D or 1D domains. class ( block_object ), intent ( inout ) :: self !< Block. if ( self % signature % is_null_x ) then self % face_i % normal = ( self % face_i % normal . paral . ex ) + ( 0._R8P * ey ) + ( 0._R8P * ez ) self % face_j % normal = ( 0._R8P * ex ) + ( self % face_j % normal . paral . ey ) + ( self % face_j % normal . paral . ez ) self % face_k % normal = ( 0._R8P * ex ) + ( self % face_k % normal . paral . ey ) + ( self % face_k % normal . paral . ez ) endif if ( self % signature % is_null_y ) then self % face_i % normal = ( self % face_i % normal . paral . ex ) + ( 0._R8P * ey ) + ( self % face_i % normal . paral . ez ) self % face_j % normal = ( 0._R8P * ex ) + ( self % face_j % normal . paral . ey ) + ( 0._R8P * ez ) self % face_k % normal = ( self % face_k % normal . paral . ex ) + ( 0._R8P * ey ) + ( self % face_k % normal . paral . ez ) endif if ( self % signature % is_null_z ) then self % face_i % normal = ( self % face_i % normal . paral . ex ) + ( self % face_i % normal . paral . ey ) + ( 0._R8P * ez ) self % face_j % normal = ( self % face_j % normal . paral . ex ) + ( self % face_j % normal . paral . ey ) + ( 0._R8P * ez ) self % face_k % normal = ( 0._R8P * ex ) + ( 0._R8P * ey ) + ( self % face_k % normal . paral . ez ) endif endsubroutine nullify_normals subroutine save_file_grid_tec ( self , file_name , ascii , metrics ) !< Save grid file in Tecplot format. !< !< @TODO implement Tecplot output. class ( block_object ), intent ( inout ) :: self !< Block. character ( * ), intent ( in ) :: file_name !< Output file name. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. error stop 'error: block mesh Tecplot output to be implemented' endsubroutine save_file_grid_tec subroutine save_file_grid_vtk ( self , file_name , ascii , metrics ) !< Save mesh data into VTK file. class ( block_object ), intent ( inout ) :: self !< Block. character ( * ), intent ( in ) :: file_name !< Output file name. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. logical :: ascii_ !< Ascii/binary output. logical :: metrics_ !< Save also metrics data. type ( vtk_file ) :: vtk !< VTK file. ascii_ = . false . ; if ( present ( ascii )) ascii_ = ascii metrics_ = . false . ; if ( present ( metrics )) metrics_ = metrics associate ( node => self % node , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk , & nn => self % nodes_number ( with_ghosts = . false .)) if ( ascii_ ) then self % error % status = vtk % initialize ( format = 'ascii' , & filename = trim ( adjustl ( file_name )), mesh_topology = 'StructuredGrid' , & nx1 = 0 , nx2 = ni , ny1 = 0 , ny2 = nj , nz1 = 0 , nz2 = nk ) else self % error % status = vtk % initialize ( format = 'raw' , & filename = trim ( adjustl ( file_name )), mesh_topology = 'StructuredGrid' , & nx1 = 0 , nx2 = ni , ny1 = 0 , ny2 = nj , nz1 = 0 , nz2 = nk ) endif self % error % status = vtk % xml_writer % write_piece ( nx1 = 0 , nx2 = ni , ny1 = 0 , ny2 = nj , nz1 = 0 , nz2 = nk ) self % error % status = vtk % xml_writer % write_geo ( n = nn , x = node ( 0 : ni , 0 : nj , 0 : nk )% vertex % x , & y = node ( 0 : ni , 0 : nj , 0 : nk )% vertex % y , & z = node ( 0 : ni , 0 : nj , 0 : nk )% vertex % z ) if ( metrics_ ) then self % error % status = vtk % xml_writer % write_dataarray ( location = 'cell' , action = 'open' ) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'volume' , x = self % cell ( 1 : ni , 1 : nj , 1 : nk )% volume , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'area_i' , x = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% area , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'area_j' , x = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% area , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'area_k' , x = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% area , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'normals_i' , x = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% normal % x , & y = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% normal % y , & z = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% normal % z ) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'normals_j' , x = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% normal % x , & y = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% normal % y , & z = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% normal % z ) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'normals_k' , x = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% normal % x , & y = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% normal % y , & z = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% normal % z ) self % error % status = vtk % xml_writer % write_dataarray ( location = 'cell' , action = 'close' ) endif self % error % status = vtk % xml_writer % write_piece () self % error % status = vtk % finalize () endassociate endsubroutine save_file_grid_vtk endmodule off_block_object","tags":"","loc":"sourcefile/off_block_object.f90.html","title":"off_block_object.f90 – OFF"},{"text":"OFF block signature object definition and implementation. Files Dependent On This One sourcefile~~off_block_signature_object.f90~~AfferentGraph sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_block_signature_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_block_signature_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_block_signature_object Source Code off_block_signature_object.f90 Source Code !< OFF block signature object definition and implementation. module off_block_signature_object !< OFF block signature object definition and implementation. use penf , only : I4P , I8P , str use vecfor , only : vector implicit none private public :: block_signature_object type :: block_signature_object !< Block signature object class. !< !< Define the block dimensions, id and level. integer ( I8P ) :: id = 0 !< Unique (Morton) identification code. integer ( I4P ) :: level = 0 !< block refinement level. integer ( I4P ) :: gc ( 1 : 6 ) = [ 0 , 0 , 0 , 0 , 0 , 0 ] !< Number of ghost cells along each frame. integer ( I4P ) :: ni = 0 !< Number of cells in I direction. integer ( I4P ) :: nj = 0 !< Number of cells in J direction. integer ( I4P ) :: nk = 0 !< Number of cells in K direction. type ( vector ) :: emin !< Coordinates of minimum abscissa (extent) of the block. type ( vector ) :: emax !< Coordinates of maximum abscissa (extent) of the block. logical :: is_cartesian = . false . !< Flag for checking if the block is Cartesian. logical :: is_null_x = . false . !< Nullify X direction (2D yz, 1D y or z domain). logical :: is_null_y = . false . !< Nullify Y direction (2D xy, 1D x or y domain). logical :: is_null_z = . false . !< Nullify Z direction (2D xy, 1D x or y domain). contains ! public methods procedure , pass ( self ) :: cells_number !< Return the number of cells. procedure , pass ( self ) :: description !< Return a pretty-formatted description of block signature. procedure , pass ( self ) :: destroy !< Destroy block signature. procedure , pass ( self ) :: initialize !< Initialize block signature. procedure , pass ( self ) :: iolength !< Return the IO length storage. procedure , pass ( self ) :: load_from_file !< Load block signature from file. procedure , pass ( self ) :: nodes_number !< Return the number of nodes. procedure , pass ( self ) :: save_into_file !< Save block signature into file. ! operators generic :: assignment ( = ) => block_d_assign_block_d !< Overload `=`. ! private methods procedure , pass ( lhs ) :: block_d_assign_block_d !< Operator `=`. endtype block_signature_object contains ! public methods elemental function cells_number ( self , with_ghosts ) result ( cells_number_ ) !< Return the number of cells. class ( block_signature_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: cells_number_ !< Number of cells. logical :: with_ghosts_ !< Take into account ghost cells, local variable. with_ghosts_ = . true . ; if ( present ( with_ghosts )) with_ghosts_ = with_ghosts if ( with_ghosts_ ) then cells_number_ = ( self % ni + self % gc ( 1 ) + self % gc ( 2 )) & * ( self % nj + self % gc ( 3 ) + self % gc ( 4 )) & * ( self % nk + self % gc ( 5 ) + self % gc ( 6 )) else cells_number_ = ( self % ni ) & * ( self % nj ) & * ( self % nk ) endif endfunction cells_number pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the block signature. class ( block_signature_object ), intent ( in ) :: self !< Block signature object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'id           : ' // trim ( str ( self % id , no_sign = . true .)) // NL desc = desc // prefix_ // 'level        : ' // trim ( str ( self % level , no_sign = . true .)) // NL desc = desc // prefix_ // 'gc           : ' // trim ( str ( self % gc , no_sign = . true .)) // NL desc = desc // prefix_ // 'ni           : ' // trim ( str ( self % ni , no_sign = . true .)) // NL desc = desc // prefix_ // 'nj           : ' // trim ( str ( self % nj , no_sign = . true .)) // NL desc = desc // prefix_ // 'nk           : ' // trim ( str ( self % nk , no_sign = . true .)) // NL desc = desc // prefix_ // 'emin         : ' // trim ( str ([ self % emin % x , self % emin % y , self % emin % z ] )) // NL desc = desc // prefix_ // 'emax         : ' // trim ( str ([ self % emax % x , self % emax % y , self % emax % z ] )) // NL desc = desc // prefix_ // 'is cartesian : ' // trim ( str ( self % is_cartesian )) // NL desc = desc // prefix_ // 'is null X    : ' // trim ( str ( self % is_null_x )) // NL desc = desc // prefix_ // 'is null Y    : ' // trim ( str ( self % is_null_y )) // NL desc = desc // prefix_ // 'is null Z    : ' // trim ( str ( self % is_null_z )) endfunction description elemental subroutine destroy ( self ) !< Destroy block signature. class ( block_signature_object ), intent ( inout ) :: self !< Block signature object. type ( block_signature_object ) :: fresh !< Fresh instance of block signature object. self = fresh endsubroutine destroy pure subroutine initialize ( self , signature , & id , level , gc , ni , nj , nk , & emin , emax , is_cartesian , is_null_x , is_null_y , is_null_z ) !< Initialize block signature. !< !< @note If both whole `signature` and single components like `id, level, gc...` are passed, the values of !< `signature%id, signature%level, ...` are overridden. class ( block_signature_object ), intent ( inout ) :: self !< Block signature object. type ( block_signature_object ), intent ( in ), optional :: signature !< Block signature input. integer ( I8P ), intent ( in ), optional :: id !< Unique (Morton) identification code. integer ( I4P ), intent ( in ), optional :: level !< Grid refinement level. integer ( I4P ), intent ( in ), optional :: gc ( 1 :) !< Number of ghost cells along each frame. integer ( I4P ), intent ( in ), optional :: ni !< Number of cells in I direction. integer ( I4P ), intent ( in ), optional :: nj !< Number of cells in J direction. integer ( I4P ), intent ( in ), optional :: nk !< Number of cells in K direction. type ( vector ), intent ( in ), optional :: emin !< Coordinates of minimum abscissa of the block. type ( vector ), intent ( in ), optional :: emax !< Coordinates of maximum abscissa of the block. logical , intent ( in ), optional :: is_cartesian !< Flag for checking if the block is Cartesian. logical , intent ( in ), optional :: is_null_x !< Nullify X direction (2D yz, 1D y or z domain). logical , intent ( in ), optional :: is_null_y !< Nullify Y direction (2D xy, 1D x or y domain). logical , intent ( in ), optional :: is_null_z !< Nullify Z direction (2D xy, 1D x or y domain). call self % destroy if ( present ( signature )) self = signature if ( present ( id )) self % id = id if ( present ( level )) self % level = level if ( present ( gc )) self % gc = gc if ( present ( ni )) self % ni = ni if ( present ( nj )) self % nj = nj if ( present ( nk )) self % nk = nk if ( present ( emin )) self % emin = emin if ( present ( emax )) self % emax = emax if ( present ( is_cartesian )) self % is_cartesian = is_cartesian if ( present ( is_null_x )) self % is_null_x = is_null_x if ( present ( is_null_y )) self % is_null_y = is_null_y if ( present ( is_null_z )) self % is_null_z = is_null_z endsubroutine initialize function iolength ( self ) !< Return the IO length storage. class ( block_signature_object ), intent ( in ) :: self !< Block signature object. integer ( I4P ) :: iolength !< IO length storage. inquire ( iolength = iolength ) self % id , & self % level , & self % gc , & self % ni , & self % nj , & self % nk , & self % emin % x , self % emin % y , self % emin % z , & self % emax % x , self % emax % y , self % emax % z , & self % is_cartesian , & self % is_null_x , self % is_null_y , self % is_null_z endfunction iolength subroutine load_from_file ( self , file_unit ) !< Load block signature from file. class ( block_signature_object ), intent ( inout ) :: self !< Block signature object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. read ( unit = file_unit ) self % id , & self % level , & self % gc , & self % ni , & self % nj , & self % nk , & self % emin % x , self % emin % y , self % emin % z , & self % emax % x , self % emax % y , self % emax % z , & self % is_cartesian , & self % is_null_x , self % is_null_y , self % is_null_z endsubroutine load_from_file elemental function nodes_number ( self , with_ghosts ) result ( nodes_number_ ) !< Return the number of nodes. class ( block_signature_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: nodes_number_ !< Number of nodes. logical :: with_ghosts_ !< Take into account ghost cells, local variable. with_ghosts_ = . true . ; if ( present ( with_ghosts )) with_ghosts_ = with_ghosts if ( with_ghosts_ ) then nodes_number_ = ( self % ni + self % gc ( 1 ) + self % gc ( 2 ) + 1 ) & * ( self % nj + self % gc ( 3 ) + self % gc ( 4 ) + 1 ) & * ( self % nk + self % gc ( 5 ) + self % gc ( 6 ) + 1 ) else nodes_number_ = ( self % ni + 1 ) & * ( self % nj + 1 ) & * ( self % nk + 1 ) endif endfunction nodes_number subroutine save_into_file ( self , file_unit ) !< Load the block signature of all blocks from file. class ( block_signature_object ), intent ( in ) :: self !< Block signature object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. write ( unit = file_unit ) self % id , & self % level , & self % gc , & self % ni , & self % nj , & self % nk , & self % emin % x , self % emin % y , self % emin % z , & self % emax % x , self % emax % y , self % emax % z , & self % is_cartesian , & self % is_null_x , self % is_null_y , self % is_null_z endsubroutine save_into_file ! private methods pure subroutine block_d_assign_block_d ( lhs , rhs ) !< Operator `=`. class ( block_signature_object ), intent ( inout ) :: lhs !< Left hand side. type ( block_signature_object ), intent ( in ) :: rhs !< Right hand side. lhs % id = rhs % id lhs % level = rhs % level lhs % gc = rhs % gc lhs % ni = rhs % ni lhs % nj = rhs % nj lhs % nk = rhs % nk lhs % emin = rhs % emin lhs % emax = rhs % emax lhs % is_cartesian = rhs % is_cartesian lhs % is_null_x = rhs % is_null_x lhs % is_null_y = rhs % is_null_y lhs % is_null_z = rhs % is_null_z endsubroutine block_d_assign_block_d endmodule off_block_signature_object","tags":"","loc":"sourcefile/off_block_signature_object.f90.html","title":"off_block_signature_object.f90 – OFF"},{"text":"OFF cell object definition and implementation. Files Dependent On This One sourcefile~~off_cell_object.f90~~AfferentGraph sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_cell_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_cell_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_cell_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_cell_object Source Code off_cell_object.f90 Source Code !< OFF cell object definition and implementation. module off_cell_object !< OFF cell object definition and implementation. use penf , only : R8P use vecfor , only : vector implicit none private public :: cell_object type :: cell_object !< Cell object class. type ( vector ) :: center !< Cell center. real ( R8P ) :: volume = 0._R8P !< Cell volume. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy cell. procedure , pass ( self ) :: initialize !< Initialize cell. ! operators generic :: assignment ( = ) => cell_assign_cell !< Overload `=`. ! private methods procedure , pass ( lhs ) :: cell_assign_cell !< Operator `=`. endtype cell_object contains ! public methods elemental subroutine destroy ( self ) !< Destroy cell. class ( cell_object ), intent ( inout ) :: self !< Cell object. type ( cell_object ) :: fresh !< Fresh instance of cell object. self = fresh endsubroutine destroy elemental subroutine initialize ( self ) !< Initialize cell. class ( cell_object ), intent ( inout ) :: self !< Cell object. call self % destroy endsubroutine initialize ! private methods pure subroutine cell_assign_cell ( lhs , rhs ) !< Operator `=`. class ( cell_object ), intent ( inout ) :: lhs !< Left hand side. type ( cell_object ), intent ( in ) :: rhs !< Right hand side. lhs % center = rhs % center lhs % volume = rhs % volume endsubroutine cell_assign_cell endmodule off_cell_object","tags":"","loc":"sourcefile/off_cell_object.f90.html","title":"off_cell_object.f90 – OFF"},{"text":"OFF error object definition and implementation. Files Dependent On This One sourcefile~~off_error_object.f90~~AfferentGraph sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_error_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_error_object.f90->sourcefile~off_solver_object.f90 sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_error_object.f90->sourcefile~off_non_dimensional_numbers_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_error_object.f90->sourcefile~off_objects.f90 sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_error_object.f90->sourcefile~off_time_object.f90 sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_error_object.f90->sourcefile~off_os_object.f90 sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_free_conditions_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 sourcefile~off_file_object.f90->sourcefile~off_objects.f90 sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_file_object.f90->sourcefile~off_files_collection_object.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_solver_object.f90->sourcefile~off_objects.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_objects.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_time_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_time_object.f90->sourcefile~off_objects.f90 sourcefile~off_os_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_os_object.f90->sourcefile~off_objects.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_files_collection_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_error_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_error_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_error_object Source Code off_error_object.f90 Source Code !< OFF error object definition and implementation. module off_error_object !< OFF error object definition and implementation. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf , only : I4P , str implicit none private public :: error_object type :: error_object !< Error object class. !< !< Handler of errors/excetpions. integer ( I4P ) :: status = 0_I4P !< Error status. character ( len = :), allocatable :: message !< Error message. contains ! public methods procedure , pass ( self ) :: check !< Check error status. procedure , pass ( self ) :: destroy !< Destroy error. procedure , pass ( self ) :: initialize !< Initialize error. ! operators generic :: assignment ( = ) => err_assign_err !< Overload `=`. ! private methods procedure , pass ( lhs ) :: err_assign_err !< Operator `=`. endtype error_object contains ! public methods subroutine check ( self , message , is_severe ) !< Check error status. !< !< If errors occurred, a warn is printed. class ( error_object ), intent ( inout ) :: self !< Error object. character ( * ), intent ( in ), optional :: message !< Error message. logical , intent ( in ), optional :: is_severe !< Enable severe error. logical :: is_severe_ !< Enable severe error, local variable. if ( self % status /= 0 ) then is_severe_ = . false . ; if ( present ( is_severe )) is_severe_ = is_severe if ( present ( message )) then self % message = 'error [' // trim ( str ( self % status )) // ']: ' // message else self % message = 'error [' // trim ( str ( self % status )) // ']' endif write ( stderr , '(A)' ) self % message if ( is_severe_ ) stop endif endsubroutine check elemental subroutine destroy ( self ) !< Destroy error. class ( error_object ), intent ( inout ) :: self !< Error object. type ( error_object ) :: fresh !< Fresh instance of error object. self = fresh if ( allocated ( self % message )) deallocate ( self % message ) endsubroutine destroy elemental subroutine initialize ( self ) !< Initialize error. class ( error_object ), intent ( inout ) :: self !< Error object. call self % destroy endsubroutine initialize ! private methods pure subroutine err_assign_err ( lhs , rhs ) !< Operator `=`. class ( error_object ), intent ( inout ) :: lhs !< Left hand side. type ( error_object ), intent ( in ) :: rhs !< Right hand side. lhs % status = rhs % status if ( allocated ( rhs % message )) lhs % message = rhs % message endsubroutine err_assign_err endmodule off_error_object","tags":"","loc":"sourcefile/off_error_object.f90.html","title":"off_error_object.f90 – OFF"},{"text":"OFF face object definition and implementation. Files Dependent On This One sourcefile~~off_face_object.f90~~AfferentGraph sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_face_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_face_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_face_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_face_object Source Code off_face_object.f90 Source Code !< OFF face object definition and implementation. module off_face_object !< OFF face object definition and implementation. use penf , only : R8P use vecfor , only : vector implicit none private public :: face_object type :: face_object !< Face object class. real ( R8P ) :: area = 0._R8P !< Area. type ( vector ) :: normal !< Normal versor. contains ! public methods procedure , pass ( self ) :: compute_metrics !< Compute face metrics. procedure , pass ( self ) :: destroy !< Destroy face. procedure , pass ( self ) :: initialize !< Initialize face. ! operators generic :: assignment ( = ) => face_assign_face !< Overload `=`. ! private methods procedure , pass ( lhs ) :: face_assign_face !< Operator `=`. endtype face_object contains ! public methods elemental subroutine compute_metrics ( self , pt1 , pt2 , pt3 , pt4 , signd ) !< Compute face metrics. class ( face_object ), intent ( inout ) :: self !< Face. type ( vector ), intent ( in ) :: pt1 !< Point 1 of face. type ( vector ), intent ( in ) :: pt2 !< Point 2 of face. type ( vector ), intent ( in ) :: pt3 !< Point 3 of face. type ( vector ), intent ( in ) :: pt4 !< Point 4 of face. real ( R8P ), intent ( in ) :: signd !< Sign of direction along normal coordinate. self % normal = self % normal % face_normal4 ( pt1 = pt1 , pt2 = pt2 , pt3 = pt3 , pt4 = pt4 ) * signd self % area = self % normal % normL2 () call self % normal % normalize endsubroutine compute_metrics elemental subroutine destroy ( self ) !< Destroy face. class ( face_object ), intent ( inout ) :: self !< Face object. type ( face_object ) :: fresh !< Fresh instance of face object. self = fresh endsubroutine destroy pure subroutine initialize ( self ) !< Initialize face. class ( face_object ), intent ( inout ) :: self !< Face object. call self % destroy endsubroutine initialize ! private methods pure subroutine face_assign_face ( lhs , rhs ) !< Operator `=`. class ( face_object ), intent ( inout ) :: lhs !< Left hand side. type ( face_object ), intent ( in ) :: rhs !< Right hand side. lhs % area = rhs % area lhs % normal = rhs % normal endsubroutine face_assign_face endmodule off_face_object","tags":"","loc":"sourcefile/off_face_object.f90.html","title":"off_face_object.f90 – OFF"},{"text":"OFF file grid object definition and implementation. This File Depends On sourcefile~~off_file_grid_object.f90~~EfferentGraph sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_file_grid_object.f90~~AfferentGraph sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_file_grid_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_file_grid_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_file_grid_object Source Code off_file_grid_object.f90 Source Code !< OFF file grid object definition and implementation. module off_file_grid_object !< OFF file grid object definition and implementation. !< The file grid is an unformatted, stream file containing the nodes coordinates of the whole grid. !< It skeleton is the following !< !<``` !< # header !< blocks_number !< # for each block !< id, level, gc, ni, nj, nk !< # core !< # for each block (for all nodes of block) !< node%vertex%x, node%vertex%y, node%vertex%z !<``` !< !< [[file_grid_object]] provides standard API for loading and saving this file. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use off_block_object , only : block_object use off_grid_dimensions_object , only : grid_dimensions_object use off_file_object , only : file_object use penf , only : I4P implicit none private public :: file_grid_object type , extends ( file_object ) :: file_grid_object !< File grid object class. contains ! public methods procedure , pass ( self ) :: load_grid_dimensions_from_file !< Load the grid dimensions of all blocks from file. procedure , pass ( self ) :: load_nodes_from_file !< Load nodes coordinates from file. procedure , pass ( self ) :: save_grid_dimensions_into_file !< Save the grid dimensions of all blocks into file. procedure , pass ( self ) :: save_nodes_into_file !< Save nodes coordinates into file. endtype file_grid_object contains ! public methods subroutine load_grid_dimensions_from_file ( self , grid_dimensions , file_name ) !< Load the grid dimensions of all blocks from file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( inout ) :: grid_dimensions !< Grid dimensions off all blocks into file. character ( * ), intent ( in ), optional :: file_name !< File name. call self % open ( file_name = file_name , action = 'read' ) call grid_dimensions % load_from_file ( file_unit = self % file_unit ) call self % close endsubroutine load_grid_dimensions_from_file subroutine load_nodes_from_file ( self , grid_dimensions , blocks , file_name ) !< Load nodes coordinates from file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( in ) :: grid_dimensions !< Grid dimensions off all blocks into file. type ( block_object ), intent ( inout ) :: blocks ( 1 :) !< Blocks storage. character ( * ), intent ( in ), optional :: file_name !< File name. integer ( I4P ) :: b !< Counter. call self % open ( file_name = file_name , action = 'read' ) do b = 1 , size ( blocks , dim = 1 ) call blocks ( b )% load_nodes_from_file ( file_unit = self % file_unit , pos = grid_dimensions % iopos_block_nodes ( b = b )) enddo call self % close endsubroutine load_nodes_from_file subroutine save_grid_dimensions_into_file ( self , grid_dimensions ) !< Load the grid dimensions of all blocks into file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( in ) :: grid_dimensions !< Grid dimensions off all blocks into file. call self % open ( action = 'write' ) call grid_dimensions % save_into_file ( file_unit = self % file_unit ) call self % close endsubroutine save_grid_dimensions_into_file subroutine save_nodes_into_file ( self , grid_dimensions , blocks ) !< Save nodes coordinates into file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( in ) :: grid_dimensions !< Grid dimensions off all blocks into file. type ( block_object ), intent ( inout ) :: blocks ( 1 :) !< Blocks storage. integer ( I4P ) :: b !< Counter. call self % open ( action = 'write' ) do b = 1 , size ( blocks , dim = 1 ) call blocks ( b )% save_nodes_into_file ( file_unit = self % file_unit , pos = grid_dimensions % iopos_block_nodes ( b = b )) enddo call self % close endsubroutine save_nodes_into_file endmodule off_file_grid_object","tags":"","loc":"sourcefile/off_file_grid_object.f90.html","title":"off_file_grid_object.f90 – OFF"},{"text":"OFF file object definition and implementation. This File Depends On sourcefile~~off_file_object.f90~~EfferentGraph sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_file_object.f90~~AfferentGraph sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_file_object.f90->sourcefile~off_files_collection_object.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_file_object.f90->sourcefile~off_objects.f90 sourcefile~off_files_collection_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_file_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_file_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_file_object Source Code off_file_object.f90 Source Code !< OFF file object definition and implementation. module off_file_object !< OFF file object definition and implementation. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use off_error_object , only : error_object use finer , only : file_ini use penf , only : I4P implicit none private public :: file_object public :: ERROR_ALREADY_CONNECTED public :: ERROR_NOT_CONNECTED public :: ERROR_NOT_INITIALIZED character ( len = 5 ), parameter :: UNSET_FILE_NAME = 'unset' !< Default, unset file name. integer ( I4P ), parameter :: ERROR_ALREADY_CONNECTED = 1 !< Already connected error code. integer ( I4P ), parameter :: ERROR_NOT_CONNECTED = 2 !< Not connected error code. integer ( I4P ), parameter :: ERROR_NOT_INITIALIZED = 3 !< Not initialized error code. type :: file_object !< File object class. type ( error_object ) :: error !< Errors handler. character ( len = :), allocatable :: file_name !< File name. integer ( I4P ) :: file_unit = 0 !< File unit. logical :: is_initialized = . false . !< Sentinel to check if file is initialized. logical :: is_connected = . false . !< Sentinel to check if file is connected. contains ! public methods procedure , pass ( self ) :: close !< Close file. procedure , pass ( self ) :: description !< Return a pretty-formatted description of the file. procedure , pass ( self ) :: destroy !< Destroy file. procedure , pass ( self ) :: initialize !< Initialize file. procedure , pass ( self ) :: load_file_name_from_file !< Load file name from file. procedure , pass ( self ) :: open !< Open file. procedure , pass ( self ) :: save_file_name_into_file !< Save file name into file. ! operators generic :: assignment ( = ) => file_assign_file !< Overload `=`. ! private methods procedure , pass ( lhs ) :: file_assign_file !< Operator `=`. endtype file_object contains ! public methods subroutine close ( self ) !< Close file. class ( file_object ), intent ( inout ) :: self !< File object. if ( self % is_initialized ) then if ( self % is_connected ) then close ( unit = self % file_unit ) self % file_unit = 0 self % is_connected = . false . else write ( stderr , '(A)' ) 'error: file \"' // self % file_name // '\" is not connected, thus its unit cannot be closed' self % error % status = ERROR_NOT_CONNECTED endif else write ( stderr , '(A)' ) 'error: file is not initialized, thus its unit cannot be closed' self % error % status = ERROR_NOT_INITIALIZED endif endsubroutine close pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the file. class ( file_object ), intent ( in ) :: self !< Files collection. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' if ( allocated ( self % file_name )) desc = desc // prefix_ // 'File name: ' // self % file_name endfunction description elemental subroutine destroy ( self ) !< Destroy file. class ( file_object ), intent ( inout ) :: self !< File object. type ( file_object ) :: fresh !< Fresh instance of file object. self = fresh if ( allocated ( self % file_name )) deallocate ( self % file_name ) endsubroutine destroy elemental subroutine initialize ( self , file_name ) !< Initialize File. !< !< @note Leading and trailing white spaces are removed from file name. class ( file_object ), intent ( inout ) :: self !< File object. character ( len =* ), intent ( in ), optional :: file_name !< File name. call self % destroy call self % error % initialize if ( present ( file_name )) then self % file_name = trim ( adjustl ( file_name )) else self % file_name = UNSET_FILE_NAME endif self % is_initialized = . true . endsubroutine initialize subroutine load_file_name_from_file ( self , fini , section_name , option_name , go_on_fail ) !< Load file name from file. class ( file_object ), intent ( inout ) :: self !< File object. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. character ( * ), intent ( in ) :: section_name !< Option name into the ini file. character ( * ), intent ( in ) :: option_name !< Option name into the ini file. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. character ( 999 ) :: buffer !< Buffer string. call fini % get ( section_name = section_name , option_name = option_name , val = buffer , error = self % error % status ) if ( present ( go_on_fail )) then if (. not . go_on_fail ) & call self % error % check ( message = 'failed to load [' // section_name // '].(' // option_name // ')' , is_severe = . not . go_on_fail ) endif if ( self % error % status <= 0 ) self % file_name = trim ( adjustl ( buffer )) endsubroutine load_file_name_from_file subroutine open ( self , file_name , format , action , access ) !< Open file. class ( file_object ), intent ( inout ) :: self !< File object. character ( len =* ), intent ( in ), optional :: file_name !< File name. character ( len =* ), intent ( in ), optional :: format !< File format. character ( len =* ), intent ( in ), optional :: action !< File action. character ( len =* ), intent ( in ), optional :: access !< File access. character ( len = :), allocatable :: file_name_ !< File name, local variable. character ( len = :), allocatable :: format_ !< File format, local variable. character ( len = :), allocatable :: action_ !< File action, local variable. character ( len = :), allocatable :: access_ !< File access, local variable. format_ = 'unformatted' ; if ( present ( format )) format_ = format action_ = 'readwrite' ; if ( present ( action )) action_ = action access_ = 'stream' ; if ( present ( access )) access_ = access if ( self % is_initialized ) then file_name_ = self % file_name ; if ( present ( file_name )) file_name_ = trim ( adjustl ( file_name )) if (. not . self % is_connected ) then open ( newunit = self % file_unit , file = file_name_ , form = format_ , action = action_ , access = access_ ) self % is_connected = . true . else write ( stderr , '(A)' ) 'error: file \"' // self % file_name // '\" is already connected, thus its unit cannot be re-open' self % error % status = ERROR_ALREADY_CONNECTED endif else write ( stderr , '(A)' ) 'error: file is not initialized, thus it cannot be open' self % error % status = ERROR_NOT_INITIALIZED endif endsubroutine open subroutine save_file_name_into_file ( self , fini , section_name , option_name ) !< Save file name into file. class ( file_object ), intent ( inout ) :: self !< File object. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. character ( * ), intent ( in ) :: section_name !< Option name into the ini file. character ( * ), intent ( in ) :: option_name !< Option name into the ini file. call fini % add ( section_name = section_name , option_name = option_name , val = self % file_name , error = self % error % status ) endsubroutine save_file_name_into_file ! private methods pure subroutine file_assign_file ( lhs , rhs ) !< Operator `=`. class ( file_object ), intent ( inout ) :: lhs !< Left hand side. type ( file_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error if ( allocated ( rhs % file_name )) lhs % file_name = rhs % file_name lhs % file_unit = rhs % file_unit lhs % is_initialized = rhs % is_initialized lhs % is_connected = rhs % is_connected endsubroutine file_assign_file endmodule off_file_object","tags":"","loc":"sourcefile/off_file_object.f90.html","title":"off_file_object.f90 – OFF"},{"text":"OFF files collection object definition and implementation. This File Depends On sourcefile~~off_files_collection_object.f90~~EfferentGraph sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_file_object.f90->sourcefile~off_files_collection_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_files_collection_object.f90~~AfferentGraph sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_files_collection_object.f90->sourcefile~off_objects.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_files_collection_object Source Code off_files_collection_object.f90 Source Code !< OFF files collection object definition and implementation. module off_files_collection_object !< OFF files collection object definition and implementation. use off_file_object , only : file_object use finer , only : file_ini use penf , only : I4P implicit none private public :: files_collection_object character ( len = 5 ), parameter :: INI_SECTION_NAME = 'files' !< INI (config) file section name containing the collection file names. type :: files_collection_object !< Files collection object class. type ( file_object ) :: boundary_conditions !< Boundary conditions file. type ( file_object ) :: grid !< Grid file. type ( file_object ) :: initial_conditions !< Initial conditions file. type ( file_object ) :: logging !< Logging file. type ( file_object ) :: solution !< Solution file. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of the files collection. procedure , pass ( self ) :: destroy !< Destroy files collection. procedure , pass ( self ) :: initialize !< Initialize files collection. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. endtype files_collection_object contains ! public methods pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the files collection. class ( files_collection_object ), intent ( in ) :: self !< Files collection. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix // 'Boundary conditions file:' // NL desc = desc // prefix // self % boundary_conditions % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Grid file:' // NL desc = desc // prefix // self % grid % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Initial conditions file:' // NL desc = desc // prefix // self % initial_conditions % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Logging file:' // NL desc = desc // prefix // self % logging % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Solution file:' // NL desc = desc // prefix // self % solution % description ( prefix = '  ' ) endfunction description elemental subroutine destroy ( self ) !< Destroy files collection. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. call self % boundary_conditions % destroy call self % grid % destroy call self % initial_conditions % destroy call self % logging % destroy call self % solution % destroy endsubroutine destroy elemental subroutine initialize ( self ) !< Initialize Files collection. !< !< @TODO Complete this. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. call self % destroy call self % boundary_conditions % initialize call self % grid % initialize call self % initial_conditions % initialize call self % logging % initialize call self % solution % initialize endsubroutine initialize subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails.. call self % boundary_conditions % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'boundary_conditions' , & go_on_fail = go_on_fail ) call self % grid % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'grid' , & go_on_fail = go_on_fail ) call self % initial_conditions % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'initial_conditions' , & go_on_fail = go_on_fail ) call self % logging % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'log' , & go_on_fail = go_on_fail ) call self % solution % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'solution' , & go_on_fail = go_on_fail ) endsubroutine load_from_file subroutine save_into_file ( self , fini ) !< Save from file. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call self % boundary_conditions % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'boundary_conditions' ) call self % grid % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'grid' ) call self % initial_conditions % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'initial_conditions' ) call self % logging % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'log' ) call self % solution % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'solution' ) endsubroutine save_into_file endmodule off_files_collection_object","tags":"","loc":"sourcefile/off_files_collection_object.f90.html","title":"off_files_collection_object.f90 – OFF"},{"text":"OFF free conditions object definition and implementation. This File Depends On sourcefile~~off_free_conditions_object.f90~~EfferentGraph sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_free_conditions_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_free_conditions_object.f90~~AfferentGraph sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_objects.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_free_conditions_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_free_conditions_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_free_conditions_object Source Code off_free_conditions_object.f90 Source Code !< OFF free conditions object definition and implementation. module off_free_conditions_object !< OFF free conditions object definition and implementation. use off_error_object , only : error_object use finer , only : file_ini use penf , only : I4P , R8P , str use vecfor , only : ex , ey , ez , vector implicit none private public :: free_conditions_object character ( len = 15 ), parameter :: INI_SECTION_NAME = 'free_conditions' !< INI (config) file section name containing the !< free stream conditions. type :: free_conditions_object !< Free conditions object class. !< !< Define the conditions of the **free stream**. type ( error_object ) :: error !< Errors handler. type ( vector ) :: velocity !< Velocity. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of the free conditions. procedure , pass ( self ) :: destroy !< Destroy free conditions. procedure , pass ( self ) :: initialize !< Initialize free conditions. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. ! operators generic :: assignment ( = ) => free_assign_free !< Overload `=`. ! private methods procedure , pass ( lhs ) :: free_assign_free !< Operator `=`. endtype free_conditions_object contains ! public methods pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the free conditions. class ( free_conditions_object ), intent ( in ) :: self !< Free conditions. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'velocity : ' // trim ( str ([ self % velocity % x , self % velocity % y , self % velocity % z ])) endfunction description elemental subroutine destroy ( self ) !< Destroy free conditions. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. type ( free_conditions_object ) :: fresh !< Fresh free conditions. self = fresh endsubroutine destroy elemental subroutine initialize ( self ) !< Initialize free conditions. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. call self % destroy endsubroutine initialize subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. real ( R8P ) :: velocity ( 1 : 3 ) !< Velocity loading buffer. call fini % get ( section_name = INI_SECTION_NAME , option_name = 'velocity' , val = velocity , error = self % error % status ) if ( present ( go_on_fail )) then if (. not . go_on_fail ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(velocity)' , is_severe = . not . go_on_fail ) endif if ( self % error % status <= 0 ) self % velocity = ex * velocity ( 1 ) + ey * velocity ( 2 ) + ez * velocity ( 3 ) endsubroutine load_from_file subroutine save_into_file ( self , fini ) !< Save into file. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'velocity' , val = [ self % velocity % x , self % velocity % y , self % velocity % z ], & error = self % error % status ) endsubroutine save_into_file ! private methods pure subroutine free_assign_free ( lhs , rhs ) !< Operator `=`. class ( free_conditions_object ), intent ( inout ) :: lhs !< Left hand side. type ( free_conditions_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % velocity = rhs % velocity endsubroutine free_assign_free endmodule off_free_conditions_object","tags":"","loc":"sourcefile/off_free_conditions_object.f90.html","title":"off_free_conditions_object.f90 – OFF"},{"text":"OFF grid dimensions object definition and implementation. This File Depends On sourcefile~~off_grid_dimensions_object.f90~~EfferentGraph sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_grid_dimensions_object.f90~~AfferentGraph sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_grid_dimensions_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_grid_dimensions_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_grid_dimensions_object Source Code off_grid_dimensions_object.f90 Source Code !< OFF grid dimensions object definition and implementation. module off_grid_dimensions_object !< OFF grid dimensions object definition and implementation. use off_block_signature_object , only : block_signature_object use penf , only : I4P , I8P use vecfor , only : vector implicit none private public :: grid_dimensions_object type :: grid_dimensions_object !< Grid dimensions object class. integer ( I4P ) :: blocks_number = 0 !< Number of blocks, blobal (whole) number on all process/image. type ( block_signature_object ), allocatable :: block_signature (:) !< Signature of each block. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of grid dimensions. procedure , pass ( self ) :: destroy !< Destroy grid dimensions. procedure , pass ( self ) :: initialize !< Initialize grid dimensions. procedure , pass ( self ) :: iolength !< Return the IO length storage. procedure , pass ( self ) :: iopos_block_nodes !< Return the IO position where nodes of block b-th are stored. procedure , pass ( self ) :: load_from_file !< Load grid dimensions from file. procedure , pass ( self ) :: save_into_file !< Save grid dimensions into file. ! operators generic :: assignment ( = ) => grid_d_assign_grid_d !< Overload `=`. ! private methods procedure , pass ( lhs ) :: grid_d_assign_grid_d !< Operator `=`. endtype grid_dimensions_object contains ! public methods pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the grid dimensions. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. integer ( I4P ) :: b !< Counter. desc = '' if ( self % blocks_number > 0 ) then do b = 1 , self % blocks_number - 1 desc = desc // self % block_signature ( b )% description ( prefix = prefix ) // NL // NL enddo desc = desc // self % block_signature ( self % blocks_number )% description ( prefix = prefix ) endif endfunction description elemental subroutine destroy ( self ) !< Destroy grid dimensions. class ( grid_dimensions_object ), intent ( inout ) :: self !< Grid dimensions object. type ( grid_dimensions_object ) :: fresh !< Fresh instance of grid dimensions object. self = fresh if ( allocated ( self % block_signature )) then call self % block_signature % destroy deallocate ( self % block_signature ) endif endsubroutine destroy pure subroutine initialize ( self , block_signature ) !< Initialize grid dimensions. class ( grid_dimensions_object ), intent ( inout ) :: self !< Grid dimensions object. type ( block_signature_object ), intent ( in ), optional :: block_signature ( 1 :) !< Dimensions of each block. call self % destroy if ( present ( block_signature )) then self % blocks_number = size ( block_signature , dim = 1 ) allocate ( self % block_signature ( 1 : self % blocks_number ), source = block_signature ) endif endsubroutine initialize function iolength ( self ) !< Return the IO length storage. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. integer ( I4P ) :: iolength !< IO length storage. inquire ( iolength = iolength ) self % blocks_number if ( self % blocks_number > 0 ) iolength = iolength + self % blocks_number * self % block_signature ( 1 )% iolength () endfunction iolength function iopos_block_nodes ( self , b ) !< Return the IO position where nodes of block b-th are stored. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. integer ( I4P ), intent ( in ) :: b !< Block index. integer ( I4P ) :: iopos_block_nodes !< IO position where nodes of block b-th are stored. type ( vector ) :: node !< A node coordinate prototype. integer ( I4P ) :: node_iolength !< Node IO length storage. integer ( I4P ) :: bb !< Counter. inquire ( iolength = node_iolength ) node % x , node % y , node % z iopos_block_nodes = self % iolength () ! file header length if ( self % blocks_number > 0 ) then if ( b > 1. and . b <= self % blocks_number ) then ! b-th block, there are the file header and [1:b-1] blocks before its nodes do bb = 1 , b - 1 iopos_block_nodes = iopos_block_nodes + self % block_signature ( bb )% nodes_number () * node_iolength enddo iopos_block_nodes = iopos_block_nodes + 1 else ! first block, there is only the file header before its nodes iopos_block_nodes = iopos_block_nodes + 1 endif endif endfunction iopos_block_nodes subroutine load_from_file ( self , file_unit ) !< Load grid dimensions from file. class ( grid_dimensions_object ), intent ( inout ) :: self !< Grid dimensions object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ) :: b !< Counter. call self % destroy read ( unit = file_unit ) self % blocks_number if ( self % blocks_number > 0 ) then allocate ( self % block_signature ( 1 : self % blocks_number )) do b = 1 , self % blocks_number call self % block_signature ( b )% load_from_file ( file_unit = file_unit ) enddo endif endsubroutine load_from_file subroutine save_into_file ( self , file_unit ) !< Load the grid dimensions of all blocks from file. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ) :: b !< Counter. if ( self % blocks_number > 0 ) then write ( unit = file_unit ) self % blocks_number do b = 1 , self % blocks_number call self % block_signature ( b )% save_into_file ( file_unit = file_unit ) enddo endif endsubroutine save_into_file ! private methods pure subroutine grid_d_assign_grid_d ( lhs , rhs ) !< Operator `=`. class ( grid_dimensions_object ), intent ( inout ) :: lhs !< Left hand side. type ( grid_dimensions_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % block_signature )) then call lhs % destroy lhs % blocks_number = rhs % blocks_number allocate ( lhs % block_signature , source = rhs % block_signature ) endif endsubroutine grid_d_assign_grid_d endmodule off_grid_dimensions_object","tags":"","loc":"sourcefile/off_grid_dimensions_object.f90.html","title":"off_grid_dimensions_object.f90 – OFF"},{"text":"OFF node object definition and implementation. Files Dependent On This One sourcefile~~off_node_object.f90~~AfferentGraph sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_node_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_node_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_node_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_node_object Source Code off_node_object.f90 Source Code !< OFF node object definition and implementation. module off_node_object !< OFF node object definition and implementation. use vecfor , only : vector implicit none private public :: node_object type :: node_object !< Node object class. type ( vector ) :: vertex !< Vertex coordinates. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy node. procedure , pass ( self ) :: initialize !< Initialize node. ! operators generic :: assignment ( = ) => node_assign_node !< Overload `=`. ! private methods procedure , pass ( lhs ) :: node_assign_node !< Operator `=`. endtype node_object contains ! public methods elemental subroutine destroy ( self ) !< Destroy node. class ( node_object ), intent ( inout ) :: self !< Node object. type ( node_object ) :: fresh !< Fresh instance of node object. self = fresh endsubroutine destroy pure subroutine initialize ( self ) !< Initialize node. class ( node_object ), intent ( inout ) :: self !< Node object. call self % destroy endsubroutine initialize ! private methods pure subroutine node_assign_node ( lhs , rhs ) !< Operator `=`. class ( node_object ), intent ( inout ) :: lhs !< Left hand side. type ( node_object ), intent ( in ) :: rhs !< Right hand side. lhs % vertex = rhs % vertex endsubroutine node_assign_node endmodule off_node_object","tags":"","loc":"sourcefile/off_node_object.f90.html","title":"off_node_object.f90 – OFF"},{"text":"OFF non dimensional numbers object definition and implementation. This File Depends On sourcefile~~off_non_dimensional_numbers_object.f90~~EfferentGraph sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_non_dimensional_numbers_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_non_dimensional_numbers_object.f90~~AfferentGraph sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_objects.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 var pansourcefileoff_non_dimensional_numbers_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_non_dimensional_numbers_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_non_dimensional_numbers_object Source Code off_non_dimensional_numbers_object.f90 Source Code !< OFF non dimensional numbers object definition and implementation. module off_non_dimensional_numbers_object !< OFF non dimensional numbers object definition and implementation. use off_error_object , only : error_object use finer , only : file_ini use penf , only : I4P , R8P , str implicit none private public :: non_dimensional_numbers_object character ( len = 23 ), parameter :: INI_SECTION_NAME = 'non_dimensional_numbers' !< INI (config) file section name containing the values !< of non dimensional numbers. type :: non_dimensional_numbers_object !< Non dimensional numbers object class. type ( error_object ) :: error !< Errors handler. ! non dimensional numbers imposed real ( R8P ) :: Re = 1._R8P !< \\rm{Re}=\\frac{\\rho_0 v_0 L_0}{\\mu_0} Reynolds number. real ( R8P ) :: Fr = 1._R8P !< \\rm{Fr}=\\sqrt{\\frac{v_0&#94;2}{f_0 L_0}} Froude number. real ( R8P ) :: We = 1._R8P !< \\rm{We}=\\sqrt{\\frac{\\rho_0 v_0&#94;2 L_0}{\\sigma_0}} Weber number. real ( R8P ) :: Ma = 1._R8P !< \\rm{We}=\\sqrt{\\frac{v_0}{a_0}} Mach number. real ( R8P ) :: Pr = 1._R8P !< \\rm{Pr}=\\frac{\\mu_0 c_p}{k_0} Prandtl number. ! reference values imposed real ( R8P ) :: L0 = 1._R8P !< Reference length. real ( R8P ) :: r0 = 1._R8P !< Reference density. real ( R8P ) :: v0 = 1._R8P !< Reference velocity. real ( R8P ) :: c0 = 1._R8P !< Reference specific heats (\\f$cp_0 = cv_0 = R_0 = c_0\\f$). ! derived reference values real ( R8P ) :: mu0 = 1._R8P !< \\mu_0= \\frac{\\rho_0 v_0 L_0}{\\rm{Re}} Reference dynamic viscosity. real ( R8P ) :: f0 = 1._R8P !< f_0= \\frac{v_0&#94;2}{L_0 \\rm{Fr}&#94;2} Reference specific force. real ( R8P ) :: k0 = 1._R8P !< k_0= \\frac{\\mu_0 c_0}{\\rm{Pr}} Reference thermal conductivity coefficient. real ( R8P ) :: Dt0 = 1._R8P !< Dt_0=\\frac{L_0}{v_0} Reference time interval. real ( R8P ) :: p0 = 1._R8P !< p_0=\\rho_0 v_0&#94;2 Reference pressure. real ( R8P ) :: a0 = 1._R8P !< a_0=v_0 Reference speed of sound. real ( R8P ) :: T0 = 1._R8P !< T_0=\\frac{v_0&#94;2}{c_0} Reference temperature. real ( R8P ) :: E0 = 1._R8P !< E_0=v_0&#94;2 Reference specific energy. real ( R8P ) :: q0 = 1._R8P !< q_0=\\frac{v_0&#94;3}{L_0} Reference specific heat. ! equations coefficients real ( R8P ) :: Re_inv = 1._R8P !< \\frac{1}{\\rm{Re}} Inverse of Reynolds number (coefficient of viscous terms). real ( R8P ) :: Fr2_inv = 1._R8P !< \\frac{1}{\\rm{Fr}&#94;2} Inverse of square of Froude number (coefficient of volume forces). real ( R8P ) :: PrRe_inv = 1._R8P !< \\frac{1}{\\rm{Pr Re}} Inverse of Prandtl and Reynolds numbers (coef. of condution terms). contains ! public methods procedure , pass ( self ) :: compute_reference_values !< Compute derived reference values. procedure , pass ( self ) :: description !< Return a pretty-formatted description of the numbers. procedure , pass ( self ) :: destroy !< Destroy numbers value. procedure , pass ( self ) :: initialize !< Initialize numbers value. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. ! operators generic :: assignment ( = ) => adim_assign_adim !< Overload `=`. ! private methods procedure , pass ( lhs ) :: adim_assign_adim !< Operator `=`. endtype non_dimensional_numbers_object contains ! public methods elemental subroutine compute_reference_values ( self ) !< Compute derived reference values. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. self % mu0 = ( self % r0 * self % v0 * self % L0 ) / self % Re self % f0 = ( self % v0 * self % v0 ) / ( self % L0 * self % Fr * self % Fr ) self % k0 = ( self % mu0 * self % c0 ) / self % Pr self % Dt0 = self % L0 / self % v0 self % p0 = self % r0 * self % v0 * self % v0 self % a0 = self % v0 self % T0 = ( self % v0 * self % v0 ) / self % c0 self % E0 = self % v0 * self % v0 self % q0 = ( self % v0 * self % v0 * self % v0 ) / self % L0 self % Re_inv = 1._R8P / self % Re self % Fr2_inv = 1._R8P / ( self % Fr * self % Fr ) self % PrRe_inv = 1._R8P / ( self % Pr * self % Re ) endsubroutine compute_reference_values pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the numbers. class ( non_dimensional_numbers_object ), intent ( in ) :: self !< Non dimensional numbers. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'Re      : ' // trim ( str ( n = self % Re )) // NL desc = desc // prefix_ // 'Fr      : ' // trim ( str ( n = self % Fr )) // NL desc = desc // prefix_ // 'We      : ' // trim ( str ( n = self % We )) // NL desc = desc // prefix_ // 'Ma      : ' // trim ( str ( n = self % Ma )) // NL desc = desc // prefix_ // 'Pr      : ' // trim ( str ( n = self % Pr )) // NL desc = desc // prefix_ // 'L0      : ' // trim ( str ( n = self % L0 )) // NL desc = desc // prefix_ // 'r0      : ' // trim ( str ( n = self % r0 )) // NL desc = desc // prefix_ // 'v0      : ' // trim ( str ( n = self % v0 )) // NL desc = desc // prefix_ // 'c0      : ' // trim ( str ( n = self % c0 )) // NL desc = desc // prefix_ // 'mu0     : ' // trim ( str ( n = self % mu0 )) // NL desc = desc // prefix_ // 'f0      : ' // trim ( str ( n = self % f0 )) // NL desc = desc // prefix_ // 'k0      : ' // trim ( str ( n = self % k0 )) // NL desc = desc // prefix_ // 'Dt0     : ' // trim ( str ( n = self % Dt0 )) // NL desc = desc // prefix_ // 'p0      : ' // trim ( str ( n = self % p0 )) // NL desc = desc // prefix_ // 'a0      : ' // trim ( str ( n = self % a0 )) // NL desc = desc // prefix_ // 'T0      : ' // trim ( str ( n = self % T0 )) // NL desc = desc // prefix_ // 'E0      : ' // trim ( str ( n = self % E0 )) // NL desc = desc // prefix_ // 'q0      : ' // trim ( str ( n = self % q0 )) // NL desc = desc // prefix_ // 'Re_inv  : ' // trim ( str ( n = self % Re_inv )) // NL desc = desc // prefix_ // 'Fr2_inv : ' // trim ( str ( n = self % Fr2_inv )) // NL desc = desc // prefix_ // 'PrRe_inv: ' // trim ( str ( n = self % PrRe_inv )) endfunction description elemental subroutine destroy ( self ) !< Destroy numbers value. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. type ( non_dimensional_numbers_object ) :: fresh !< Fresh instance of non dimensional numbers. self = fresh endsubroutine destroy elemental subroutine initialize ( self ) !< Initialize numbers value. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. call self % destroy endsubroutine initialize subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Re' , val = self % Re , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Re)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Fr' , val = self % Fr , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Fr)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'We' , val = self % We , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(We)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Ma' , val = self % Ma , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Me)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Pr' , val = self % Pr , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Pr)' , is_severe = . not . go_on_fail_ ) call self % compute_reference_values endsubroutine load_from_file subroutine save_into_file ( self , fini ) !< Save into file. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Simulation parameters. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Re' , val = self % Re , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Fr' , val = self % Fr , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'We' , val = self % We , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Ma' , val = self % Ma , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Pr' , val = self % Pr , error = self % error % status ) endsubroutine save_into_file ! private methods pure subroutine adim_assign_adim ( lhs , rhs ) !< Operator `=`. class ( non_dimensional_numbers_object ), intent ( inout ) :: lhs !< Left hand side. type ( non_dimensional_numbers_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % Re = rhs % Re lhs % Fr = rhs % Fr lhs % We = rhs % We lhs % Ma = rhs % Ma lhs % Pr = rhs % Pr lhs % L0 = rhs % L0 lhs % r0 = rhs % r0 lhs % v0 = rhs % v0 lhs % c0 = rhs % c0 lhs % mu0 = rhs % mu0 lhs % f0 = rhs % f0 lhs % k0 = rhs % k0 lhs % Dt0 = rhs % Dt0 lhs % p0 = rhs % p0 lhs % a0 = rhs % a0 lhs % T0 = rhs % T0 lhs % E0 = rhs % E0 lhs % q0 = rhs % q0 lhs % Re_inv = rhs % Re_inv lhs % Fr2_inv = rhs % Fr2_inv lhs % PrRe_inv = rhs % PrRe_inv endsubroutine adim_assign_adim endmodule off_non_dimensional_numbers_object","tags":"","loc":"sourcefile/off_non_dimensional_numbers_object.f90.html","title":"off_non_dimensional_numbers_object.f90 – OFF"},{"text":"OFF objects collection. This File Depends On sourcefile~~off_objects.f90~~EfferentGraph sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_file_object.f90->sourcefile~off_objects.f90 sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_file_object.f90->sourcefile~off_files_collection_object.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_solver_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_files_collection_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_os_object.f90->sourcefile~off_objects.f90 sourcefile~off_os_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_objects.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 sourcefile~off_error_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90->sourcefile~off_solver_object.f90 sourcefile~off_error_object.f90->sourcefile~off_os_object.f90 sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_error_object.f90->sourcefile~off_time_object.f90 sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_error_object.f90->sourcefile~off_non_dimensional_numbers_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_face_object.f90->sourcefile~off_objects.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_node_object.f90->sourcefile~off_objects.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_objects.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_time_object.f90->sourcefile~off_objects.f90 sourcefile~off_time_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_objects.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_simulation_object.f90 var pansourcefileoff_objectsf90EfferentGraph = svgPanZoom('#sourcefileoff_objectsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_objects.f90~~AfferentGraph sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_objects Source Code off_objects.f90 Source Code !< OFF objects collection. module off_objects !< OFF objects collection. !< !< This is convenient entry point to access all OFF objects. use off_block_object , only : block_object use off_block_signature_object , only : block_signature_object use off_cell_object , only : cell_object use off_error_object , only : error_object use off_face_object , only : face_object use off_file_object , only : file_object use off_file_grid_object , only : file_grid_object use off_files_collection_object , only : files_collection_object use off_free_conditions_object , only : free_conditions_object use off_grid_dimensions_object , only : grid_dimensions_object use off_node_object , only : node_object use off_non_dimensional_numbers_object , only : non_dimensional_numbers_object use off_os_object , only : os_object use off_simulation_object , only : simulation_object use off_solver_object , only : solver_object use off_time_object , only : time_object implicit none private public :: block_object public :: block_signature_object public :: cell_object public :: error_object public :: face_object public :: file_object public :: file_grid_object public :: files_collection_object public :: free_conditions_object public :: grid_dimensions_object public :: node_object public :: non_dimensional_numbers_object public :: os_object public :: simulation_object public :: solver_object public :: time_object endmodule off_objects","tags":"","loc":"sourcefile/off_objects.f90.html","title":"off_objects.f90 – OFF"},{"text":"OFF OS object definition and implementation. This File Depends On sourcefile~~off_os_object.f90~~EfferentGraph sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_os_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_os_object.f90~~AfferentGraph sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_os_object.f90->sourcefile~off_objects.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_os_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_os_object Source Code off_os_object.f90 Source Code !< OFF OS object definition and implementation. module off_os_object !< OFF OS object definition and implementation. use off_error_object , only : error_object use penf , only : I4P use stringifor , only : string implicit none private public :: os_object integer ( I4P ), parameter :: NO_ERROR = 0 !< No errors occurred. integer ( I4P ), parameter :: ERROR_CP_FAILED = 1 !< Failed to copy files/directories. integer ( I4P ), parameter :: ERROR_MKDIR_FAILED = 2 !< Failed to create directory. integer ( I4P ), parameter :: ERROR_RM_FAILED = 3 !< Failed to remove files/directories. integer ( I4P ), parameter :: ERROR_FALLBACK_INIT = 4 !< Failed to set custom OS, used fallback system (unix). type :: os_object !< OS object class. !< !< This class is designed as an helper for performing system calls, e.g. make directory, copy files, etc... type ( error_object ) :: error !< Error handler. character ( len = :), allocatable :: path_separator !< Path seperator, e.g. \"/\" for unix-like systems. character ( len = :), allocatable :: cp_dir_command !< Copy directory command. character ( len = :), allocatable :: cp_file_command !< Copy file command. character ( len = :), allocatable :: mkdir_command !< Make directory command. character ( len = :), allocatable :: rm_dir_command !< Remove directory command. character ( len = :), allocatable :: rm_file_command !< Remove file command. contains ! public methods procedure , pass ( self ) :: cp !< Copy files/directories. procedure , pass ( self ) :: destroy !< Destroy OS... not your :-) procedure , pass ( self ) :: initialize !< Initialze OS. procedure , pass ( self ) :: mkdir !< Make directory. procedure , pass ( self ) :: rm !< Remove files/directories. ! operators generic :: assignment ( = ) => os_assign_os !< Overload `=`. ! private methods procedure , pass ( self ) :: initialize_unix !< Initialze OS as unix-like system. procedure , pass ( self ) :: initialize_windows !< Initialze OS as windows-like system. procedure , pass ( lhs ) :: os_assign_os !< Operator `=`. endtype os_object contains ! public methods subroutine cp ( self , file_name , dir_name ) !< Copy files/directories. !< !< @note leading and trailing white spaces are trimmed out. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ), optional :: file_name !< File name. character ( * ), intent ( in ), optional :: dir_name !< Dir name. if ( present ( file_name )) then call execute_command_line ( command = self % cp_file_command // ' ' // trim ( adjustl ( file_name )), exitstat = self % error % status ) elseif ( present ( dir_name )) then call execute_command_line ( command = self % cp_dir_command // ' ' // trim ( adjustl ( dir_name )), exitstat = self % error % status ) else self % error % status = ERROR_CP_FAILED endif endsubroutine cp elemental subroutine destroy ( self ) !< Destroy OS... not your :-) class ( os_object ), intent ( inout ) :: self !< OS. type ( os_object ) :: fresh !< Fresh instance of OS. self = fresh if ( allocated ( self % path_separator )) deallocate ( self % path_separator ) if ( allocated ( self % cp_dir_command )) deallocate ( self % cp_dir_command ) if ( allocated ( self % cp_file_command )) deallocate ( self % cp_file_command ) if ( allocated ( self % mkdir_command )) deallocate ( self % mkdir_command ) if ( allocated ( self % rm_dir_command )) deallocate ( self % rm_dir_command ) if ( allocated ( self % rm_file_command )) deallocate ( self % rm_file_command ) endsubroutine destroy elemental subroutine initialize ( self , system ) !< Initialize OS. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ), optional :: system !< System name, valid [unix, windows]. type ( string ) :: system_ !< System name. self % error % status = 0 system_ = 'UNIX' if ( present ( system )) then system_ = trim ( adjustl ( system )) system_ = system_ % upper () endif select case ( system_ % chars ()) case ( 'UNIX' ) call self % initialize_unix case ( 'WINDOWS' ) call self % initialize_windows case default call self % initialize_unix self % error % status = ERROR_FALLBACK_INIT endselect endsubroutine initialize subroutine mkdir ( self , dir_name ) !< Make directoriy. !< !< @note leading and trailing white spaces are trimmed out. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ) :: dir_name !< Dir name. call execute_command_line ( command = self % mkdir_command // ' ' // trim ( adjustl ( dir_name )), exitstat = self % error % status ) endsubroutine mkdir subroutine rm ( self , file_name , dir_name ) !< Remove files/directories. !< !< @note leading and trailing white spaces are trimmed out. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ), optional :: file_name !< File name. character ( * ), intent ( in ), optional :: dir_name !< Dir name. if ( present ( file_name )) then call execute_command_line ( command = self % rm_file_command // ' ' // trim ( adjustl ( file_name )), exitstat = self % error % status ) elseif ( present ( dir_name )) then call execute_command_line ( command = self % rm_dir_command // ' ' // trim ( adjustl ( dir_name )), exitstat = self % error % status ) else self % error % status = ERROR_RM_FAILED endif endsubroutine rm ! private methods elemental subroutine initialize_unix ( self ) !< Initialize OS as unix-like system. class ( os_object ), intent ( inout ) :: self !< OS. call self % destroy self % path_separator = char ( 47 ) self % cp_dir_command = 'cp -r' self % cp_file_command = 'cp' self % mkdir_command = 'mkdir -p' self % rm_dir_command = 'rm -fr' self % rm_file_command = 'rm -f' endsubroutine initialize_unix elemental subroutine initialize_windows ( self ) !< Initialize OS as windows-like system. class ( os_object ), intent ( inout ) :: self !< OS. call self % destroy self % path_separator = char ( 92 ) self % cp_dir_command = 'copy' self % cp_file_command = 'copy' self % mkdir_command = 'mkdir' self % rm_dir_command = 'del' self % rm_file_command = 'del' endsubroutine initialize_windows pure subroutine os_assign_os ( lhs , rhs ) !< Operator `=`. class ( os_object ), intent ( inout ) :: lhs !< Left hand side. type ( os_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error if ( allocated ( rhs % path_separator )) lhs % path_separator = rhs % path_separator if ( allocated ( rhs % cp_dir_command )) lhs % cp_dir_command = rhs % cp_dir_command if ( allocated ( rhs % cp_file_command )) lhs % cp_file_command = rhs % cp_file_command if ( allocated ( rhs % mkdir_command )) lhs % mkdir_command = rhs % mkdir_command if ( allocated ( rhs % rm_dir_command )) lhs % rm_dir_command = rhs % rm_dir_command if ( allocated ( rhs % rm_file_command )) lhs % rm_file_command = rhs % rm_file_command endsubroutine os_assign_os endmodule off_os_object","tags":"","loc":"sourcefile/off_os_object.f90.html","title":"off_os_object.f90 – OFF"},{"text":"OFF simulation object definition and implementation. This File Depends On sourcefile~~off_simulation_object.f90~~EfferentGraph sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_solver_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90->sourcefile~off_non_dimensional_numbers_object.f90 sourcefile~off_error_object.f90->sourcefile~off_solver_object.f90 sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_error_object.f90->sourcefile~off_os_object.f90 sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_free_conditions_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_error_object.f90->sourcefile~off_time_object.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_os_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_time_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 var pansourcefileoff_simulation_objectf90EfferentGraph = svgPanZoom('#sourcefileoff_simulation_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_simulation_object.f90~~AfferentGraph sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_simulation_object Source Code off_simulation_object.f90 Source Code !< OFF simulation object definition and implementation. module off_simulation_object !< OFF simulation object definition and implementation. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use off_block_object , only : block_object use off_error_object , only : error_object use off_free_conditions_object , only : free_conditions_object use off_file_grid_object , only : file_grid_object use off_grid_dimensions_object , only : grid_dimensions_object use off_non_dimensional_numbers_object , only : non_dimensional_numbers_object use off_os_object , only : os_object use off_solver_object , only : solver_object use off_time_object , only : time_object use finer , only : file_ini use flap , only : command_line_interface use penf , only : I4P , str implicit none private public :: simulation_object type :: simulation_object !< Simulation object class. !< !< [[simulation_object]] is a container for all simulation data for each processor/image. type ( error_object ) :: error !< Errors handler. type ( command_line_interface ) :: cli !< Command line interface. type ( file_grid_object ) :: file_grid !< Grid file handler. type ( non_dimensional_numbers_object ) :: adimensionals !< Non dimensional numbers. type ( free_conditions_object ) :: free_conditions !< Free stream conditions. type ( os_object ) :: os !< Running Operating System. type ( solver_object ) :: solver !< solver models parameters. type ( time_object ) :: time !< Timing conditions. type ( grid_dimensions_object ) :: grid_dimensions !< Grid dimensions. type ( block_object ), allocatable :: blocks (:) !< Blocks list. logical :: is_cli_parsed = . false . !< Sentinel of CLI parsing. character ( 999 ) :: file_parameters = '' !< Name of simulation parameters file. logical :: is_output_verbose = . false . !< Verbose output. logical :: go_on_fail = . false . !< Allow/disallow parameters loading failure. contains ! public methods procedure , pass ( self ) :: allocate_blocks !< Allocate blocks accordingly to grid dimensions. procedure , pass ( self ) :: description !< Return a pretty-formatted description of the simulation. procedure , pass ( self ) :: destroy !< Destroy simulation data. procedure , pass ( self ) :: initialize !< Initialize simulation. procedure , pass ( self ) :: integrate !< Integrate the equations. procedure , pass ( self ) :: load_file_grid !< Load grid file. procedure , pass ( self ) :: load_file_parameters !< Load file parameters. procedure , pass ( self ) :: load_input_files !< Load input files. procedure , pass ( self ) :: parse_command_line_interface !< Parse command line interface. procedure , pass ( self ) :: save_file_grid !< Save grid file. procedure , pass ( self ) :: save_file_parameters !< Save file parameters. ! private methods procedure , pass ( self ), private :: set_command_line_interface !< Set command line interface. endtype simulation_object contains ! public methods subroutine allocate_blocks ( self ) !< Allocate blocks accordingly to grid dimensions. class ( simulation_object ), intent ( inout ) :: self !< Simulation data. integer ( I4P ) :: b !< Counter. if ( self % grid_dimensions % blocks_number > 0 ) then if ( allocated ( self % blocks )) then call self % blocks % destroy deallocate ( self % blocks ) endif allocate ( self % blocks ( 1 : self % grid_dimensions % blocks_number )) do b = 1 , self % grid_dimensions % blocks_number call self % blocks ( b )% initialize ( signature = self % grid_dimensions % block_signature ( b )) enddo endif endsubroutine allocate_blocks pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the simulation. class ( simulation_object ), intent ( in ) :: self !< Simulation parameters. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' ! desc = desc//prefix_//'Files:'//NL ! desc = desc//prefix//self%files_collection%description(prefix='  ')//NL desc = desc // prefix_ // 'Non dimensional numbers:' // NL desc = desc // prefix_ // self % adimensionals % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Free stream conditions:' // NL desc = desc // prefix_ // self % free_conditions % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Solver models:' // NL desc = desc // prefix_ // self % solver % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Time:' // NL desc = desc // prefix_ // self % time % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Grid dimensions:' // NL desc = desc // prefix_ // self % grid_dimensions % description ( prefix = prefix_ // '  ' ) endfunction description elemental subroutine destroy ( self ) !< Destroy simulation data. class ( simulation_object ), intent ( inout ) :: self !< Simulation data. call self % error % destroy call self % cli % free call self % adimensionals % destroy call self % file_grid % destroy call self % free_conditions % destroy call self % os % destroy call self % solver % destroy call self % time % destroy call self % grid_dimensions % destroy if ( allocated ( self % blocks )) then call self % blocks % destroy deallocate ( self % blocks ) endif self % is_cli_parsed = . false . self % file_parameters = '' self % is_output_verbose = . false . self % go_on_fail = . false . endsubroutine destroy subroutine initialize ( self , blocks , parse_cli , load_files ) !< Initialize simulation. class ( simulation_object ), intent ( inout ) :: self !< simulation data. type ( block_object ), intent ( in ), optional :: blocks ( 1 :) !< Blocks structure. logical , intent ( in ), optional :: parse_cli !< Enable CLI parsing. logical , intent ( in ), optional :: load_files !< Enable files loading. logical :: parse_cli_ !< Enable CLI parsing, local variable. logical :: load_files_ !< Enable files loading, local variable. parse_cli_ = . false . ; if ( present ( parse_cli )) parse_cli_ = parse_cli load_files_ = . false . ; if ( present ( load_files )) load_files_ = load_files call self % destroy call self % error % initialize call self % adimensionals % initialize call self % file_grid % initialize call self % free_conditions % initialize call self % os % initialize call self % solver % initialize call self % time % initialize call self % grid_dimensions % initialize if ( parse_cli_ ) call self % parse_command_line_interface if ( load_files_ ) call self % load_input_files if ( present ( blocks )) then call self % grid_dimensions % initialize ( block_signature = blocks % signature ) allocate ( self % blocks ( 1 : size ( blocks , dim = 1 )), source = blocks ) endif if ( self % is_output_verbose ) print '(A)' , self % description () endsubroutine initialize subroutine integrate ( self ) !< Integrate the equations. !< !< @TODO Implement this. class ( simulation_object ), intent ( inout ) :: self !< simulation data. error stop 'error: simulation_object%integrate to be implemented' endsubroutine integrate subroutine load_file_grid ( self , file_basename ) !< Load grid file. class ( simulation_object ), intent ( inout ) :: self !< simulation data. character ( * ), intent ( in ) :: file_basename !< File basename. call self % file_grid % load_grid_dimensions_from_file ( file_name = trim ( adjustl ( file_basename )) // '.grd' , & grid_dimensions = self % grid_dimensions ) call self % allocate_blocks call self % file_grid % load_nodes_from_file ( file_name = trim ( adjustl ( file_basename )) // '.grd' , & grid_dimensions = self % grid_dimensions , blocks = self % blocks ) endsubroutine load_file_grid subroutine load_file_parameters ( self , file_name , go_on_fail ) !< Load file parameters. class ( simulation_object ), intent ( inout ) :: self !< Simulation object. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. type ( file_ini ) :: fini !< Simulation parameters ini file handler. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % load ( filename = file_name , error = self % error % status ) call self % error % check ( message = 'failed to load \"' // trim ( adjustl ( file_name )) // '\"' , is_severe = . not . go_on_fail_ ) if ( self % error % status /= 0 ) then write ( stderr , '(A)' ) 'Using default simulation parameters values' return endif call self % file_grid % load_file_name_from_file ( fini = fini , section_name = 'files' , option_name = 'grid' , go_on_fail = go_on_fail ) ! call self%files_collection%load_from_file(fini=fini, go_on_fail=go_on_fail_) call self % adimensionals % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) call self % free_conditions % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) call self % solver % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) call self % time % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) endsubroutine load_file_parameters subroutine load_input_files ( self ) !< Load from file. class ( simulation_object ), intent ( inout ) :: self !< simulation data. if ( self % is_cli_parsed ) then if ( self % is_output_verbose ) print '(A)' , 'load file \"' // trim ( adjustl ( self % file_parameters )) // '\"' call self % load_file_parameters ( file_name = self % file_parameters , go_on_fail = self % go_on_fail ) else error stop 'error: before loading input files, Command Line Interface must be parsed!' endif endsubroutine load_input_files subroutine parse_command_line_interface ( self ) !< Parse command line interface. class ( simulation_object ), intent ( inout ) :: self !< simulation data. integer ( I4P ) :: error !< Error trapping flag. call self % set_command_line_interface call self % cli % parse ( error = error ) ; if ( error /= 0 ) stop call self % cli % get ( switch = '--parameters_file' , val = self % file_parameters , error = error ) ; if ( error /= 0 ) stop call self % cli % get ( switch = '--go-on-fail' , val = self % go_on_fail , error = error ) ; if ( error /= 0 ) stop call self % cli % get ( switch = '--verbose' , val = self % is_output_verbose , error = error ) ; if ( error /= 0 ) stop self % is_cli_parsed = . true . endsubroutine parse_command_line_interface subroutine save_file_grid ( self , file_basename , ascii , metrics , off , tecplot , vtk ) !< Save grid file. class ( simulation_object ), intent ( inout ) :: self !< simulation data. character ( * ), intent ( in ) :: file_basename !< File basename. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. logical , intent ( in ), optional :: off !< Save in OFF format sentinel. logical , intent ( in ), optional :: tecplot !< Tecplot output format sentinel. logical , intent ( in ), optional :: vtk !< VTK output format sentinel. integer ( I4P ) :: b !< Counter. logical :: off_ !< OFF format sentinel, local variable. logical :: vtk_ !< VTK format sentinel, local variable. character ( len = :), allocatable :: file_name !< File name buffer. off_ = . true . ; if ( present ( off )) off_ = off vtk_ = . false . ; if ( present ( vtk )) vtk_ = vtk if ( off_ ) then call self % file_grid % initialize ( file_name = trim ( adjustl ( file_basename )) // '.grd' ) call self % file_grid % save_grid_dimensions_into_file ( grid_dimensions = self % grid_dimensions ) call self % file_grid % save_nodes_into_file ( grid_dimensions = self % grid_dimensions , blocks = self % blocks ) endif if ( vtk_ ) then do b = 1 , self % grid_dimensions % blocks_number file_name = trim ( adjustl ( file_basename )) // '-block' // & '-id_' // trim ( str ( n = self % blocks ( b )% signature % id , no_sign = . true .)) // & '-lv_' // trim ( str ( n = self % blocks ( b )% signature % level , no_sign = . true .)) // '.vts' call self % blocks ( b )% save_file_grid ( file_name = file_name , ascii = ascii , metrics = metrics , vtk = vtk ) enddo endif endsubroutine save_file_grid subroutine save_file_parameters ( self , file_name ) !< Save file parameters. class ( simulation_object ), intent ( inout ) :: self !< Simulation object. character ( * ), intent ( in ) :: file_name !< File name. type ( file_ini ) :: fini !< Simulation parameters ini file handler. ! call self%files_collection%save_into_file(fini=fini) call self % adimensionals % save_into_file ( fini = fini ) call self % free_conditions % save_into_file ( fini = fini ) call self % solver % save_into_file ( fini = fini ) call self % time % save_into_file ( fini = fini ) call fini % save ( filename = trim ( adjustl ( file_name ))) endsubroutine save_file_parameters ! private methods subroutine set_command_line_interface ( self ) !< Set command line interface. class ( simulation_object ), intent ( inout ) :: self !< simulation data. integer ( I4P ) :: error !< Error trapping flag. call self % cli % init ( progname = 'off' , & version = 'v0.0.1' , & authors = 'G. Rossi, S. Zaghi' , & help = 'Usage: ' , & description = 'CNR-INSEAN CFD code' , & examples = [ \"off --parameters sim_parameters.ini --verbose\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call self % cli % add ( switch = '--parameters_file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . false ., & act = 'store' , & def = 'simulation_parameters.ini' , & error = error ) if ( error /= 0 ) stop call self % cli % add ( switch = '--go-on-fail' , & switch_ab = '-gof' , & help = 'go-on if parameters load fails somewhere' , & required = . false ., & def = '.false.' , & act = 'store' ) if ( error /= 0 ) stop call self % cli % add ( switch = '--verbose' , & help = 'enable verbose output' , & required = . false ., & act = 'store_true' , & def = '.false.' , & error = error ) if ( error /= 0 ) stop endsubroutine set_command_line_interface endmodule off_simulation_object","tags":"","loc":"sourcefile/off_simulation_object.f90.html","title":"off_simulation_object.f90 – OFF"},{"text":"OFF solver object definition and implementation. This File Depends On sourcefile~~off_solver_object.f90~~EfferentGraph sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_solver_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_solver_object.f90~~AfferentGraph sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_solver_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_solver_object.f90->sourcefile~off_objects.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 var pansourcefileoff_solver_objectf90AfferentGraph = svgPanZoom('#sourcefileoff_solver_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_solver_object Source Code off_solver_object.f90 Source Code !< OFF solver object definition and implementation. module off_solver_object !< OFF solver object definition and implementation. use off_error_object , only : error_object use finer , only : file_ini use penf , only : R8P , str implicit none private public :: solver_object character ( len = 6 ), parameter :: INI_SECTION_NAME = 'solver' !< INI (config) file section name containing the solver parameters. type :: solver_object !< Solver object class. !< !< Class designed to handle the general solver models parameters. type ( error_object ) :: error !< Errors handler. character ( len = :), allocatable :: time_integrator !< Time integrator model: euler, rk2(3-10), ab2(3-12)... character ( len = :), allocatable :: convective_operator !< Convective operator model: tvd, eno3, weno3(5-17)... character ( len = :), allocatable :: diffusive_operator !< Diffusive operator model: centered2(4-10)... character ( len = :), allocatable :: turbulence_model !< Turbulence_model: k-e, k-w, less... real ( R8P ) :: artificial_viscosity = 0._R8P !< Artifiical viscosity. real ( R8P ) :: residuals_tolerance = 0._R8P !< Tolerance on residuals value. real ( R8P ) :: pseudo_compressibility = 0._R8P !< Pseudo compressibility. real ( R8P ) :: chimera_forcing = 0._R8P !< Chimera forcing coefficient. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of solver parameters. procedure , pass ( self ) :: destroy !< Destroy solver. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. ! operators generic :: assignment ( = ) => solver_assign_solver !< Overload `=`. ! private methods procedure , pass ( lhs ) :: solver_assign_solver !< Operator `=`. endtype solver_object contains ! public methods pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of solver parameters. class ( solver_object ), intent ( in ) :: self !< Solver object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' if ( allocated ( self % time_integrator )) desc = desc // prefix_ // 'time integrator       : ' // self % time_integrator // NL if ( allocated ( self % convective_operator )) desc = desc // prefix_ // 'convective operator   : ' // self % convective_operator // NL if ( allocated ( self % diffusive_operator )) desc = desc // prefix_ // 'diffusive operator    : ' // self % diffusive_operator // NL if ( allocated ( self % turbulence_model )) desc = desc // prefix_ // 'turbulence model      : ' // self % turbulence_model // NL desc = desc // prefix_ // 'artificial viscosity  : ' // trim ( str ( self % artificial_viscosity )) // NL desc = desc // prefix_ // 'residuals tolerance   : ' // trim ( str ( self % residuals_tolerance )) // NL desc = desc // prefix_ // 'pseudo compressibility: ' // trim ( str ( self % pseudo_compressibility )) // NL desc = desc // prefix_ // 'chimera forcing       : ' // trim ( str ( self % chimera_forcing )) endfunction description elemental subroutine destroy ( self ) !< Destroy solver. class ( solver_object ), intent ( inout ) :: self !< Solver object. type ( solver_object ) :: fresh !< Fresh instance of solver object. self = fresh if ( allocated ( self % time_integrator )) deallocate ( self % time_integrator ) if ( allocated ( self % convective_operator )) deallocate ( self % convective_operator ) if ( allocated ( self % diffusive_operator )) deallocate ( self % diffusive_operator ) if ( allocated ( self % turbulence_model )) deallocate ( self % turbulence_model ) endsubroutine destroy elemental subroutine initialize ( self ) !< Initialize solver. class ( solver_object ), intent ( inout ) :: self !< Solver object. call self % destroy endsubroutine initialize subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( solver_object ), intent ( inout ) :: self !< Solver object. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. character ( 999 ) :: buffer !< Buffer string. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'time_integrator' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(time_integrator)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % time_integrator = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'convective_operator' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(convective_operator)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % convective_operator = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'diffusive_operator' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(diffusive_operator)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % diffusive_operator = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'turbulence_model' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(turbulence_model)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % turbulence_model = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'artificial_viscosity' , & val = self % artificial_viscosity , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(artificial_viscosity)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'residuals_tolerance' , & val = self % residuals_tolerance , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(residuals_tolerance)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'pseudo_compressibility' , & val = self % pseudo_compressibility , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(pseudo_compressibility)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'chimera_forcing' , & val = self % chimera_forcing , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(chimera_forcing)' , is_severe = . not . go_on_fail_ ) endsubroutine load_from_file subroutine save_into_file ( self , fini ) !< Save into file. class ( solver_object ), intent ( inout ) :: self !< Solver object. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'time_integrator' , val = self % time_integrator , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'convective_operator' , val = self % convective_operator , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'diffusive_operator' , val = self % diffusive_operator , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'turbulence_model' , val = self % turbulence_model , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'artificial_viscosity' , val = self % artificial_viscosity , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'residuals_tolerance' , val = self % residuals_tolerance , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'pseudo_compressibility' , val = self % pseudo_compressibility , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'chimera_forcing' , val = self % chimera_forcing , error = self % error % status ) endsubroutine save_into_file ! private methods pure subroutine solver_assign_solver ( lhs , rhs ) !< Operator `=`. class ( solver_object ), intent ( inout ) :: lhs !< Left hand side. type ( solver_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error if ( allocated ( rhs % time_integrator )) lhs % time_integrator = rhs % time_integrator if ( allocated ( rhs % convective_operator )) lhs % convective_operator = rhs % convective_operator if ( allocated ( rhs % diffusive_operator )) lhs % diffusive_operator = rhs % diffusive_operator if ( allocated ( rhs % turbulence_model )) lhs % turbulence_model = rhs % turbulence_model lhs % artificial_viscosity = rhs % artificial_viscosity lhs % residuals_tolerance = rhs % residuals_tolerance lhs % pseudo_compressibility = rhs % pseudo_compressibility lhs % chimera_forcing = rhs % chimera_forcing endsubroutine solver_assign_solver endmodule off_solver_object","tags":"","loc":"sourcefile/off_solver_object.f90.html","title":"off_solver_object.f90 – OFF"},{"text":"OFF time object definition and implementation. This File Depends On sourcefile~~off_time_object.f90~~EfferentGraph sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_time_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~off_time_object.f90~~AfferentGraph sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_time_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_time_object.f90->sourcefile~off_objects.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules off_time_object Source Code off_time_object.f90 Source Code !< OFF time object definition and implementation. module off_time_object !< OFF time object definition and implementation. use off_error_object , only : error_object use finer , only : file_ini use penf , only : I8P , R8P , str implicit none private public :: time_object character ( len = 4 ), parameter :: INI_SECTION_NAME = 'time' !< INI (config) file section name containing the time parameters. type :: time_object !< Time object class. !< !< Class designed to handle the timing data of the simulation. type ( error_object ) :: error !< Errors handler. logical :: is_unsteady = . true . !< Type of simulation: unsteady or steady. integer ( I8P ) :: n = 0 !< Time steps counter. real ( R8P ) :: t = 0._R8P !< Time. integer ( I8P ) :: n_max = 0 !< Maximum number of time steps computed. real ( R8P ) :: t_max = 0._R8P !< Maximum time of integration, ignored if `n_max>0`. real ( R8P ) :: CFL = 0.3_R8P !< Courant-Friedrichs-Lewy stability coefficient. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of time parameters. procedure , pass ( self ) :: destroy !< Destroy time. procedure , pass ( self ) :: initialize !< Initialize time. procedure , pass ( self ) :: is_the_end !< Return true if the end of simulation is reached. procedure , pass ( self ) :: progress !< Return the progress of simulation. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. procedure , pass ( self ) :: set_stop !< Set simulation stop condition. procedure , pass ( self ) :: update !< Update time. ! operators generic :: assignment ( = ) => time_assign_time !< Overload `=`. ! private methods procedure , pass ( lhs ) :: time_assign_time !< Operator `=`. endtype time_object contains ! public methods pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of time parameters. class ( time_object ), intent ( in ) :: self !< Time object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' if ( self % is_unsteady ) then desc = desc // prefix_ // 'timing: unsteady' // NL else desc = desc // prefix_ // 'timing: steady' // NL endif desc = desc // prefix_ // 'n     : ' // trim ( str ( n = self % n )) // NL desc = desc // prefix_ // 't     : ' // trim ( str ( n = self % t )) // NL desc = desc // prefix_ // 'n_max : ' // trim ( str ( n = self % n_max )) // NL desc = desc // prefix_ // 't_max : ' // trim ( str ( n = self % t_max )) // NL desc = desc // prefix_ // 'CFL   : ' // trim ( str ( n = self % CFL )) endfunction description elemental subroutine destroy ( self ) !< Destroy time. class ( time_object ), intent ( inout ) :: self !< Time object. type ( time_object ) :: fresh !< Fresh instance of time object. self = fresh endsubroutine destroy elemental subroutine initialize ( self ) !< Initialize time. class ( time_object ), intent ( inout ) :: self !< Time object. call self % destroy endsubroutine initialize elemental function is_the_end ( self ) result ( yes ) !< Return true if the end of simulation is reached. class ( time_object ), intent ( in ) :: self !< Time object. logical :: yes !< Test result. yes = (( self % t == self % t_max ). or .( self % n == self % n_max )) endfunction is_the_end elemental function progress ( self ) result ( prog ) !< Return the progress of simulation. class ( time_object ), intent ( in ) :: self !< Time object. real ( R8P ) :: prog !< Actual progress value. if ( self % n_max > 0 ) then prog = self % n * 100 / ( self % n_max * 1._R8P ) elseif ( self % t_max > 0._R8P ) then prog = 100 * self % t / self % t_max else prog = 0._R8P endif endfunction progress subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( time_object ), intent ( inout ) :: self !< Time object. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % get ( section_name = INI_SECTION_NAME , option_name = 'is_unsteady' , val = self % is_unsteady , error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(is_unsteady)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'n_max' , val = self % n_max , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(n_max)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 't_max' , val = self % t_max , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(t_max)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'cfl' , val = self % CFL , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(cfl)' , is_severe = . not . go_on_fail_ ) endsubroutine load_from_file subroutine save_into_file ( self , fini ) !< Save into file. class ( time_object ), intent ( inout ) :: self !< Time object. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'is_unsteady' , val = self % is_unsteady , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'n_max' , val = self % n_max , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 't_max' , val = self % t_max , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'cfl' , val = self % cfl , error = self % error % status ) endsubroutine save_into_file elemental subroutine set_stop ( self ) !< Set simulation stop condition. class ( time_object ), intent ( inout ) :: self !< Time object. if ( self % is_unsteady ) then if ( self % n_max > 0_I8P ) then self % t_max = - 1._R8P ! the value of t_max is ignored because n_max>0 else self % n_max = - 1_I8P endif else self % t_max = - 1._R8P ! the value of t_max is ignored because steady simulation endif endsubroutine set_stop elemental subroutine update ( self , global_min_dt ) !< Update time. class ( time_object ), intent ( inout ) :: self !< Time object. real ( R8P ), intent ( inout ) :: global_min_dt !< Global (all processes/images, all blocks) minimum time step. if ( self % is_unsteady ) then ! for an unsteady accurate simulation each cell is updated by means of global minimum time step ! control for the last iterate if ( self % n_max <= 0 ) then if (( self % t + global_min_dt ) > self % t_max ) then ! the global minimum time step is so high that the last iteration will go over t_max ! it is decreased in order to achieve exactly t_max global_min_dt = abs ( self % t_max - self % t ) endif endif self % t = self % t + global_min_dt endif endsubroutine update ! private methods pure subroutine time_assign_time ( lhs , rhs ) !< Operator `=`. class ( time_object ), intent ( inout ) :: lhs !< Left hand side. type ( time_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % n = rhs % n lhs % t = rhs % t lhs % n_max = rhs % n_max lhs % t_max = rhs % t_max lhs % CFL = rhs % CFL lhs % is_unsteady = rhs % is_unsteady endsubroutine time_assign_time endmodule off_time_object","tags":"","loc":"sourcefile/off_time_object.f90.html","title":"off_time_object.f90 – OFF"},{"text":"OFF test: load file of simulation parameters. This File Depends On sourcefile~~off_test_load_file_parameters.f90~~EfferentGraph sourcefile~off_test_load_file_parameters.f90 off_test_load_file_parameters.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_objects.f90->sourcefile~off_test_load_file_parameters.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_file_object.f90->sourcefile~off_objects.f90 sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_file_object.f90->sourcefile~off_files_collection_object.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_solver_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_files_collection_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_os_object.f90->sourcefile~off_objects.f90 sourcefile~off_os_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_objects.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 sourcefile~off_error_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90->sourcefile~off_solver_object.f90 sourcefile~off_error_object.f90->sourcefile~off_os_object.f90 sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_error_object.f90->sourcefile~off_time_object.f90 sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_error_object.f90->sourcefile~off_non_dimensional_numbers_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_face_object.f90->sourcefile~off_objects.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_node_object.f90->sourcefile~off_objects.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_objects.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_time_object.f90->sourcefile~off_objects.f90 sourcefile~off_time_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_objects.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_simulation_object.f90 var pansourcefileoff_test_load_file_parametersf90EfferentGraph = svgPanZoom('#sourcefileoff_test_load_file_parametersf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs off_test_load_file_parameters Source Code off_test_load_file_parameters.f90 Source Code !< OFF test: load file of simulation parameters. program off_test_load_file_parameters !< OFF test: load file of simulation parameters. use off_objects , only : simulation_object use flap , only : command_line_interface use penf , only : I4P implicit none character ( 999 ) :: file_parameters !< Name of simulation parameters. logical :: go_on_fail !< Go on if load fails. type ( simulation_object ) :: simulation !< Simulation data. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call simulation % load_file_parameters ( file_name = file_parameters , go_on_fail = go_on_fail ) are_tests_passed ( 1 ) = simulation % solver % time_integrator == 'rk5' print '(A)' , simulation % description () print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_load_file_parameters' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_load_file_parameters --parameters sim_parameters.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--parameters-file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . true ., & act = 'store' ) call cli % add ( switch = '--go-on-fail' , & switch_ab = '-gof' , & help = 'go-on if load fails somewhere' , & required = . false ., & def = '.false.' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--parameters-file' , val = file_parameters ) call cli % get ( switch = '--go-on-fail' , val = go_on_fail ) endsubroutine cli_parse endprogram off_test_load_file_parameters","tags":"","loc":"sourcefile/off_test_load_file_parameters.f90.html","title":"off_test_load_file_parameters.f90 – OFF"},{"text":"OFF test: save (and re-load for checking) file grid. This File Depends On sourcefile~~off_test_save_load_file_grid.f90~~EfferentGraph sourcefile~off_test_save_load_file_grid.f90 off_test_save_load_file_grid.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_grid.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_file_object.f90->sourcefile~off_objects.f90 sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_file_object.f90->sourcefile~off_files_collection_object.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_solver_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_files_collection_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_os_object.f90->sourcefile~off_objects.f90 sourcefile~off_os_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_objects.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 sourcefile~off_error_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90->sourcefile~off_solver_object.f90 sourcefile~off_error_object.f90->sourcefile~off_os_object.f90 sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_error_object.f90->sourcefile~off_time_object.f90 sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_error_object.f90->sourcefile~off_non_dimensional_numbers_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_face_object.f90->sourcefile~off_objects.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_node_object.f90->sourcefile~off_objects.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_objects.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_time_object.f90->sourcefile~off_objects.f90 sourcefile~off_time_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_objects.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_simulation_object.f90 var pansourcefileoff_test_save_load_file_gridf90EfferentGraph = svgPanZoom('#sourcefileoff_test_save_load_file_gridf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs off_test_save_load_file_grid Source Code off_test_save_load_file_grid.f90 Source Code !< OFF test: save (and re-load for checking) file grid. program off_test_save_load_file_grid !< OFF test: save (and re-load for checking) file grid. use off_objects , only : block_object , simulation_object use flap , only : command_line_interface use penf , only : I4P , I8P use vecfor , only : ex , ey , ez implicit none character ( 999 ) :: file_basename !< Basename of grid file. type ( simulation_object ) :: simulation !< Simulation data. type ( block_object ) :: blocks ( 2 ) !< A block. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call blocks ( 1 )% initialize ( id = 1_I8P , level = 1 , gc = [ 2 , 2 , 2 , 2 , 2 , 2 ], ni = 8 , nj = 16 , nk = 32 ) call blocks ( 1 )% create_linspace ( emin = ( 0 * ex ), emax = ( ex + ey + ez )) call blocks ( 2 )% initialize ( id = 2_I8P , level = 1 , gc = [ 2 , 2 , 2 , 2 , 2 , 2 ], ni = 16 , nj = 32 , nk = 64 ) call blocks ( 2 )% create_linspace ( emin = ( 1 * ex ), emax = ( 2 * ex + ey + ez )) call simulation % initialize ( blocks = blocks ) call simulation % save_file_grid ( file_basename = trim ( adjustl ( file_basename )), metrics = . true ., off = . true ., vtk = . true .) ! re-load for checking call simulation % initialize call simulation % load_file_grid ( file_basename = trim ( adjustl ( file_basename ))) are_tests_passed ( 1 ) = simulation % blocks ( 2 )% cells_number ( with_ghosts = . false .) == 16_I4P * 32_I4P * 64_I4P print '(A)' , simulation % description () print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) ! remove temporary files grid call simulation % os % rm ( file_name = trim ( adjustl ( file_basename )) // '.grd' ) call simulation % os % rm ( file_name = trim ( adjustl ( file_basename )) // '*.vts' ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_save_load_file_grid' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_save_load_file_grid --grid-basename grid\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--grid-basename' , & switch_ab = '-g' , & help = 'basename of grid file' , & required = . false ., & def = 'grid' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--grid-basename' , val = file_basename ) endsubroutine cli_parse endprogram off_test_save_load_file_grid","tags":"","loc":"sourcefile/off_test_save_load_file_grid.f90.html","title":"off_test_save_load_file_grid.f90 – OFF"},{"text":"OFF test: save (and re-load for checking) file of simulation parameters. This File Depends On sourcefile~~off_test_save_load_file_parameters.f90~~EfferentGraph sourcefile~off_test_save_load_file_parameters.f90 off_test_save_load_file_parameters.f90 sourcefile~off_objects.f90 off_objects.f90 sourcefile~off_objects.f90->sourcefile~off_test_save_load_file_parameters.f90 sourcefile~off_file_object.f90 off_file_object.f90 sourcefile~off_file_object.f90->sourcefile~off_objects.f90 sourcefile~off_files_collection_object.f90 off_files_collection_object.f90 sourcefile~off_file_object.f90->sourcefile~off_files_collection_object.f90 sourcefile~off_file_grid_object.f90 off_file_grid_object.f90 sourcefile~off_file_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_simulation_object.f90 off_simulation_object.f90 sourcefile~off_simulation_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90 off_solver_object.f90 sourcefile~off_solver_object.f90->sourcefile~off_objects.f90 sourcefile~off_solver_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_signature_object.f90 off_block_signature_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90 off_grid_dimensions_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_grid_dimensions_object.f90 sourcefile~off_block_object.f90 off_block_object.f90 sourcefile~off_block_signature_object.f90->sourcefile~off_block_object.f90 sourcefile~off_files_collection_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90 off_cell_object.f90 sourcefile~off_cell_object.f90->sourcefile~off_objects.f90 sourcefile~off_cell_object.f90->sourcefile~off_block_object.f90 sourcefile~off_os_object.f90 off_os_object.f90 sourcefile~off_os_object.f90->sourcefile~off_objects.f90 sourcefile~off_os_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90 off_error_object.f90 sourcefile~off_error_object.f90->sourcefile~off_objects.f90 sourcefile~off_error_object.f90->sourcefile~off_file_object.f90 sourcefile~off_error_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_error_object.f90->sourcefile~off_solver_object.f90 sourcefile~off_error_object.f90->sourcefile~off_os_object.f90 sourcefile~off_free_conditions_object.f90 off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_free_conditions_object.f90 sourcefile~off_error_object.f90->sourcefile~off_block_object.f90 sourcefile~off_time_object.f90 off_time_object.f90 sourcefile~off_error_object.f90->sourcefile~off_time_object.f90 sourcefile~off_non_dimensional_numbers_object.f90 off_non_dimensional_numbers_object.f90 sourcefile~off_error_object.f90->sourcefile~off_non_dimensional_numbers_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_objects.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_grid_dimensions_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_face_object.f90 off_face_object.f90 sourcefile~off_face_object.f90->sourcefile~off_objects.f90 sourcefile~off_face_object.f90->sourcefile~off_block_object.f90 sourcefile~off_node_object.f90 off_node_object.f90 sourcefile~off_node_object.f90->sourcefile~off_objects.f90 sourcefile~off_node_object.f90->sourcefile~off_block_object.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_objects.f90 sourcefile~off_free_conditions_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_objects.f90 sourcefile~off_block_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_block_object.f90->sourcefile~off_file_grid_object.f90 sourcefile~off_time_object.f90->sourcefile~off_objects.f90 sourcefile~off_time_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_objects.f90 sourcefile~off_file_grid_object.f90->sourcefile~off_simulation_object.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_objects.f90 sourcefile~off_non_dimensional_numbers_object.f90->sourcefile~off_simulation_object.f90 var pansourcefileoff_test_save_load_file_parametersf90EfferentGraph = svgPanZoom('#sourcefileoff_test_save_load_file_parametersf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs off_test_save_load_file_parameters Source Code off_test_save_load_file_parameters.f90 Source Code !< OFF test: save (and re-load for checking) file of simulation parameters. program off_test_save_load_file_parameters !< OFF test: save (and re-load for checking) file of simulation parameters. use off_objects , only : simulation_object use flap , only : command_line_interface use penf , only : I4P , R8P implicit none character ( 999 ) :: file_parameters !< Name of simulation parameters. type ( simulation_object ) :: simulation !< Simulation data. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . simulation % adimensionals % Ma = 3._R8P call cli_parse call simulation % save_file_parameters ( file_name = file_parameters ) call simulation % initialize ! re-initialize call simulation % load_file_parameters ( file_name = file_parameters ) are_tests_passed ( 1 ) = simulation % adimensionals % Ma == 3._R8P print '(A)' , simulation % description () print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) call simulation % os % rm ( file_name = trim ( file_parameters )) ! remove temporary file parameters contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_save_load_file_parameters' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_save_load_file_parameters --parameters sim_parameters.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--parameters-file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . true ., & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--parameters-file' , val = file_parameters ) endsubroutine cli_parse endprogram off_test_save_load_file_parameters","tags":"","loc":"sourcefile/off_test_save_load_file_parameters.f90.html","title":"off_test_save_load_file_parameters.f90 – OFF"},{"text":"type, public :: block_object type~~block_object~~InheritsGraph type~block_object block_object type~block_signature_object block_signature_object type~block_signature_object->type~block_object signature type~cell_object cell_object type~cell_object->type~block_object cell type~face_object face_object type~face_object->type~block_object face_i, face_j, face_k type~node_object node_object type~node_object->type~block_object node type~error_object error_object type~error_object->type~block_object error vector vector vector->type~block_signature_object emax, emin vector->type~cell_object center vector->type~face_object normal vector->type~node_object vertex Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Block object class. Inherited By type~~block_object~~InheritedByGraph type~block_object block_object type~simulation_object simulation_object type~block_object->type~simulation_object blocks Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables cell error face_i face_j face_k node signature Type-Bound Procedures assignment(=) block_assign_block cells_number compute_extents compute_faces_metrics compute_metrics compute_space_operator compute_volumes correct_metrics create_linspace destroy initialize interpolate_at_nodes load_nodes_from_file node_to_center nodes_number nullify_normals save_file_grid save_file_grid_tec save_file_grid_vtk save_nodes_into_file Source Code block_object Components Type Visibility Attributes Name Initial type( cell_object ), public, allocatable :: cell (:,:,:) Cell. type( error_object ), public :: error Errors handler. type( face_object ), public, allocatable :: face_i (:,:,:) Faces along I direction. type( face_object ), public, allocatable :: face_j (:,:,:) Faces along I direction. type( face_object ), public, allocatable :: face_k (:,:,:) Faces along I direction. type( node_object ), public, allocatable :: node (:,:,:) Cell. type( block_signature_object ), public :: signature Signature, namely id, level, dimensions, etc… Type-Bound Procedures generic, public :: assignment(=) => block_assign_block Overload = . private pure subroutine block_assign_block (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: lhs Left hand side. type( block_object ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: block_assign_block Operator = . private pure subroutine block_assign_block (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: lhs Left hand side. type( block_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: cells_number Return the number of cells. private elemental function cells_number (self, with_ghosts) result(cells_number_) Return the number of cells. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. procedure, private, pass(self) :: compute_extents Compute block extents. private elemental subroutine compute_extents (self) Compute block extents. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. procedure, private, pass(self) :: compute_faces_metrics Compute block faces metrics. private elemental subroutine compute_faces_metrics (self) Compute block faces metrics. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. procedure, private, pass(self) :: compute_metrics Compute block metrics. private subroutine compute_metrics (self) Compute block metrics. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. procedure, public, pass(self) :: compute_space_operator Compute space operator. private subroutine compute_space_operator (self) Compute space operator. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. procedure, private, pass(self) :: compute_volumes Compute block volumes. private elemental subroutine compute_volumes (self) Compute block volumes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. procedure, private, pass(self) :: correct_metrics Correct block metrics. private subroutine correct_metrics (self) Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Correct the metrics. procedure, public, pass(self) :: create_linspace Create a Cartesian block with linearly spaced nodes. private subroutine create_linspace (self, emin, emax) Create a Cartesian block with linearly spaced nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. procedure, public, pass(self) :: destroy Destroy block. private elemental subroutine destroy (self) Destroy block. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. procedure, public, pass(self) :: initialize Initialize block. private subroutine initialize (self, signature, id, level, gc, ni, nj, nk, emin, emax, is_cartesian, is_null_x, is_null_y, is_null_z) Initialize block. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. type( block_signature_object ), intent(in), optional :: signature Signature, namely id, level, dimensions, etc… integer(kind=I8P), intent(in), optional :: id Unique (Morton) identification code. integer(kind=I4P), intent(in), optional :: level Grid refinement level. integer(kind=I4P), intent(in), optional :: gc (1:) Number of ghost cells along each frame. integer(kind=I4P), intent(in), optional :: ni Number of cells in I direction. integer(kind=I4P), intent(in), optional :: nj Number of cells in J direction. integer(kind=I4P), intent(in), optional :: nk Number of cells in K direction. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. logical, intent(in), optional :: is_cartesian Flag for checking if the block is Cartesian. logical, intent(in), optional :: is_null_x Nullify X direction (2D yz, 1D y or z domain). logical, intent(in), optional :: is_null_y Nullify Y direction (2D xy, 1D x or y domain). logical, intent(in), optional :: is_null_z Nullify Z direction (2D xy, 1D x or y domain). procedure, public, pass(self) :: interpolate_at_nodes Interpolate cell-centered variable at nodes. private pure subroutine interpolate_at_nodes (self, var_cell, var_node) Interpolate cell-centered variable at nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. real(kind=R8P), intent(in) :: var_cell (1-self%signature%gc(1):,1-self%signature%gc(3):,1-self%signature%gc(5):) Cell-centered variable. real(kind=R8P), intent(out) :: var_node (0-self%signature%gc(1):,0-self%signature%gc(3):,0-self%signature%gc(5):) Node-centered variable. procedure, public, pass(self) :: load_nodes_from_file Load nodes from file. private subroutine load_nodes_from_file (self, file_unit, pos) Load nodes from file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. integer(kind=I4P), intent(in) :: file_unit File unit. integer(kind=I4P), intent(in) :: pos Position to start the loading. procedure, private, pass(self) :: node_to_center Compute cell centers coordinates from cell nodes. private pure function node_to_center (self) result(center) Compute cell centers coordinates from cell nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. Return Value type(vector),\n  allocatable, (:,:,:) Cell centers coordinates. procedure, public, pass(self) :: nodes_number Return the number of nodes. private elemental function nodes_number (self, with_ghosts) result(nodes_number_) Return the number of nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. procedure, private, pass(self) :: nullify_normals Nullify normals for 2D or 1D domains. private elemental subroutine nullify_normals (self) Nullify normals for 2D or 1D domains. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. procedure, public, pass(self) :: save_file_grid Save gird file. private subroutine save_file_grid (self, file_name, ascii, metrics, tecplot, vtk) Save grid file file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name File name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. logical, intent(in), optional :: tecplot Tecplot output format sentinel. logical, intent(in), optional :: vtk VTK output format sentinel. procedure, private, pass(self) :: save_file_grid_tec Save grid file in Tecplot format. private subroutine save_file_grid_tec (self, file_name, ascii, metrics) Save grid file in Tecplot format. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name Output file name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. procedure, private, pass(self) :: save_file_grid_vtk Save grid file in VTK format. private subroutine save_file_grid_vtk (self, file_name, ascii, metrics) Save mesh data into VTK file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name Output file name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. procedure, public, pass(self) :: save_nodes_into_file Save nodes into file. private subroutine save_nodes_into_file (self, file_unit, pos) Save nodes into file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. integer(kind=I4P), intent(in) :: file_unit File unit. integer(kind=I4P), intent(in) :: pos Position to start the loading. Source Code type :: block_object !< Block object class. type ( error_object ) :: error !< Errors handler. type ( block_signature_object ) :: signature !< Signature, namely id, level, dimensions, etc... type ( cell_object ), allocatable :: cell (:,:,:) !< Cell. type ( face_object ), allocatable :: face_i (:,:,:) !< Faces along I direction. type ( face_object ), allocatable :: face_j (:,:,:) !< Faces along I direction. type ( face_object ), allocatable :: face_k (:,:,:) !< Faces along I direction. type ( node_object ), allocatable :: node (:,:,:) !< Cell. contains ! public methods procedure , pass ( self ) :: cells_number !< Return the number of cells. procedure , pass ( self ) :: compute_space_operator !< Compute space operator. procedure , pass ( self ) :: create_linspace !< Create a Cartesian block with linearly spaced nodes. procedure , pass ( self ) :: destroy !< Destroy block. procedure , pass ( self ) :: interpolate_at_nodes !< Interpolate cell-centered variable at nodes. procedure , pass ( self ) :: initialize !< Initialize block. procedure , pass ( self ) :: load_nodes_from_file !< Load nodes from file. procedure , pass ( self ) :: nodes_number !< Return the number of nodes. procedure , pass ( self ) :: save_file_grid !< Save gird file. procedure , pass ( self ) :: save_nodes_into_file !< Save nodes into file. ! operators generic :: assignment ( = ) => block_assign_block !< Overload `=`. ! private methods procedure , pass ( lhs ), private :: block_assign_block !< Operator `=`. procedure , pass ( self ), private :: compute_extents !< Compute block extents. procedure , pass ( self ), private :: compute_faces_metrics !< Compute block faces metrics. procedure , pass ( self ), private :: compute_metrics !< Compute block metrics. procedure , pass ( self ), private :: compute_volumes !< Compute block volumes. procedure , pass ( self ), private :: correct_metrics !< Correct block metrics. procedure , pass ( self ), private :: node_to_center !< Compute cell centers coordinates from cell nodes. procedure , pass ( self ), private :: nullify_normals !< Nullify normals for 2D or 1D domains. procedure , pass ( self ), private :: save_file_grid_tec !< Save grid file in Tecplot format. procedure , pass ( self ), private :: save_file_grid_vtk !< Save grid file in VTK format. endtype block_object","tags":"","loc":"type/block_object.html","title":"block_object – OFF "},{"text":"type, public :: block_signature_object type~~block_signature_object~~InheritsGraph type~block_signature_object block_signature_object vector vector vector->type~block_signature_object emax, emin Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Block signature object class. Define the block dimensions, id and level. Inherited By type~~block_signature_object~~InheritedByGraph type~block_signature_object block_signature_object type~block_object block_object type~block_signature_object->type~block_object signature type~grid_dimensions_object grid_dimensions_object type~block_signature_object->type~grid_dimensions_object block_signature type~simulation_object simulation_object type~block_object->type~simulation_object blocks type~grid_dimensions_object->type~simulation_object grid_dimensions Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables emax emin gc id is_cartesian is_null_x is_null_y is_null_z level ni nj nk Type-Bound Procedures assignment(=) block_d_assign_block_d cells_number description destroy initialize iolength load_from_file nodes_number save_into_file Source Code block_signature_object Components Type Visibility Attributes Name Initial type(vector), public :: emax Coordinates of maximum abscissa (extent) of the block. type(vector), public :: emin Coordinates of minimum abscissa (extent) of the block. integer(kind=I4P), public :: gc (1:6) = [0, 0, 0, 0, 0, 0] Number of ghost cells along each frame. integer(kind=I8P), public :: id = 0 Unique (Morton) identification code. logical, public :: is_cartesian = .false. Flag for checking if the block is Cartesian. logical, public :: is_null_x = .false. Nullify X direction (2D yz, 1D y or z domain). logical, public :: is_null_y = .false. Nullify Y direction (2D xy, 1D x or y domain). logical, public :: is_null_z = .false. Nullify Z direction (2D xy, 1D x or y domain). integer(kind=I4P), public :: level = 0 block refinement level. integer(kind=I4P), public :: ni = 0 Number of cells in I direction. integer(kind=I4P), public :: nj = 0 Number of cells in J direction. integer(kind=I4P), public :: nk = 0 Number of cells in K direction. Type-Bound Procedures generic, public :: assignment(=) => block_d_assign_block_d Overload = . private pure subroutine block_d_assign_block_d (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: lhs Left hand side. type( block_signature_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: block_d_assign_block_d Operator = . private pure subroutine block_d_assign_block_d (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: lhs Left hand side. type( block_signature_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: cells_number Return the number of cells. private elemental function cells_number (self, with_ghosts) result(cells_number_) Return the number of cells. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. procedure, public, pass(self) :: description Return a pretty-formatted description of block signature. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy block signature. private elemental subroutine destroy (self) Destroy block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. procedure, public, pass(self) :: initialize Initialize block signature. private pure subroutine initialize (self, signature, id, level, gc, ni, nj, nk, emin, emax, is_cartesian, is_null_x, is_null_y, is_null_z) Initialize block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. type( block_signature_object ), intent(in), optional :: signature Block signature input. integer(kind=I8P), intent(in), optional :: id Unique (Morton) identification code. integer(kind=I4P), intent(in), optional :: level Grid refinement level. integer(kind=I4P), intent(in), optional :: gc (1:) Number of ghost cells along each frame. integer(kind=I4P), intent(in), optional :: ni Number of cells in I direction. integer(kind=I4P), intent(in), optional :: nj Number of cells in J direction. integer(kind=I4P), intent(in), optional :: nk Number of cells in K direction. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. logical, intent(in), optional :: is_cartesian Flag for checking if the block is Cartesian. logical, intent(in), optional :: is_null_x Nullify X direction (2D yz, 1D y or z domain). logical, intent(in), optional :: is_null_y Nullify Y direction (2D xy, 1D x or y domain). logical, intent(in), optional :: is_null_z Nullify Z direction (2D xy, 1D x or y domain). procedure, public, pass(self) :: iolength Return the IO length storage. private function iolength (self) Return the IO length storage. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. Return Value integer(kind=I4P) IO length storage. procedure, public, pass(self) :: load_from_file Load block signature from file. private subroutine load_from_file (self, file_unit) Load block signature from file. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. integer(kind=I4P), intent(in) :: file_unit File unit. procedure, public, pass(self) :: nodes_number Return the number of nodes. private elemental function nodes_number (self, with_ghosts) result(nodes_number_) Return the number of nodes. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of nodes. procedure, public, pass(self) :: save_into_file Save block signature into file. private subroutine save_into_file (self, file_unit) Load the block signature of all blocks from file. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code type :: block_signature_object !< Block signature object class. !< !< Define the block dimensions, id and level. integer ( I8P ) :: id = 0 !< Unique (Morton) identification code. integer ( I4P ) :: level = 0 !< block refinement level. integer ( I4P ) :: gc ( 1 : 6 ) = [ 0 , 0 , 0 , 0 , 0 , 0 ] !< Number of ghost cells along each frame. integer ( I4P ) :: ni = 0 !< Number of cells in I direction. integer ( I4P ) :: nj = 0 !< Number of cells in J direction. integer ( I4P ) :: nk = 0 !< Number of cells in K direction. type ( vector ) :: emin !< Coordinates of minimum abscissa (extent) of the block. type ( vector ) :: emax !< Coordinates of maximum abscissa (extent) of the block. logical :: is_cartesian = . false . !< Flag for checking if the block is Cartesian. logical :: is_null_x = . false . !< Nullify X direction (2D yz, 1D y or z domain). logical :: is_null_y = . false . !< Nullify Y direction (2D xy, 1D x or y domain). logical :: is_null_z = . false . !< Nullify Z direction (2D xy, 1D x or y domain). contains ! public methods procedure , pass ( self ) :: cells_number !< Return the number of cells. procedure , pass ( self ) :: description !< Return a pretty-formatted description of block signature. procedure , pass ( self ) :: destroy !< Destroy block signature. procedure , pass ( self ) :: initialize !< Initialize block signature. procedure , pass ( self ) :: iolength !< Return the IO length storage. procedure , pass ( self ) :: load_from_file !< Load block signature from file. procedure , pass ( self ) :: nodes_number !< Return the number of nodes. procedure , pass ( self ) :: save_into_file !< Save block signature into file. ! operators generic :: assignment ( = ) => block_d_assign_block_d !< Overload `=`. ! private methods procedure , pass ( lhs ) :: block_d_assign_block_d !< Operator `=`. endtype block_signature_object","tags":"","loc":"type/block_signature_object.html","title":"block_signature_object – OFF "},{"text":"type, public :: cell_object type~~cell_object~~InheritsGraph type~cell_object cell_object vector vector vector->type~cell_object center Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Cell object class. Inherited By type~~cell_object~~InheritedByGraph type~cell_object cell_object type~block_object block_object type~cell_object->type~block_object cell type~simulation_object simulation_object type~block_object->type~simulation_object blocks Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables center volume Type-Bound Procedures assignment(=) cell_assign_cell destroy initialize Source Code cell_object Components Type Visibility Attributes Name Initial type(vector), public :: center Cell center. real(kind=R8P), public :: volume = 0._R8P Cell volume. Type-Bound Procedures generic, public :: assignment(=) => cell_assign_cell Overload = . private pure subroutine cell_assign_cell (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: lhs Left hand side. type( cell_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: cell_assign_cell Operator = . private pure subroutine cell_assign_cell (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: lhs Left hand side. type( cell_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: destroy Destroy cell. private elemental subroutine destroy (self) Destroy cell. Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: self Cell object. procedure, public, pass(self) :: initialize Initialize cell. private elemental subroutine initialize (self) Initialize cell. Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: self Cell object. Source Code type :: cell_object !< Cell object class. type ( vector ) :: center !< Cell center. real ( R8P ) :: volume = 0._R8P !< Cell volume. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy cell. procedure , pass ( self ) :: initialize !< Initialize cell. ! operators generic :: assignment ( = ) => cell_assign_cell !< Overload `=`. ! private methods procedure , pass ( lhs ) :: cell_assign_cell !< Operator `=`. endtype cell_object","tags":"","loc":"type/cell_object.html","title":"cell_object – OFF "},{"text":"type, public :: error_object Error object class. Handler of errors/excetpions. Inherited By type~~error_object~~InheritedByGraph type~error_object error_object type~file_object file_object type~error_object->type~file_object error type~file_grid_object file_grid_object type~error_object->type~file_grid_object error type~solver_object solver_object type~error_object->type~solver_object error type~time_object time_object type~error_object->type~time_object error type~non_dimensional_numbers_object non_dimensional_numbers_object type~error_object->type~non_dimensional_numbers_object error type~block_object block_object type~error_object->type~block_object error type~os_object os_object type~error_object->type~os_object error type~free_conditions_object free_conditions_object type~error_object->type~free_conditions_object error type~simulation_object simulation_object type~error_object->type~simulation_object error type~file_object->type~file_grid_object type~files_collection_object files_collection_object type~file_object->type~files_collection_object boundary_conditions, grid, initial_conditions, logging, solution type~file_grid_object->type~simulation_object file_grid type~solver_object->type~simulation_object solver type~time_object->type~simulation_object time type~non_dimensional_numbers_object->type~simulation_object adimensionals type~block_object->type~simulation_object blocks type~os_object->type~simulation_object os type~free_conditions_object->type~simulation_object free_conditions var pantypeerror_objectInheritedByGraph = svgPanZoom('#typeerror_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables message status Type-Bound Procedures assignment(=) check destroy err_assign_err initialize Source Code error_object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Error message. integer(kind=I4P), public :: status = 0_I4P Error status. Type-Bound Procedures generic, public :: assignment(=) => err_assign_err Overload = . private pure subroutine err_assign_err (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: lhs Left hand side. type( error_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check Check error status. private subroutine check (self, message, is_severe) Check error status. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. character(len=*), intent(in), optional :: message Error message. logical, intent(in), optional :: is_severe Enable severe error. procedure, public, pass(self) :: destroy Destroy error. private elemental subroutine destroy (self) Destroy error. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. procedure, public, pass(lhs) :: err_assign_err Operator = . private pure subroutine err_assign_err (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: lhs Left hand side. type( error_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: initialize Initialize error. private elemental subroutine initialize (self) Initialize error. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. Source Code type :: error_object !< Error object class. !< !< Handler of errors/excetpions. integer ( I4P ) :: status = 0_I4P !< Error status. character ( len = :), allocatable :: message !< Error message. contains ! public methods procedure , pass ( self ) :: check !< Check error status. procedure , pass ( self ) :: destroy !< Destroy error. procedure , pass ( self ) :: initialize !< Initialize error. ! operators generic :: assignment ( = ) => err_assign_err !< Overload `=`. ! private methods procedure , pass ( lhs ) :: err_assign_err !< Operator `=`. endtype error_object","tags":"","loc":"type/error_object.html","title":"error_object – OFF "},{"text":"type, public :: face_object type~~face_object~~InheritsGraph type~face_object face_object vector vector vector->type~face_object normal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Face object class. Inherited By type~~face_object~~InheritedByGraph type~face_object face_object type~block_object block_object type~face_object->type~block_object face_i, face_j, face_k type~simulation_object simulation_object type~block_object->type~simulation_object blocks Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables area normal Type-Bound Procedures assignment(=) compute_metrics destroy face_assign_face initialize Source Code face_object Components Type Visibility Attributes Name Initial real(kind=R8P), public :: area = 0._R8P Area. type(vector), public :: normal Normal versor. Type-Bound Procedures generic, public :: assignment(=) => face_assign_face Overload = . private pure subroutine face_assign_face (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: lhs Left hand side. type( face_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: compute_metrics Compute face metrics. private elemental subroutine compute_metrics (self, pt1, pt2, pt3, pt4, signd) Compute face metrics. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face. type(vector), intent(in) :: pt1 Point 1 of face. type(vector), intent(in) :: pt2 Point 2 of face. type(vector), intent(in) :: pt3 Point 3 of face. type(vector), intent(in) :: pt4 Point 4 of face. real(kind=R8P), intent(in) :: signd Sign of direction along normal coordinate. procedure, public, pass(self) :: destroy Destroy face. private elemental subroutine destroy (self) Destroy face. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face object. procedure, public, pass(lhs) :: face_assign_face Operator = . private pure subroutine face_assign_face (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: lhs Left hand side. type( face_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: initialize Initialize face. private pure subroutine initialize (self) Initialize face. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face object. Source Code type :: face_object !< Face object class. real ( R8P ) :: area = 0._R8P !< Area. type ( vector ) :: normal !< Normal versor. contains ! public methods procedure , pass ( self ) :: compute_metrics !< Compute face metrics. procedure , pass ( self ) :: destroy !< Destroy face. procedure , pass ( self ) :: initialize !< Initialize face. ! operators generic :: assignment ( = ) => face_assign_face !< Overload `=`. ! private methods procedure , pass ( lhs ) :: face_assign_face !< Operator `=`. endtype face_object","tags":"","loc":"type/face_object.html","title":"face_object – OFF "},{"text":"type, public, extends( file_object ) :: file_grid_object type~~file_grid_object~~InheritsGraph type~file_grid_object file_grid_object type~error_object error_object type~error_object->type~file_grid_object error type~file_object file_object type~error_object->type~file_object error type~file_object->type~file_grid_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). File grid object class. Inherited By type~~file_grid_object~~InheritedByGraph type~file_grid_object file_grid_object type~simulation_object simulation_object type~file_grid_object->type~simulation_object file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables error file_name file_unit is_connected is_initialized Type-Bound Procedures assignment(=) close description destroy file_assign_file initialize load_file_name_from_file load_grid_dimensions_from_file load_nodes_from_file open save_file_name_into_file save_grid_dimensions_into_file save_nodes_into_file Source Code file_grid_object Components Type Visibility Attributes Name Initial type( error_object ), public :: error Errors handler. character(len=:), public, allocatable :: file_name File name. integer(kind=I4P), public :: file_unit = 0 File unit. logical, public :: is_connected = .false. Sentinel to check if file is connected. logical, public :: is_initialized = .false. Sentinel to check if file is initialized. Type-Bound Procedures generic, public :: assignment(=) => file_assign_file Overload = . private pure subroutine file_assign_file (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: lhs Left hand side. type( file_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: close Close file. private subroutine close (self) Close file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. procedure, public, pass(self) :: description Return a pretty-formatted description of the file. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(in) :: self Files collection. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy file. private elemental subroutine destroy (self) Destroy file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. procedure, public, pass(lhs) :: file_assign_file Operator = . private pure subroutine file_assign_file (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: lhs Left hand side. type( file_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: initialize Initialize file. private elemental subroutine initialize (self, file_name) Initialize File. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. procedure, public, pass(self) :: load_file_name_from_file Load file name from file. private subroutine load_file_name_from_file (self, fini, section_name, option_name, go_on_fail) Load file name from file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file. logical, intent(in), optional :: go_on_fail Go on if load fails. procedure, public, pass(self) :: load_grid_dimensions_from_file Load the grid dimensions of all blocks from file. private subroutine load_grid_dimensions_from_file (self, grid_dimensions, file_name) Load the grid dimensions of all blocks from file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(inout) :: grid_dimensions Grid dimensions off all blocks into file. character(len=*), intent(in), optional :: file_name File name. procedure, public, pass(self) :: load_nodes_from_file Load nodes coordinates from file. private subroutine load_nodes_from_file (self, grid_dimensions, blocks, file_name) Load nodes coordinates from file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. type( block_object ), intent(inout) :: blocks (1:) Blocks storage. character(len=*), intent(in), optional :: file_name File name. procedure, public, pass(self) :: open Open file. private subroutine open (self, file_name, format, action, access) Open file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: format File format. character(len=*), intent(in), optional :: action File action. character(len=*), intent(in), optional :: access File access. procedure, public, pass(self) :: save_file_name_into_file Save file name into file. private subroutine save_file_name_into_file (self, fini, section_name, option_name) Save file name into file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file. procedure, public, pass(self) :: save_grid_dimensions_into_file Save the grid dimensions of all blocks into file. private subroutine save_grid_dimensions_into_file (self, grid_dimensions) Load the grid dimensions of all blocks into file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. procedure, public, pass(self) :: save_nodes_into_file Save nodes coordinates into file. private subroutine save_nodes_into_file (self, grid_dimensions, blocks) Save nodes coordinates into file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. type( block_object ), intent(inout) :: blocks (1:) Blocks storage. Source Code type , extends ( file_object ) :: file_grid_object !< File grid object class. contains ! public methods procedure , pass ( self ) :: load_grid_dimensions_from_file !< Load the grid dimensions of all blocks from file. procedure , pass ( self ) :: load_nodes_from_file !< Load nodes coordinates from file. procedure , pass ( self ) :: save_grid_dimensions_into_file !< Save the grid dimensions of all blocks into file. procedure , pass ( self ) :: save_nodes_into_file !< Save nodes coordinates into file. endtype file_grid_object","tags":"","loc":"type/file_grid_object.html","title":"file_grid_object – OFF "},{"text":"type, public :: file_object type~~file_object~~InheritsGraph type~file_object file_object type~error_object error_object type~error_object->type~file_object error Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). File object class. Inherited By type~~file_object~~InheritedByGraph type~file_object file_object type~files_collection_object files_collection_object type~file_object->type~files_collection_object boundary_conditions, grid, initial_conditions, logging, solution type~file_grid_object file_grid_object type~file_object->type~file_grid_object type~simulation_object simulation_object type~file_grid_object->type~simulation_object file_grid var pantypefile_objectInheritedByGraph = svgPanZoom('#typefile_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables error file_name file_unit is_connected is_initialized Type-Bound Procedures assignment(=) close description destroy file_assign_file initialize load_file_name_from_file open save_file_name_into_file Source Code file_object Components Type Visibility Attributes Name Initial type( error_object ), public :: error Errors handler. character(len=:), public, allocatable :: file_name File name. integer(kind=I4P), public :: file_unit = 0 File unit. logical, public :: is_connected = .false. Sentinel to check if file is connected. logical, public :: is_initialized = .false. Sentinel to check if file is initialized. Type-Bound Procedures generic, public :: assignment(=) => file_assign_file Overload = . private pure subroutine file_assign_file (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: lhs Left hand side. type( file_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: close Close file. private subroutine close (self) Close file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. procedure, public, pass(self) :: description Return a pretty-formatted description of the file. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(in) :: self Files collection. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy file. private elemental subroutine destroy (self) Destroy file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. procedure, public, pass(lhs) :: file_assign_file Operator = . private pure subroutine file_assign_file (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: lhs Left hand side. type( file_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: initialize Initialize file. private elemental subroutine initialize (self, file_name) Initialize File. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. procedure, public, pass(self) :: load_file_name_from_file Load file name from file. private subroutine load_file_name_from_file (self, fini, section_name, option_name, go_on_fail) Load file name from file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file. logical, intent(in), optional :: go_on_fail Go on if load fails. procedure, public, pass(self) :: open Open file. private subroutine open (self, file_name, format, action, access) Open file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: format File format. character(len=*), intent(in), optional :: action File action. character(len=*), intent(in), optional :: access File access. procedure, public, pass(self) :: save_file_name_into_file Save file name into file. private subroutine save_file_name_into_file (self, fini, section_name, option_name) Save file name into file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file. Source Code type :: file_object !< File object class. type ( error_object ) :: error !< Errors handler. character ( len = :), allocatable :: file_name !< File name. integer ( I4P ) :: file_unit = 0 !< File unit. logical :: is_initialized = . false . !< Sentinel to check if file is initialized. logical :: is_connected = . false . !< Sentinel to check if file is connected. contains ! public methods procedure , pass ( self ) :: close !< Close file. procedure , pass ( self ) :: description !< Return a pretty-formatted description of the file. procedure , pass ( self ) :: destroy !< Destroy file. procedure , pass ( self ) :: initialize !< Initialize file. procedure , pass ( self ) :: load_file_name_from_file !< Load file name from file. procedure , pass ( self ) :: open !< Open file. procedure , pass ( self ) :: save_file_name_into_file !< Save file name into file. ! operators generic :: assignment ( = ) => file_assign_file !< Overload `=`. ! private methods procedure , pass ( lhs ) :: file_assign_file !< Operator `=`. endtype file_object","tags":"","loc":"type/file_object.html","title":"file_object – OFF "},{"text":"type, public :: files_collection_object type~~files_collection_object~~InheritsGraph type~files_collection_object files_collection_object type~file_object file_object type~file_object->type~files_collection_object boundary_conditions, grid, initial_conditions, logging, solution type~error_object error_object type~error_object->type~file_object error Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Files collection object class. Variables boundary_conditions grid initial_conditions logging solution Type-Bound Procedures description destroy initialize load_from_file save_into_file Source Code files_collection_object Components Type Visibility Attributes Name Initial type( file_object ), public :: boundary_conditions Boundary conditions file. type( file_object ), public :: grid Grid file. type( file_object ), public :: initial_conditions Initial conditions file. type( file_object ), public :: logging Logging file. type( file_object ), public :: solution Solution file. Type-Bound Procedures procedure, public, pass(self) :: description Return a pretty-formatted description of the files collection. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(in) :: self Files collection. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy files collection. private elemental subroutine destroy (self) Destroy files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. procedure, public, pass(self) :: initialize Initialize files collection. private elemental subroutine initialize (self) Initialize Files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. procedure, public, pass(self) :: load_from_file Load from file. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails.. procedure, public, pass(self) :: save_into_file Save into file. private subroutine save_into_file (self, fini) Save from file. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code type :: files_collection_object !< Files collection object class. type ( file_object ) :: boundary_conditions !< Boundary conditions file. type ( file_object ) :: grid !< Grid file. type ( file_object ) :: initial_conditions !< Initial conditions file. type ( file_object ) :: logging !< Logging file. type ( file_object ) :: solution !< Solution file. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of the files collection. procedure , pass ( self ) :: destroy !< Destroy files collection. procedure , pass ( self ) :: initialize !< Initialize files collection. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. endtype files_collection_object","tags":"","loc":"type/files_collection_object.html","title":"files_collection_object – OFF "},{"text":"type, public :: free_conditions_object type~~free_conditions_object~~InheritsGraph type~free_conditions_object free_conditions_object type~error_object error_object type~error_object->type~free_conditions_object error vector vector vector->type~free_conditions_object velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Free conditions object class. Define the conditions of the free stream . Inherited By type~~free_conditions_object~~InheritedByGraph type~free_conditions_object free_conditions_object type~simulation_object simulation_object type~free_conditions_object->type~simulation_object free_conditions Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables error velocity Type-Bound Procedures assignment(=) description destroy free_assign_free initialize load_from_file save_into_file Source Code free_conditions_object Components Type Visibility Attributes Name Initial type( error_object ), public :: error Errors handler. type(vector), public :: velocity Velocity. Type-Bound Procedures generic, public :: assignment(=) => free_assign_free Overload = . private pure subroutine free_assign_free (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: lhs Left hand side. type( free_conditions_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description Return a pretty-formatted description of the free conditions. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(in) :: self Free conditions. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy free conditions. private elemental subroutine destroy (self) Destroy free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. procedure, public, pass(lhs) :: free_assign_free Operator = . private pure subroutine free_assign_free (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: lhs Left hand side. type( free_conditions_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: initialize Initialize free conditions. private elemental subroutine initialize (self) Initialize free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. procedure, public, pass(self) :: load_from_file Load from file. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. procedure, public, pass(self) :: save_into_file Save into file. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code type :: free_conditions_object !< Free conditions object class. !< !< Define the conditions of the **free stream**. type ( error_object ) :: error !< Errors handler. type ( vector ) :: velocity !< Velocity. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of the free conditions. procedure , pass ( self ) :: destroy !< Destroy free conditions. procedure , pass ( self ) :: initialize !< Initialize free conditions. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. ! operators generic :: assignment ( = ) => free_assign_free !< Overload `=`. ! private methods procedure , pass ( lhs ) :: free_assign_free !< Operator `=`. endtype free_conditions_object","tags":"","loc":"type/free_conditions_object.html","title":"free_conditions_object – OFF "},{"text":"type, public :: grid_dimensions_object type~~grid_dimensions_object~~InheritsGraph type~grid_dimensions_object grid_dimensions_object type~block_signature_object block_signature_object type~block_signature_object->type~grid_dimensions_object block_signature vector vector vector->type~block_signature_object emax, emin Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Grid dimensions object class. Inherited By type~~grid_dimensions_object~~InheritedByGraph type~grid_dimensions_object grid_dimensions_object type~simulation_object simulation_object type~grid_dimensions_object->type~simulation_object grid_dimensions Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables block_signature blocks_number Type-Bound Procedures assignment(=) description destroy grid_d_assign_grid_d initialize iolength iopos_block_nodes load_from_file save_into_file Source Code grid_dimensions_object Components Type Visibility Attributes Name Initial type( block_signature_object ), public, allocatable :: block_signature (:) Signature of each block. integer(kind=I4P), public :: blocks_number = 0 Number of blocks, blobal (whole) number on all process/image. Type-Bound Procedures generic, public :: assignment(=) => grid_d_assign_grid_d Overload = . private pure subroutine grid_d_assign_grid_d (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: lhs Left hand side. type( grid_dimensions_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description Return a pretty-formatted description of grid dimensions. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy grid dimensions. private elemental subroutine destroy (self) Destroy grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. procedure, public, pass(lhs) :: grid_d_assign_grid_d Operator = . private pure subroutine grid_d_assign_grid_d (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: lhs Left hand side. type( grid_dimensions_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: initialize Initialize grid dimensions. private pure subroutine initialize (self, block_signature) Initialize grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. type( block_signature_object ), intent(in), optional :: block_signature (1:) Dimensions of each block. procedure, public, pass(self) :: iolength Return the IO length storage. private function iolength (self) Return the IO length storage. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. Return Value integer(kind=I4P) IO length storage. procedure, public, pass(self) :: iopos_block_nodes Return the IO position where nodes of block b-th are stored. private function iopos_block_nodes (self, b) Return the IO position where nodes of block b-th are stored. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: b Block index. Return Value integer(kind=I4P) IO position where nodes of block b-th are stored. procedure, public, pass(self) :: load_from_file Load grid dimensions from file. private subroutine load_from_file (self, file_unit) Load grid dimensions from file. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: file_unit File unit. procedure, public, pass(self) :: save_into_file Save grid dimensions into file. private subroutine save_into_file (self, file_unit) Load the grid dimensions of all blocks from file. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code type :: grid_dimensions_object !< Grid dimensions object class. integer ( I4P ) :: blocks_number = 0 !< Number of blocks, blobal (whole) number on all process/image. type ( block_signature_object ), allocatable :: block_signature (:) !< Signature of each block. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of grid dimensions. procedure , pass ( self ) :: destroy !< Destroy grid dimensions. procedure , pass ( self ) :: initialize !< Initialize grid dimensions. procedure , pass ( self ) :: iolength !< Return the IO length storage. procedure , pass ( self ) :: iopos_block_nodes !< Return the IO position where nodes of block b-th are stored. procedure , pass ( self ) :: load_from_file !< Load grid dimensions from file. procedure , pass ( self ) :: save_into_file !< Save grid dimensions into file. ! operators generic :: assignment ( = ) => grid_d_assign_grid_d !< Overload `=`. ! private methods procedure , pass ( lhs ) :: grid_d_assign_grid_d !< Operator `=`. endtype grid_dimensions_object","tags":"","loc":"type/grid_dimensions_object.html","title":"grid_dimensions_object – OFF "},{"text":"type, public :: node_object type~~node_object~~InheritsGraph type~node_object node_object vector vector vector->type~node_object vertex Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Node object class. Inherited By type~~node_object~~InheritedByGraph type~node_object node_object type~block_object block_object type~node_object->type~block_object node type~simulation_object simulation_object type~block_object->type~simulation_object blocks Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables vertex Type-Bound Procedures assignment(=) destroy initialize node_assign_node Source Code node_object Components Type Visibility Attributes Name Initial type(vector), public :: vertex Vertex coordinates. Type-Bound Procedures generic, public :: assignment(=) => node_assign_node Overload = . private pure subroutine node_assign_node (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: lhs Left hand side. type( node_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: destroy Destroy node. private elemental subroutine destroy (self) Destroy node. Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: self Node object. procedure, public, pass(self) :: initialize Initialize node. private pure subroutine initialize (self) Initialize node. Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: self Node object. procedure, public, pass(lhs) :: node_assign_node Operator = . private pure subroutine node_assign_node (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: lhs Left hand side. type( node_object ), intent(in) :: rhs Right hand side. Source Code type :: node_object !< Node object class. type ( vector ) :: vertex !< Vertex coordinates. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy node. procedure , pass ( self ) :: initialize !< Initialize node. ! operators generic :: assignment ( = ) => node_assign_node !< Overload `=`. ! private methods procedure , pass ( lhs ) :: node_assign_node !< Operator `=`. endtype node_object","tags":"","loc":"type/node_object.html","title":"node_object – OFF "},{"text":"type, public :: non_dimensional_numbers_object type~~non_dimensional_numbers_object~~InheritsGraph type~non_dimensional_numbers_object non_dimensional_numbers_object type~error_object error_object type~error_object->type~non_dimensional_numbers_object error Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Non dimensional numbers object class. Inherited By type~~non_dimensional_numbers_object~~InheritedByGraph type~non_dimensional_numbers_object non_dimensional_numbers_object type~simulation_object simulation_object type~non_dimensional_numbers_object->type~simulation_object adimensionals Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables Dt0 E0 Fr Fr2_inv L0 Ma Pr PrRe_inv Re Re_inv T0 We a0 c0 error f0 k0 mu0 p0 q0 r0 v0 Type-Bound Procedures adim_assign_adim assignment(=) compute_reference_values description destroy initialize load_from_file save_into_file Source Code non_dimensional_numbers_object Components Type Visibility Attributes Name Initial real(kind=R8P), public :: Dt0 = 1._R8P Dt_0=\\frac{L_0}{v_0} Reference time interval. real(kind=R8P), public :: E0 = 1._R8P E_0=v_0&#94;2 Reference specific energy. real(kind=R8P), public :: Fr = 1._R8P \\rm{Fr}=\\sqrt{\\frac{v_0&#94;2}{f_0 L_0}} Froude number. real(kind=R8P), public :: Fr2_inv = 1._R8P \\frac{1}{\\rm{Fr}&#94;2} Inverse of square of Froude number (coefficient of volume forces). real(kind=R8P), public :: L0 = 1._R8P Reference length. real(kind=R8P), public :: Ma = 1._R8P \\rm{We}=\\sqrt{\\frac{v_0}{a_0}} Mach number. real(kind=R8P), public :: Pr = 1._R8P \\rm{Pr}=\\frac{\\mu_0 c_p}{k_0} Prandtl number. real(kind=R8P), public :: PrRe_inv = 1._R8P \\frac{1}{\\rm{Pr Re}} Inverse of Prandtl and Reynolds numbers (coef. of condution terms). real(kind=R8P), public :: Re = 1._R8P \\rm{Re}=\\frac{\\rho_0 v_0 L_0}{\\mu_0} Reynolds number. real(kind=R8P), public :: Re_inv = 1._R8P \\frac{1}{\\rm{Re}} Inverse of Reynolds number (coefficient of viscous terms). real(kind=R8P), public :: T0 = 1._R8P T_0=\\frac{v_0&#94;2}{c_0} Reference temperature. real(kind=R8P), public :: We = 1._R8P \\rm{We}=\\sqrt{\\frac{\\rho_0 v_0&#94;2 L_0}{\\sigma_0}} Weber number. real(kind=R8P), public :: a0 = 1._R8P a_0=v_0 Reference speed of sound. real(kind=R8P), public :: c0 = 1._R8P Reference specific heats (\\f$cp_0 = cv_0 = R_0 = c_0\\f$). type( error_object ), public :: error Errors handler. real(kind=R8P), public :: f0 = 1._R8P f_0= \\frac{v_0&#94;2}{L_0 \\rm{Fr}&#94;2} Reference specific force. real(kind=R8P), public :: k0 = 1._R8P k_0= \\frac{\\mu_0 c_0}{\\rm{Pr}} Reference thermal conductivity coefficient. real(kind=R8P), public :: mu0 = 1._R8P \\mu_0= \\frac{\\rho_0 v_0 L_0}{\\rm{Re}} Reference dynamic viscosity. real(kind=R8P), public :: p0 = 1._R8P p_0=\\rho_0 v_0&#94;2 Reference pressure. real(kind=R8P), public :: q0 = 1._R8P q_0=\\frac{v_0&#94;3}{L_0} Reference specific heat. real(kind=R8P), public :: r0 = 1._R8P Reference density. real(kind=R8P), public :: v0 = 1._R8P Reference velocity. Type-Bound Procedures procedure, public, pass(lhs) :: adim_assign_adim Operator = . private pure subroutine adim_assign_adim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: lhs Left hand side. type( non_dimensional_numbers_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => adim_assign_adim Overload = . private pure subroutine adim_assign_adim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: lhs Left hand side. type( non_dimensional_numbers_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: compute_reference_values Compute derived reference values. private elemental subroutine compute_reference_values (self) Compute derived reference values. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. procedure, public, pass(self) :: description Return a pretty-formatted description of the numbers. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the numbers. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(in) :: self Non dimensional numbers. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy numbers value. private elemental subroutine destroy (self) Destroy numbers value. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. procedure, public, pass(self) :: initialize Initialize numbers value. private elemental subroutine initialize (self) Initialize numbers value. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. procedure, public, pass(self) :: load_from_file Load from file. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. procedure, public, pass(self) :: save_into_file Save into file. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Simulation parameters. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code type :: non_dimensional_numbers_object !< Non dimensional numbers object class. type ( error_object ) :: error !< Errors handler. ! non dimensional numbers imposed real ( R8P ) :: Re = 1._R8P !< \\rm{Re}=\\frac{\\rho_0 v_0 L_0}{\\mu_0} Reynolds number. real ( R8P ) :: Fr = 1._R8P !< \\rm{Fr}=\\sqrt{\\frac{v_0&#94;2}{f_0 L_0}} Froude number. real ( R8P ) :: We = 1._R8P !< \\rm{We}=\\sqrt{\\frac{\\rho_0 v_0&#94;2 L_0}{\\sigma_0}} Weber number. real ( R8P ) :: Ma = 1._R8P !< \\rm{We}=\\sqrt{\\frac{v_0}{a_0}} Mach number. real ( R8P ) :: Pr = 1._R8P !< \\rm{Pr}=\\frac{\\mu_0 c_p}{k_0} Prandtl number. ! reference values imposed real ( R8P ) :: L0 = 1._R8P !< Reference length. real ( R8P ) :: r0 = 1._R8P !< Reference density. real ( R8P ) :: v0 = 1._R8P !< Reference velocity. real ( R8P ) :: c0 = 1._R8P !< Reference specific heats (\\f$cp_0 = cv_0 = R_0 = c_0\\f$). ! derived reference values real ( R8P ) :: mu0 = 1._R8P !< \\mu_0= \\frac{\\rho_0 v_0 L_0}{\\rm{Re}} Reference dynamic viscosity. real ( R8P ) :: f0 = 1._R8P !< f_0= \\frac{v_0&#94;2}{L_0 \\rm{Fr}&#94;2} Reference specific force. real ( R8P ) :: k0 = 1._R8P !< k_0= \\frac{\\mu_0 c_0}{\\rm{Pr}} Reference thermal conductivity coefficient. real ( R8P ) :: Dt0 = 1._R8P !< Dt_0=\\frac{L_0}{v_0} Reference time interval. real ( R8P ) :: p0 = 1._R8P !< p_0=\\rho_0 v_0&#94;2 Reference pressure. real ( R8P ) :: a0 = 1._R8P !< a_0=v_0 Reference speed of sound. real ( R8P ) :: T0 = 1._R8P !< T_0=\\frac{v_0&#94;2}{c_0} Reference temperature. real ( R8P ) :: E0 = 1._R8P !< E_0=v_0&#94;2 Reference specific energy. real ( R8P ) :: q0 = 1._R8P !< q_0=\\frac{v_0&#94;3}{L_0} Reference specific heat. ! equations coefficients real ( R8P ) :: Re_inv = 1._R8P !< \\frac{1}{\\rm{Re}} Inverse of Reynolds number (coefficient of viscous terms). real ( R8P ) :: Fr2_inv = 1._R8P !< \\frac{1}{\\rm{Fr}&#94;2} Inverse of square of Froude number (coefficient of volume forces). real ( R8P ) :: PrRe_inv = 1._R8P !< \\frac{1}{\\rm{Pr Re}} Inverse of Prandtl and Reynolds numbers (coef. of condution terms). contains ! public methods procedure , pass ( self ) :: compute_reference_values !< Compute derived reference values. procedure , pass ( self ) :: description !< Return a pretty-formatted description of the numbers. procedure , pass ( self ) :: destroy !< Destroy numbers value. procedure , pass ( self ) :: initialize !< Initialize numbers value. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. ! operators generic :: assignment ( = ) => adim_assign_adim !< Overload `=`. ! private methods procedure , pass ( lhs ) :: adim_assign_adim !< Operator `=`. endtype non_dimensional_numbers_object","tags":"","loc":"type/non_dimensional_numbers_object.html","title":"non_dimensional_numbers_object – OFF "},{"text":"type, public :: os_object type~~os_object~~InheritsGraph type~os_object os_object type~error_object error_object type~error_object->type~os_object error Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). OS object class. This class is designed as an helper for performing system calls, e.g. make directory, copy files, etc… Inherited By type~~os_object~~InheritedByGraph type~os_object os_object type~simulation_object simulation_object type~os_object->type~simulation_object os Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables cp_dir_command cp_file_command error mkdir_command path_separator rm_dir_command rm_file_command Type-Bound Procedures assignment(=) cp destroy initialize initialize_unix initialize_windows mkdir os_assign_os rm Source Code os_object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cp_dir_command Copy directory command. character(len=:), public, allocatable :: cp_file_command Copy file command. type( error_object ), public :: error Error handler. character(len=:), public, allocatable :: mkdir_command Make directory command. character(len=:), public, allocatable :: path_separator Path seperator, e.g. \"/\" for unix-like systems. character(len=:), public, allocatable :: rm_dir_command Remove directory command. character(len=:), public, allocatable :: rm_file_command Remove file command. Type-Bound Procedures generic, public :: assignment(=) => os_assign_os Overload = . private pure subroutine os_assign_os (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: lhs Left hand side. type( os_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: cp Copy files/directories. private subroutine cp (self, file_name, dir_name) Copy files/directories. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: dir_name Dir name. procedure, public, pass(self) :: destroy Destroy OS… not your :-) private elemental subroutine destroy (self) Destroy OS… not your :-) Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. procedure, public, pass(self) :: initialize Initialze OS. private elemental subroutine initialize (self, system) Initialize OS. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: system System name, valid [unix, windows]. procedure, public, pass(self) :: initialize_unix Initialze OS as unix-like system. private elemental subroutine initialize_unix (self) Initialize OS as unix-like system. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. procedure, public, pass(self) :: initialize_windows Initialze OS as windows-like system. private elemental subroutine initialize_windows (self) Initialize OS as windows-like system. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. procedure, public, pass(self) :: mkdir Make directory. private subroutine mkdir (self, dir_name) Make directoriy. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in) :: dir_name Dir name. procedure, public, pass(lhs) :: os_assign_os Operator = . private pure subroutine os_assign_os (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: lhs Left hand side. type( os_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: rm Remove files/directories. private subroutine rm (self, file_name, dir_name) Remove files/directories. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: dir_name Dir name. Source Code type :: os_object !< OS object class. !< !< This class is designed as an helper for performing system calls, e.g. make directory, copy files, etc... type ( error_object ) :: error !< Error handler. character ( len = :), allocatable :: path_separator !< Path seperator, e.g. \"/\" for unix-like systems. character ( len = :), allocatable :: cp_dir_command !< Copy directory command. character ( len = :), allocatable :: cp_file_command !< Copy file command. character ( len = :), allocatable :: mkdir_command !< Make directory command. character ( len = :), allocatable :: rm_dir_command !< Remove directory command. character ( len = :), allocatable :: rm_file_command !< Remove file command. contains ! public methods procedure , pass ( self ) :: cp !< Copy files/directories. procedure , pass ( self ) :: destroy !< Destroy OS... not your :-) procedure , pass ( self ) :: initialize !< Initialze OS. procedure , pass ( self ) :: mkdir !< Make directory. procedure , pass ( self ) :: rm !< Remove files/directories. ! operators generic :: assignment ( = ) => os_assign_os !< Overload `=`. ! private methods procedure , pass ( self ) :: initialize_unix !< Initialze OS as unix-like system. procedure , pass ( self ) :: initialize_windows !< Initialze OS as windows-like system. procedure , pass ( lhs ) :: os_assign_os !< Operator `=`. endtype os_object","tags":"","loc":"type/os_object.html","title":"os_object – OFF "},{"text":"type, public :: simulation_object type~~simulation_object~~InheritsGraph type~simulation_object simulation_object command_line_interface command_line_interface command_line_interface->type~simulation_object cli type~file_grid_object file_grid_object type~file_grid_object->type~simulation_object file_grid type~solver_object solver_object type~solver_object->type~simulation_object solver type~error_object error_object type~error_object->type~simulation_object error type~error_object->type~file_grid_object error type~error_object->type~solver_object error type~non_dimensional_numbers_object non_dimensional_numbers_object type~error_object->type~non_dimensional_numbers_object error type~block_object block_object type~error_object->type~block_object error type~os_object os_object type~error_object->type~os_object error type~time_object time_object type~error_object->type~time_object error type~free_conditions_object free_conditions_object type~error_object->type~free_conditions_object error type~file_object file_object type~error_object->type~file_object error type~non_dimensional_numbers_object->type~simulation_object adimensionals type~block_object->type~simulation_object blocks type~os_object->type~simulation_object os type~grid_dimensions_object grid_dimensions_object type~grid_dimensions_object->type~simulation_object grid_dimensions type~time_object->type~simulation_object time type~free_conditions_object->type~simulation_object free_conditions type~file_object->type~file_grid_object type~block_signature_object block_signature_object type~block_signature_object->type~block_object signature type~block_signature_object->type~grid_dimensions_object block_signature type~cell_object cell_object type~cell_object->type~block_object cell type~face_object face_object type~face_object->type~block_object face_i, face_j, face_k type~node_object node_object type~node_object->type~block_object node vector vector vector->type~free_conditions_object velocity vector->type~block_signature_object emax, emin vector->type~cell_object center vector->type~face_object normal vector->type~node_object vertex var pantypesimulation_objectInheritsGraph = svgPanZoom('#typesimulation_objectInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Simulation object class. simulation_object is a container for all simulation data for each processor/image. Variables adimensionals blocks cli error file_grid file_parameters free_conditions go_on_fail grid_dimensions is_cli_parsed is_output_verbose os solver time Type-Bound Procedures allocate_blocks description destroy initialize integrate load_file_grid load_file_parameters load_input_files parse_command_line_interface save_file_grid save_file_parameters set_command_line_interface Source Code simulation_object Components Type Visibility Attributes Name Initial type( non_dimensional_numbers_object ), public :: adimensionals Non dimensional numbers. type( block_object ), public, allocatable :: blocks (:) Blocks list. type(command_line_interface), public :: cli Command line interface. type( error_object ), public :: error Errors handler. type( file_grid_object ), public :: file_grid Grid file handler. character(len=999), public :: file_parameters = '' Name of simulation parameters file. type( free_conditions_object ), public :: free_conditions Free stream conditions. logical, public :: go_on_fail = .false. Allow/disallow parameters loading failure. type( grid_dimensions_object ), public :: grid_dimensions Grid dimensions. logical, public :: is_cli_parsed = .false. Sentinel of CLI parsing. logical, public :: is_output_verbose = .false. Verbose output. type( os_object ), public :: os Running Operating System. type( solver_object ), public :: solver solver models parameters. type( time_object ), public :: time Timing conditions. Type-Bound Procedures procedure, public, pass(self) :: allocate_blocks Allocate blocks accordingly to grid dimensions. private subroutine allocate_blocks (self) Allocate blocks accordingly to grid dimensions. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation data. procedure, public, pass(self) :: description Return a pretty-formatted description of the simulation. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the simulation. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(in) :: self Simulation parameters. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy simulation data. private elemental subroutine destroy (self) Destroy simulation data. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation data. procedure, public, pass(self) :: initialize Initialize simulation. private subroutine initialize (self, blocks, parse_cli, load_files) Initialize simulation. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. type( block_object ), intent(in), optional :: blocks (1:) Blocks structure. logical, intent(in), optional :: parse_cli Enable CLI parsing. logical, intent(in), optional :: load_files Enable files loading. procedure, public, pass(self) :: integrate Integrate the equations. private subroutine integrate (self) Integrate the equations. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. procedure, public, pass(self) :: load_file_grid Load grid file. private subroutine load_file_grid (self, file_basename) Load grid file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. character(len=*), intent(in) :: file_basename File basename. procedure, public, pass(self) :: load_file_parameters Load file parameters. private subroutine load_file_parameters (self, file_name, go_on_fail) Load file parameters. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation object. character(len=*), intent(in) :: file_name File name. logical, intent(in), optional :: go_on_fail Go on if load fails. procedure, public, pass(self) :: load_input_files Load input files. private subroutine load_input_files (self) Load from file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. procedure, public, pass(self) :: parse_command_line_interface Parse command line interface. private subroutine parse_command_line_interface (self) Parse command line interface. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. procedure, public, pass(self) :: save_file_grid Save grid file. private subroutine save_file_grid (self, file_basename, ascii, metrics, off, tecplot, vtk) Save grid file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. character(len=*), intent(in) :: file_basename File basename. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. logical, intent(in), optional :: off Save in OFF format sentinel. logical, intent(in), optional :: tecplot Tecplot output format sentinel. logical, intent(in), optional :: vtk VTK output format sentinel. procedure, public, pass(self) :: save_file_parameters Save file parameters. private subroutine save_file_parameters (self, file_name) Save file parameters. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation object. character(len=*), intent(in) :: file_name File name. procedure, private, pass(self) :: set_command_line_interface Set command line interface. private subroutine set_command_line_interface (self) Set command line interface. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. Source Code type :: simulation_object !< Simulation object class. !< !< [[simulation_object]] is a container for all simulation data for each processor/image. type ( error_object ) :: error !< Errors handler. type ( command_line_interface ) :: cli !< Command line interface. type ( file_grid_object ) :: file_grid !< Grid file handler. type ( non_dimensional_numbers_object ) :: adimensionals !< Non dimensional numbers. type ( free_conditions_object ) :: free_conditions !< Free stream conditions. type ( os_object ) :: os !< Running Operating System. type ( solver_object ) :: solver !< solver models parameters. type ( time_object ) :: time !< Timing conditions. type ( grid_dimensions_object ) :: grid_dimensions !< Grid dimensions. type ( block_object ), allocatable :: blocks (:) !< Blocks list. logical :: is_cli_parsed = . false . !< Sentinel of CLI parsing. character ( 999 ) :: file_parameters = '' !< Name of simulation parameters file. logical :: is_output_verbose = . false . !< Verbose output. logical :: go_on_fail = . false . !< Allow/disallow parameters loading failure. contains ! public methods procedure , pass ( self ) :: allocate_blocks !< Allocate blocks accordingly to grid dimensions. procedure , pass ( self ) :: description !< Return a pretty-formatted description of the simulation. procedure , pass ( self ) :: destroy !< Destroy simulation data. procedure , pass ( self ) :: initialize !< Initialize simulation. procedure , pass ( self ) :: integrate !< Integrate the equations. procedure , pass ( self ) :: load_file_grid !< Load grid file. procedure , pass ( self ) :: load_file_parameters !< Load file parameters. procedure , pass ( self ) :: load_input_files !< Load input files. procedure , pass ( self ) :: parse_command_line_interface !< Parse command line interface. procedure , pass ( self ) :: save_file_grid !< Save grid file. procedure , pass ( self ) :: save_file_parameters !< Save file parameters. ! private methods procedure , pass ( self ), private :: set_command_line_interface !< Set command line interface. endtype simulation_object","tags":"","loc":"type/simulation_object.html","title":"simulation_object – OFF "},{"text":"type, public :: solver_object type~~solver_object~~InheritsGraph type~solver_object solver_object type~error_object error_object type~error_object->type~solver_object error Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Solver object class. Class designed to handle the general solver models parameters. Inherited By type~~solver_object~~InheritedByGraph type~solver_object solver_object type~simulation_object simulation_object type~solver_object->type~simulation_object solver Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables artificial_viscosity chimera_forcing convective_operator diffusive_operator error pseudo_compressibility residuals_tolerance time_integrator turbulence_model Type-Bound Procedures assignment(=) description destroy initialize load_from_file save_into_file solver_assign_solver Source Code solver_object Components Type Visibility Attributes Name Initial real(kind=R8P), public :: artificial_viscosity = 0._R8P Artifiical viscosity. real(kind=R8P), public :: chimera_forcing = 0._R8P Chimera forcing coefficient. character(len=:), public, allocatable :: convective_operator Convective operator model: tvd, eno3, weno3(5-17)… character(len=:), public, allocatable :: diffusive_operator Diffusive operator model: centered2(4-10)… type( error_object ), public :: error Errors handler. real(kind=R8P), public :: pseudo_compressibility = 0._R8P Pseudo compressibility. real(kind=R8P), public :: residuals_tolerance = 0._R8P Tolerance on residuals value. character(len=:), public, allocatable :: time_integrator Time integrator model: euler, rk2(3-10), ab2(3-12)… character(len=:), public, allocatable :: turbulence_model Turbulence_model: k-e, k-w, less… Type-Bound Procedures generic, public :: assignment(=) => solver_assign_solver Overload = . private pure subroutine solver_assign_solver (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: lhs Left hand side. type( solver_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description Return a pretty-formatted description of solver parameters. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of solver parameters. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(in) :: self Solver object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy solver. private elemental subroutine destroy (self) Destroy solver. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. procedure, public, pass(self) :: initialize Initialize solver. private elemental subroutine initialize (self) Initialize solver. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. procedure, public, pass(self) :: load_from_file Load from file. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. procedure, public, pass(self) :: save_into_file Save into file. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. procedure, public, pass(lhs) :: solver_assign_solver Operator = . private pure subroutine solver_assign_solver (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: lhs Left hand side. type( solver_object ), intent(in) :: rhs Right hand side. Source Code type :: solver_object !< Solver object class. !< !< Class designed to handle the general solver models parameters. type ( error_object ) :: error !< Errors handler. character ( len = :), allocatable :: time_integrator !< Time integrator model: euler, rk2(3-10), ab2(3-12)... character ( len = :), allocatable :: convective_operator !< Convective operator model: tvd, eno3, weno3(5-17)... character ( len = :), allocatable :: diffusive_operator !< Diffusive operator model: centered2(4-10)... character ( len = :), allocatable :: turbulence_model !< Turbulence_model: k-e, k-w, less... real ( R8P ) :: artificial_viscosity = 0._R8P !< Artifiical viscosity. real ( R8P ) :: residuals_tolerance = 0._R8P !< Tolerance on residuals value. real ( R8P ) :: pseudo_compressibility = 0._R8P !< Pseudo compressibility. real ( R8P ) :: chimera_forcing = 0._R8P !< Chimera forcing coefficient. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of solver parameters. procedure , pass ( self ) :: destroy !< Destroy solver. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. ! operators generic :: assignment ( = ) => solver_assign_solver !< Overload `=`. ! private methods procedure , pass ( lhs ) :: solver_assign_solver !< Operator `=`. endtype solver_object","tags":"","loc":"type/solver_object.html","title":"solver_object – OFF "},{"text":"type, public :: time_object type~~time_object~~InheritsGraph type~time_object time_object type~error_object error_object type~error_object->type~time_object error Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Time object class. Class designed to handle the timing data of the simulation. Inherited By type~~time_object~~InheritedByGraph type~time_object time_object type~simulation_object simulation_object type~time_object->type~simulation_object time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables CFL error is_unsteady n n_max t t_max Type-Bound Procedures assignment(=) description destroy initialize is_the_end load_from_file progress save_into_file set_stop time_assign_time update Source Code time_object Components Type Visibility Attributes Name Initial real(kind=R8P), public :: CFL = 0.3_R8P Courant-Friedrichs-Lewy stability coefficient. type( error_object ), public :: error Errors handler. logical, public :: is_unsteady = .true. Type of simulation: unsteady or steady. integer(kind=I8P), public :: n = 0 Time steps counter. integer(kind=I8P), public :: n_max = 0 Maximum number of time steps computed. real(kind=R8P), public :: t = 0._R8P Time. real(kind=R8P), public :: t_max = 0._R8P Maximum time of integration, ignored if n_max>0 . Type-Bound Procedures generic, public :: assignment(=) => time_assign_time Overload = . private pure subroutine time_assign_time (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: lhs Left hand side. type( time_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description Return a pretty-formatted description of time parameters. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of time parameters. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy time. private elemental subroutine destroy (self) Destroy time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. procedure, public, pass(self) :: initialize Initialize time. private elemental subroutine initialize (self) Initialize time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. procedure, public, pass(self) :: is_the_end Return true if the end of simulation is reached. private elemental function is_the_end (self) result(yes) Return true if the end of simulation is reached. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. Return Value logical Test result. procedure, public, pass(self) :: load_from_file Load from file. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. procedure, public, pass(self) :: progress Return the progress of simulation. private elemental function progress (self) result(prog) Return the progress of simulation. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. Return Value real(kind=R8P) Actual progress value. procedure, public, pass(self) :: save_into_file Save into file. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. procedure, public, pass(self) :: set_stop Set simulation stop condition. private elemental subroutine set_stop (self) Set simulation stop condition. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. procedure, public, pass(lhs) :: time_assign_time Operator = . private pure subroutine time_assign_time (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: lhs Left hand side. type( time_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: update Update time. private elemental subroutine update (self, global_min_dt) Update time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. real(kind=R8P), intent(inout) :: global_min_dt Global (all processes/images, all blocks) minimum time step. Source Code type :: time_object !< Time object class. !< !< Class designed to handle the timing data of the simulation. type ( error_object ) :: error !< Errors handler. logical :: is_unsteady = . true . !< Type of simulation: unsteady or steady. integer ( I8P ) :: n = 0 !< Time steps counter. real ( R8P ) :: t = 0._R8P !< Time. integer ( I8P ) :: n_max = 0 !< Maximum number of time steps computed. real ( R8P ) :: t_max = 0._R8P !< Maximum time of integration, ignored if `n_max>0`. real ( R8P ) :: CFL = 0.3_R8P !< Courant-Friedrichs-Lewy stability coefficient. contains ! public methods procedure , pass ( self ) :: description !< Return a pretty-formatted description of time parameters. procedure , pass ( self ) :: destroy !< Destroy time. procedure , pass ( self ) :: initialize !< Initialize time. procedure , pass ( self ) :: is_the_end !< Return true if the end of simulation is reached. procedure , pass ( self ) :: progress !< Return the progress of simulation. procedure , pass ( self ) :: load_from_file !< Load from file. procedure , pass ( self ) :: save_into_file !< Save into file. procedure , pass ( self ) :: set_stop !< Set simulation stop condition. procedure , pass ( self ) :: update !< Update time. ! operators generic :: assignment ( = ) => time_assign_time !< Overload `=`. ! private methods procedure , pass ( lhs ) :: time_assign_time !< Operator `=`. endtype time_object","tags":"","loc":"type/time_object.html","title":"time_object – OFF "},{"text":"private elemental function cells_number(self, with_ghosts) result(cells_number_) Return the number of cells. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. Source Code cells_number Source Code elemental function cells_number ( self , with_ghosts ) result ( cells_number_ ) !< Return the number of cells. class ( block_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: cells_number_ !< Number of cells. cells_number_ = self % signature % cells_number ( with_ghosts = with_ghosts ) endfunction cells_number","tags":"","loc":"proc/cells_number.html","title":"cells_number – OFF"},{"text":"private pure function node_to_center(self) result(center) Compute cell centers coordinates from cell nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. Return Value type(vector),\n  allocatable,(:,:,:) Cell centers coordinates. Calls proc~~node_to_center~~CallsGraph proc~node_to_center node_to_center gc gc proc~node_to_center->gc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code node_to_center Source Code pure function node_to_center ( self ) result ( center ) !< Compute cell centers coordinates from cell nodes. class ( block_object ), intent ( in ) :: self !< Block. type ( vector ), allocatable :: center (:,:,:) !< Cell centers coordinates. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( gc => self % signature % gc , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) allocate ( center ( 1 - gc ( 1 ) : ni + gc ( 2 ), 1 - gc ( 3 ) : nj + gc ( 4 ), 1 - gc ( 5 ) : nk + gc ( 6 ))) do k = 1 - gc ( 5 ), nk + gc ( 6 ) do j = 1 - gc ( 3 ), nj + gc ( 4 ) do i = 1 - gc ( 1 ), ni + gc ( 2 ) center ( i , j , k ) = ( self % node ( i , j , k )% vertex + & self % node ( i - 1 , j , k )% vertex + & self % node ( i , j - 1 , k )% vertex + & self % node ( i , j , k - 1 )% vertex + & self % node ( i - 1 , j - 1 , k - 1 )% vertex + & self % node ( i , j - 1 , k - 1 )% vertex + & self % node ( i - 1 , j , k - 1 )% vertex + & self % node ( i - 1 , j - 1 , k )% vertex ) * 0.125_R8P enddo enddo enddo endassociate endfunction node_to_center","tags":"","loc":"proc/node_to_center.html","title":"node_to_center – OFF"},{"text":"private elemental function nodes_number(self, with_ghosts) result(nodes_number_) Return the number of nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. Source Code nodes_number Source Code elemental function nodes_number ( self , with_ghosts ) result ( nodes_number_ ) !< Return the number of nodes. class ( block_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: nodes_number_ !< Number of cells. nodes_number_ = self % signature % nodes_number ( with_ghosts = with_ghosts ) endfunction nodes_number","tags":"","loc":"proc/nodes_number.html","title":"nodes_number – OFF"},{"text":"private pure subroutine block_assign_block(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: lhs Left hand side. type( block_object ), intent(in) :: rhs Right hand side. Source Code block_assign_block Source Code pure subroutine block_assign_block ( lhs , rhs ) !< Operator `=`. class ( block_object ), intent ( inout ) :: lhs !< Left hand side. type ( block_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % signature = rhs % signature if ( allocated ( rhs % cell )) then if ( allocated ( lhs % cell )) then call lhs % cell % destroy deallocate ( lhs % cell ) endif lhs % cell = rhs % cell endif if ( allocated ( rhs % face_i )) then if ( allocated ( lhs % face_i )) then call lhs % face_i % destroy deallocate ( lhs % face_i ) endif lhs % face_i = rhs % face_i endif if ( allocated ( rhs % face_j )) then if ( allocated ( lhs % face_j )) then call lhs % face_j % destroy deallocate ( lhs % face_j ) endif lhs % face_j = rhs % face_j endif if ( allocated ( rhs % face_k )) then if ( allocated ( lhs % face_k )) then call lhs % face_k % destroy deallocate ( lhs % face_k ) endif lhs % face_k = rhs % face_k endif if ( allocated ( rhs % node )) then if ( allocated ( lhs % node )) then call lhs % node % destroy deallocate ( lhs % node ) endif lhs % node = rhs % node endif endsubroutine block_assign_block","tags":"","loc":"proc/block_assign_block.html","title":"block_assign_block – OFF"},{"text":"private elemental subroutine compute_extents(self) Compute block extents. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. Source Code compute_extents Source Code elemental subroutine compute_extents ( self ) !< Compute block extents. class ( block_object ), intent ( inout ) :: self !< Block. self % error % status = ERROR_BLOCK_COMPUTE_EXTENTS_FAILED associate ( ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) if ( allocated ( self % node )) then self % signature % emin % x = minval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % x ) self % signature % emin % y = minval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % y ) self % signature % emin % z = minval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % z ) self % signature % emax % x = maxval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % x ) self % signature % emax % y = maxval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % y ) self % signature % emax % z = maxval ( self % node ( 1 : ni , 1 : nj , 1 : nk )% vertex % z ) self % error % status = NO_ERROR endif endassociate endsubroutine compute_extents","tags":"","loc":"proc/compute_extents.html","title":"compute_extents – OFF"},{"text":"private elemental subroutine compute_faces_metrics(self) Compute block faces metrics. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. Calls proc~~compute_faces_metrics~~CallsGraph proc~compute_faces_metrics compute_faces_metrics node node proc~compute_faces_metrics->node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_faces_metrics Source Code elemental subroutine compute_faces_metrics ( self ) !< Compute block faces metrics. class ( block_object ), intent ( inout ) :: self !< Block. type ( vector ) :: triplet ( 1 : 4 ) !< Dummy vectors. real ( R8P ) :: signi !< Sign of direction of normals along I coordinate. real ( R8P ) :: signj !< Sign of direction of normals along J coordinate. real ( R8P ) :: signk !< Sign of direction of normals along K coordinate. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( node => self % node , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) i = max ( 1 , ni ) j = max ( 1 , nj ) k = max ( 1 , nk ) triplet ( 1 ) = node ( i , j , k )% vertex - node ( i , j - 1 , k - 1 )% vertex triplet ( 2 ) = node ( i , j - 1 , k )% vertex - node ( i , j , k - 1 )% vertex triplet ( 3 ) = triplet ( 1 ). cross . triplet ( 2 ) triplet ( 4 ) = ( 0.25_R8P * ( node ( i , j , k )% vertex + node ( i , j - 1 , k )% vertex + & node ( i , j , k - 1 )% vertex + node ( i , j - 1 , k - 1 )% vertex )) - & ( 0.25_R8P * ( node ( i - 1 , j , k )% vertex + node ( i - 1 , j - 1 , k )% vertex + & node ( i - 1 , j , k - 1 )% vertex + node ( i - 1 , j - 1 , k - 1 )% vertex )) signi = sign ( 1._R8P , ( triplet ( 3 ). dot . triplet ( 4 ))) triplet ( 1 ) = node ( i , j , k )% vertex - node ( i - 1 , j , k - 1 )% vertex triplet ( 2 ) = node ( i , j , k - 1 )% vertex - node ( i - 1 , j , k )% vertex triplet ( 3 ) = triplet ( 1 ). cross . triplet ( 2 ) triplet ( 4 ) = ( 0.25_R8P * ( node ( i , j , k )% vertex + node ( i - 1 , j , k )% vertex + & node ( i , j , k - 1 )% vertex + node ( i - 1 , j , k - 1 )% vertex )) - & ( 0.25_R8P * ( node ( i , j - 1 , k )% vertex + node ( i - 1 , j - 1 , k )% vertex + & node ( i , j - 1 , k - 1 )% vertex + node ( i - 1 , j - 1 , k - 1 )% vertex )) signj = sign ( 1._R8P , ( triplet ( 3 ). dot . triplet ( 4 ))) triplet ( 1 ) = node ( i , j , k )% vertex - node ( i - 1 , j - 1 , k )% vertex triplet ( 2 ) = node ( i - 1 , j , k )% vertex - node ( i , j - 1 , k )% vertex triplet ( 3 ) = triplet ( 1 ). cross . triplet ( 2 ) triplet ( 4 ) = ( 0.25_R8P * ( node ( i , j , k )% vertex + node ( i - 1 , j , k )% vertex + & node ( i , j - 1 , k )% vertex + node ( i - 1 , j - 1 , k )% vertex )) - & ( 0.25_R8P * ( node ( i , j , k - 1 )% vertex + node ( i - 1 , j , k - 1 )% vertex + & node ( i , j - 1 , k - 1 )% vertex + node ( i - 1 , j - 1 , k - 1 )% vertex )) signk = sign ( 1._R8P , ( triplet ( 3 ). dot . triplet ( 4 ))) do k = 1 , nk do j = 1 , nj do i = 0 , ni call self % face_i ( i , j , k )% compute_metrics ( pt1 = node ( i , j - 1 , k - 1 )% vertex , & pt2 = node ( i , j , k - 1 )% vertex , & pt3 = node ( i , j , k )% vertex , & pt4 = node ( i , j - 1 , k )% vertex , signd = signi ) enddo enddo enddo do k = 1 , nk do j = 0 , nj do i = 1 , ni call self % face_j ( i , j , k )% compute_metrics ( pt1 = node ( i - 1 , j , k - 1 )% vertex , & pt2 = node ( i - 1 , j , k )% vertex , & pt3 = node ( i , j , k )% vertex , & pt4 = node ( i , j , k - 1 )% vertex , signd = signj ) enddo enddo enddo do k = 0 , nk do j = 1 , nj do i = 1 , ni call self % face_k ( i , j , k )% compute_metrics ( pt1 = node ( i - 1 , j - 1 , k )% vertex , & pt2 = node ( i , j - 1 , k )% vertex , & pt3 = node ( i , j , k )% vertex , & pt4 = node ( i - 1 , j , k )% vertex , signd = signk ) enddo enddo enddo endassociate endsubroutine compute_faces_metrics","tags":"","loc":"proc/compute_faces_metrics.html","title":"compute_faces_metrics – OFF"},{"text":"private subroutine compute_metrics(self) Compute block metrics. Todo re-add elemental attribute. Todo re-add metrics correction call. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. Source Code compute_metrics Source Code subroutine compute_metrics ( self ) !< Compute block metrics. !< !< @TODO re-add elemental attribute. !< !< @TODO re-add metrics correction call. class ( block_object ), intent ( inout ) :: self !< Block. call self % compute_faces_metrics call self % compute_volumes ! call self%correct_metrics call self % nullify_normals endsubroutine compute_metrics","tags":"","loc":"proc/compute_metrics.html","title":"compute_metrics – OFF"},{"text":"private subroutine compute_space_operator(self) Compute space operator. Todo implement space operator. Todo re-add elemental attribute. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. Source Code compute_space_operator Source Code subroutine compute_space_operator ( self ) !, space_operator) !< Compute space operator. !< !< @TODO implement space operator. !< !< @TODO re-add elemental attribute. class ( block_object ), intent ( in ) :: self !< Block. ! class(conservative_object), intent(inout) :: space_operator(1:,1:,1:) !< Space operator. error stop 'error: block space operator to be implemented' endsubroutine compute_space_operator","tags":"","loc":"proc/compute_space_operator.html","title":"compute_space_operator – OFF"},{"text":"private elemental subroutine compute_volumes(self) Compute block volumes. The volume of each cell is computed using the formula:\n \n v = [(\\vec n_7 - \\vec n_1) + (\\vec n_6 - \\vec n_0), (\\vec n_7 - \\vec n_2), (\\vec n_3 - \\vec n_0)] +\n     [(\\vec n_6 - \\vec n_0), (\\vec n_7 - \\vec n_2) + (\\vec n_5 - \\vec n_0), (\\vec n_7 - \\vec n_4)] +\n     [(\\vec n_7 - \\vec n_1), (\\vec n_5 - \\vec n_0), (\\vec n_7 - \\vec n_4) + (\\vec n_3 - \\vec n_0)]\n \n where [\\vec A, \\vec B, \\vec C]=\\vec A \\cdot (\\vec B \\times \\vec C) is the triple product. References [1] Efficient computation of volume of hexahedral cells , Grandy J., 1997. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. Calls proc~~compute_volumes~~CallsGraph proc~compute_volumes compute_volumes node node proc~compute_volumes->node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_volumes Source Code elemental subroutine compute_volumes ( self ) !< Compute block volumes. !< !< The volume of each cell is computed using the formula: !<  !< v = [(\\vec n_7 - \\vec n_1) + (\\vec n_6 - \\vec n_0), (\\vec n_7 - \\vec n_2), (\\vec n_3 - \\vec n_0)] + !<     [(\\vec n_6 - \\vec n_0), (\\vec n_7 - \\vec n_2) + (\\vec n_5 - \\vec n_0), (\\vec n_7 - \\vec n_4)] + !<     [(\\vec n_7 - \\vec n_1), (\\vec n_5 - \\vec n_0), (\\vec n_7 - \\vec n_4) + (\\vec n_3 - \\vec n_0)] !<  !< where [\\vec A, \\vec B, \\vec C]=\\vec A \\cdot (\\vec B \\times \\vec C) is the triple product. !< !<### References !< !< [1] *Efficient computation of volume of hexahedral cells*, Grandy J., 1997. class ( block_object ), intent ( inout ) :: self !< Block. type ( vector ) :: triplet ( 1 : 9 ) !< Dummy vectors. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( node => self % node , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) do k = 1 , nk do j = 1 , nj do i = 1 , ni triplet ( 1 ) = node ( i , j , k )% vertex - node ( i , j - 1 , k - 1 )% vertex & + node ( i - 1 , j , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 2 ) = node ( i , j , k )% vertex - node ( i - 1 , j , k - 1 )% vertex triplet ( 3 ) = node ( i , j , k - 1 )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 4 ) = node ( i - 1 , j , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 5 ) = node ( i , j , k )% vertex - node ( i - 1 , j , k - 1 )% vertex & + node ( i , j - 1 , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 6 ) = node ( i , j , k )% vertex - node ( i - 1 , j - 1 , k )% vertex triplet ( 7 ) = node ( i , j , k )% vertex - node ( i , j - 1 , k - 1 )% vertex triplet ( 8 ) = node ( i , j - 1 , k )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex triplet ( 9 ) = node ( i , j , k )% vertex - node ( i - 1 , j - 1 , k )% vertex & + node ( i , j , k - 1 )% vertex - node ( i - 1 , j - 1 , k - 1 )% vertex self % cell ( i , j , k )% volume = (( triplet ( 1 ). dot .( triplet ( 2 ). cross . triplet ( 3 ))) + & ( triplet ( 4 ). dot .( triplet ( 5 ). cross . triplet ( 6 ))) + & ( triplet ( 7 ). dot .( triplet ( 8 ). cross . triplet ( 9 )))) / 1 2.0_R8P enddo enddo enddo endassociate endsubroutine compute_volumes","tags":"","loc":"proc/compute_volumes.html","title":"compute_volumes – OFF"},{"text":"private subroutine correct_metrics(self) Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Correct the metrics. Check for boundary conditions and volumes issues. Todo Implement correction.\n Block. Source Code correct_metrics Source Code subroutine correct_metrics ( self ) !> Correct the metrics. !< !< Check for boundary conditions and volumes issues. !< !< @TODO Implement correction. class ( block_object ), intent ( inout ) :: self !< Block. error stop 'error: block metrics correction to be implemented' endsubroutine correct_metrics","tags":"","loc":"proc/correct_metrics.html","title":"correct_metrics – OFF"},{"text":"private subroutine create_linspace(self, emin, emax) Create a Cartesian block with linearly spaced nodes. Note If the extents (emin, emax) of the block are not passed, the values already saved into the block are used. Todo re-add elemental attribute. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. Calls proc~~create_linspace~~CallsGraph proc~create_linspace create_linspace gc gc proc~create_linspace->gc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code create_linspace Source Code subroutine create_linspace ( self , emin , emax ) !< Create a Cartesian block with linearly spaced nodes. !< !< @note If the extents (emin, emax) of the block are not passed, the values already saved into the block are used. !< !< @TODO re-add elemental attribute. class ( block_object ), intent ( inout ) :: self !< Block. type ( vector ), intent ( in ), optional :: emin !< Coordinates of minimum abscissa of the block. type ( vector ), intent ( in ), optional :: emax !< Coordinates of maximum abscissa of the block. type ( vector ) :: delta !< Diagonal of block bounding-box. real ( R8P ) :: delta_x !< X component of diagonal of block bounding-box. real ( R8P ) :: delta_y !< Y component of diagonal of block bounding-box. real ( R8P ) :: delta_z !< Z component of diagonal of block bounding-box. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. self % error % status = ERROR_BLOCK_CREATE_LINSPACE_FAILED self % signature % is_cartesian = . true . if ( present ( emin )) self % signature % emin = emin if ( present ( emax )) self % signature % emax = emax associate ( gc => self % signature % gc , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) if ( self % signature % emin /= self % signature % emax ) then delta = ( self % signature % emax - self % signature % emin ) / ( ni * ex + nj * ey + nk * ez ) delta_x = delta . dot . ex delta_y = delta . dot . ey delta_z = delta . dot . ez do k = 0 - gc ( 5 ), nk + gc ( 6 ) do j = 0 - gc ( 3 ), nj + gc ( 4 ) do i = 0 - gc ( 1 ), ni + gc ( 2 ) self % node ( i , j , k )% vertex = self % signature % emin + ( i * delta_x ) * ex + ( j * delta_y ) * ey + ( k * delta_z ) * ez enddo enddo enddo call self % compute_metrics self % error % status = NO_ERROR endif endassociate endsubroutine create_linspace","tags":"","loc":"proc/create_linspace.html","title":"create_linspace – OFF"},{"text":"private elemental subroutine destroy(self) Destroy block. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy block. class ( block_object ), intent ( inout ) :: self !< Block. type ( block_object ) :: fresh !< Fresh instance of block object. self = fresh if ( allocated ( self % cell )) then call self % cell % destroy deallocate ( self % cell ) endif if ( allocated ( self % face_i )) then call self % face_i % destroy deallocate ( self % face_i ) endif if ( allocated ( self % face_j )) then call self % face_j % destroy deallocate ( self % face_j ) endif if ( allocated ( self % face_k )) then call self % face_k % destroy deallocate ( self % face_k ) endif if ( allocated ( self % node )) then call self % node % destroy deallocate ( self % node ) endif endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – OFF"},{"text":"private subroutine initialize(self, signature, id, level, gc, ni, nj, nk, emin, emax, is_cartesian, is_null_x, is_null_y, is_null_z) Initialize block. Assign block signature, allocate dynamic memory and set block features. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. type( block_signature_object ), intent(in), optional :: signature Signature, namely id, level, dimensions, etc… integer(kind=I8P), intent(in), optional :: id Unique (Morton) identification code. integer(kind=I4P), intent(in), optional :: level Grid refinement level. integer(kind=I4P), intent(in), optional :: gc (1:) Number of ghost cells along each frame. integer(kind=I4P), intent(in), optional :: ni Number of cells in I direction. integer(kind=I4P), intent(in), optional :: nj Number of cells in J direction. integer(kind=I4P), intent(in), optional :: nk Number of cells in K direction. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. logical, intent(in), optional :: is_cartesian Flag for checking if the block is Cartesian. logical, intent(in), optional :: is_null_x Nullify X direction (2D yz, 1D y or z domain). logical, intent(in), optional :: is_null_y Nullify Y direction (2D xy, 1D x or y domain). logical, intent(in), optional :: is_null_z Nullify Z direction (2D xy, 1D x or y domain). Calls proc~~initialize~~CallsGraph proc~initialize initialize gc_ gc_ proc~initialize->gc_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , signature , & id , level , gc , ni , nj , nk , & emin , emax , is_cartesian , is_null_x , is_null_y , is_null_z ) !< Initialize block. !< !< Assign block signature, allocate dynamic memory and set block features. class ( block_object ), intent ( inout ) :: self !< Block. type ( block_signature_object ), intent ( in ), optional :: signature !< Signature, namely id, level, dimensions, etc... integer ( I8P ), intent ( in ), optional :: id !< Unique (Morton) identification code. integer ( I4P ), intent ( in ), optional :: level !< Grid refinement level. integer ( I4P ), intent ( in ), optional :: gc ( 1 :) !< Number of ghost cells along each frame. integer ( I4P ), intent ( in ), optional :: ni !< Number of cells in I direction. integer ( I4P ), intent ( in ), optional :: nj !< Number of cells in J direction. integer ( I4P ), intent ( in ), optional :: nk !< Number of cells in K direction. type ( vector ), intent ( in ), optional :: emin !< Coordinates of minimum abscissa of the block. type ( vector ), intent ( in ), optional :: emax !< Coordinates of maximum abscissa of the block. logical , intent ( in ), optional :: is_cartesian !< Flag for checking if the block is Cartesian. logical , intent ( in ), optional :: is_null_x !< Nullify X direction (2D yz, 1D y or z domain). logical , intent ( in ), optional :: is_null_y !< Nullify Y direction (2D xy, 1D x or y domain). logical , intent ( in ), optional :: is_null_z !< Nullify Z direction (2D xy, 1D x or y domain). self % error % status = ERROR_BLOCK_CREATE_FAILED if ((. not .( present ( signature ))). and .& (. not .( present ( id ). and . present ( level ). and . present ( gc ). and . present ( ni ). and . present ( nj ). and . present ( nk )))) then error stop 'error: either signature or (id, level, gc, ni, nj, nk) tuple must be passed to a block initialized' endif call self % destroy call self % signature % initialize ( signature = signature , & id = id , level = level , gc = gc , ni = ni , nj = nj , nk = nk , & emin = emin , emax = emax , is_cartesian = is_cartesian , & is_null_x = is_null_x , is_null_y = is_null_y , is_null_z = is_null_z ) associate ( gc_ => self % signature % gc , ni_ => self % signature % ni , nj_ => self % signature % nj , nk_ => self % signature % nk ) allocate ( self % cell ( 1 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 1 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 1 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % face_i ( 0 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 1 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 1 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % face_j ( 1 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 0 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 1 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % face_k ( 1 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 1 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 0 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) allocate ( self % node ( 0 - gc_ ( 1 ) : ni_ + gc_ ( 2 ), 0 - gc_ ( 3 ) : nj_ + gc_ ( 4 ), 0 - gc_ ( 5 ) : nk_ + gc_ ( 6 ))) endassociate self % error % status = NO_ERROR endsubroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – OFF"},{"text":"private pure subroutine interpolate_at_nodes(self, var_cell, var_node) Interpolate cell-centered variable at nodes. Note The interpolation is linear and based on the volume-weights. Note Only internal cells are considered, ghost ones are trimmed. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. real(kind=R8P), intent(in) :: var_cell (1-self%signature%gc(1):,1-self%signature%gc(3):,1-self%signature%gc(5):) Cell-centered variable. real(kind=R8P), intent(out) :: var_node (0-self%signature%gc(1):,0-self%signature%gc(3):,0-self%signature%gc(5):) Node-centered variable. Calls proc~~interpolate_at_nodes~~CallsGraph proc~interpolate_at_nodes interpolate_at_nodes gc gc proc~interpolate_at_nodes->gc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpolate_at_nodes Source Code pure subroutine interpolate_at_nodes ( self , var_cell , var_node ) !< Interpolate cell-centered variable at nodes. !< !< @note The interpolation is linear and based on the volume-weights. !< !< @note Only internal cells are considered, ghost ones are trimmed. class ( block_object ), intent ( in ) :: self !< Block. real ( R8P ), intent ( in ) :: var_cell ( 1 - self % signature % gc ( 1 ):, & 1 - self % signature % gc ( 3 ):, & 1 - self % signature % gc ( 5 ):) !< Cell-centered variable. real ( R8P ), intent ( out ) :: var_node ( 0 - self % signature % gc ( 1 ):, & 0 - self % signature % gc ( 3 ):, & 0 - self % signature % gc ( 5 ):) !< Node-centered variable. real ( R8P ), allocatable :: var_cell_framed (:,:,:) !< Cell-centered var framed. real ( R8P ), allocatable :: volume_framed (:,:,:) !< Volume framed. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: k !< Counter. associate ( gc => self % signature % gc , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk ) ! building framed variable and volume allocate ( var_cell_framed ( 0 : ni + 1 , 0 : nj + 1 , 0 : nk + 1 )) ; var_cell_framed = 0._R8P var_cell_framed ( 1 : ni , 1 : nj , 1 : nk ) = var_cell ( 1 : ni , 1 : nj , 1 : nk ) allocate ( volume_framed ( 0 : ni + 1 , 0 : nj + 1 , 0 : nk + 1 )) ; volume_framed = 0._R8P volume_framed ( 1 : ni , 1 : nj , 1 : nk ) = self % cell ( 1 : ni , 1 : nj , 1 : nk )% volume ! check frames if ( gc ( 1 ) > 0 ) then var_cell_framed ( 0 , 1 : nj , 1 : nk ) = var_cell ( 0 , 1 : nj , 1 : nk ) volume_framed ( 0 , 1 : nj , 1 : nk ) = self % cell ( 0 , 1 : nj , 1 : nk )% volume endif if ( gc ( 2 ) > 0 ) then var_cell_framed ( ni + 1 , 1 : nj , 1 : nk ) = var_cell ( ni + 1 , 1 : nj , 1 : nk ) volume_framed ( ni + 1 , 1 : nj , 1 : nk ) = self % cell ( ni + 1 , 1 : nj , 1 : nk )% volume endif if ( gc ( 3 ) > 0 ) then var_cell_framed ( 1 : ni , 0 , 1 : nk ) = var_cell ( 1 : ni , 0 , 1 : nk ) volume_framed ( 1 : ni , 0 , 1 : nk ) = self % cell ( 1 : ni , 0 , 1 : nk )% volume endif if ( gc ( 4 ) > 0 ) then var_cell_framed ( ni , 1 : nj + 1 , 1 : nk ) = var_cell ( ni , 1 : nj + 1 , 1 : nk ) volume_framed ( ni , 1 : nj + 1 , 1 : nk ) = self % cell ( ni , 1 : nj + 1 , 1 : nk )% volume endif if ( gc ( 5 ) > 0 ) then var_cell_framed ( 1 : ni , 1 : nj , 0 ) = var_cell ( 1 : ni , 1 : nj , 0 ) volume_framed ( 1 : ni , 1 : nj , 0 ) = self % cell ( 1 : ni , 1 : nj , 0 )% volume endif if ( gc ( 6 ) > 0 ) then var_cell_framed ( ni , 1 : nj , 1 : nk + 1 ) = var_cell ( ni , 1 : nj , 1 : nk + 1 ) volume_framed ( ni , 1 : nj , 1 : nk + 1 ) = self % cell ( ni , 1 : nj , 1 : nk + 1 )% volume endif ! interpolate on nodes do k = 0 , nk do j = 0 , nj do i = 0 , ni var_node ( i , j , k ) = ( var_cell_framed ( i + 1 , j + 1 , k + 1 ) * volume_framed ( i + 1 , j + 1 , k + 1 ) & + var_cell_framed ( i , j + 1 , k + 1 ) * volume_framed ( i , j + 1 , k + 1 ) & + var_cell_framed ( i + 1 , j , k + 1 ) * volume_framed ( i + 1 , j , k + 1 ) & + var_cell_framed ( i , j , k + 1 ) * volume_framed ( i , j , k + 1 ) & + var_cell_framed ( i + 1 , j + 1 , k ) * volume_framed ( i + 1 , j + 1 , k ) & + var_cell_framed ( i , j + 1 , k ) * volume_framed ( i , j + 1 , k ) & + var_cell_framed ( i + 1 , j , k ) * volume_framed ( i + 1 , j , k ) & + var_cell_framed ( i , j , k ) * volume_framed ( i , j , k ))& / sum ( volume_framed ( i : i + 1 , j : j + 1 , k : k + 1 )) enddo enddo enddo endassociate endsubroutine interpolate_at_nodes","tags":"","loc":"proc/interpolate_at_nodes.html","title":"interpolate_at_nodes – OFF"},{"text":"private subroutine load_nodes_from_file(self, file_unit, pos) Load nodes from file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. integer(kind=I4P), intent(in) :: file_unit File unit. integer(kind=I4P), intent(in) :: pos Position to start the loading. Source Code load_nodes_from_file Source Code subroutine load_nodes_from_file ( self , file_unit , pos ) !< Load nodes from file. class ( block_object ), intent ( inout ) :: self !< Block. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ), intent ( in ) :: pos !< Position to start the loading. read ( file_unit , pos = pos , iostat = self % error % status ) self % node % vertex % x , self % node % vertex % y , self % node % vertex % z call self % compute_extents endsubroutine load_nodes_from_file","tags":"","loc":"proc/load_nodes_from_file.html","title":"load_nodes_from_file – OFF"},{"text":"private elemental subroutine nullify_normals(self) Nullify normals for 2D or 1D domains. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. Source Code nullify_normals Source Code elemental subroutine nullify_normals ( self ) !< Nullify normals for 2D or 1D domains. class ( block_object ), intent ( inout ) :: self !< Block. if ( self % signature % is_null_x ) then self % face_i % normal = ( self % face_i % normal . paral . ex ) + ( 0._R8P * ey ) + ( 0._R8P * ez ) self % face_j % normal = ( 0._R8P * ex ) + ( self % face_j % normal . paral . ey ) + ( self % face_j % normal . paral . ez ) self % face_k % normal = ( 0._R8P * ex ) + ( self % face_k % normal . paral . ey ) + ( self % face_k % normal . paral . ez ) endif if ( self % signature % is_null_y ) then self % face_i % normal = ( self % face_i % normal . paral . ex ) + ( 0._R8P * ey ) + ( self % face_i % normal . paral . ez ) self % face_j % normal = ( 0._R8P * ex ) + ( self % face_j % normal . paral . ey ) + ( 0._R8P * ez ) self % face_k % normal = ( self % face_k % normal . paral . ex ) + ( 0._R8P * ey ) + ( self % face_k % normal . paral . ez ) endif if ( self % signature % is_null_z ) then self % face_i % normal = ( self % face_i % normal . paral . ex ) + ( self % face_i % normal . paral . ey ) + ( 0._R8P * ez ) self % face_j % normal = ( self % face_j % normal . paral . ex ) + ( self % face_j % normal . paral . ey ) + ( 0._R8P * ez ) self % face_k % normal = ( 0._R8P * ex ) + ( 0._R8P * ey ) + ( self % face_k % normal . paral . ez ) endif endsubroutine nullify_normals","tags":"","loc":"proc/nullify_normals.html","title":"nullify_normals – OFF"},{"text":"private subroutine save_file_grid(self, file_name, ascii, metrics, tecplot, vtk) Save grid file file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name File name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. logical, intent(in), optional :: tecplot Tecplot output format sentinel. logical, intent(in), optional :: vtk VTK output format sentinel. Source Code save_file_grid Source Code subroutine save_file_grid ( self , file_name , ascii , metrics , tecplot , vtk ) !< Save grid file file. class ( block_object ), intent ( inout ) :: self !< Block. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. logical , intent ( in ), optional :: tecplot !< Tecplot output format sentinel. logical , intent ( in ), optional :: vtk !< VTK output format sentinel. logical :: tecplot_ !< Tecplot format sentinel, local variable. logical :: vtk_ !< VTK format sentinel, local variable. tecplot_ = . false . ; if ( present ( tecplot )) tecplot_ = tecplot vtk_ = . false . ; if ( present ( vtk )) vtk_ = vtk if ( vtk_ ) call self % save_file_grid_vtk ( file_name = file_name , ascii = ascii , metrics = metrics ) endsubroutine save_file_grid","tags":"","loc":"proc/save_file_grid.html","title":"save_file_grid – OFF"},{"text":"private subroutine save_file_grid_tec(self, file_name, ascii, metrics) Save grid file in Tecplot format. Todo implement Tecplot output. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name Output file name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. Source Code save_file_grid_tec Source Code subroutine save_file_grid_tec ( self , file_name , ascii , metrics ) !< Save grid file in Tecplot format. !< !< @TODO implement Tecplot output. class ( block_object ), intent ( inout ) :: self !< Block. character ( * ), intent ( in ) :: file_name !< Output file name. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. error stop 'error: block mesh Tecplot output to be implemented' endsubroutine save_file_grid_tec","tags":"","loc":"proc/save_file_grid_tec.html","title":"save_file_grid_tec – OFF"},{"text":"private subroutine save_file_grid_vtk(self, file_name, ascii, metrics) Save mesh data into VTK file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name Output file name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. Calls proc~~save_file_grid_vtk~~CallsGraph proc~save_file_grid_vtk save_file_grid_vtk node node proc~save_file_grid_vtk->node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_file_grid_vtk Source Code subroutine save_file_grid_vtk ( self , file_name , ascii , metrics ) !< Save mesh data into VTK file. class ( block_object ), intent ( inout ) :: self !< Block. character ( * ), intent ( in ) :: file_name !< Output file name. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. logical :: ascii_ !< Ascii/binary output. logical :: metrics_ !< Save also metrics data. type ( vtk_file ) :: vtk !< VTK file. ascii_ = . false . ; if ( present ( ascii )) ascii_ = ascii metrics_ = . false . ; if ( present ( metrics )) metrics_ = metrics associate ( node => self % node , ni => self % signature % ni , nj => self % signature % nj , nk => self % signature % nk , & nn => self % nodes_number ( with_ghosts = . false .)) if ( ascii_ ) then self % error % status = vtk % initialize ( format = 'ascii' , & filename = trim ( adjustl ( file_name )), mesh_topology = 'StructuredGrid' , & nx1 = 0 , nx2 = ni , ny1 = 0 , ny2 = nj , nz1 = 0 , nz2 = nk ) else self % error % status = vtk % initialize ( format = 'raw' , & filename = trim ( adjustl ( file_name )), mesh_topology = 'StructuredGrid' , & nx1 = 0 , nx2 = ni , ny1 = 0 , ny2 = nj , nz1 = 0 , nz2 = nk ) endif self % error % status = vtk % xml_writer % write_piece ( nx1 = 0 , nx2 = ni , ny1 = 0 , ny2 = nj , nz1 = 0 , nz2 = nk ) self % error % status = vtk % xml_writer % write_geo ( n = nn , x = node ( 0 : ni , 0 : nj , 0 : nk )% vertex % x , & y = node ( 0 : ni , 0 : nj , 0 : nk )% vertex % y , & z = node ( 0 : ni , 0 : nj , 0 : nk )% vertex % z ) if ( metrics_ ) then self % error % status = vtk % xml_writer % write_dataarray ( location = 'cell' , action = 'open' ) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'volume' , x = self % cell ( 1 : ni , 1 : nj , 1 : nk )% volume , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'area_i' , x = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% area , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'area_j' , x = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% area , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'area_k' , x = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% area , & one_component = . true .) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'normals_i' , x = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% normal % x , & y = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% normal % y , & z = self % face_i ( 1 : ni , 1 : nj , 1 : nk )% normal % z ) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'normals_j' , x = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% normal % x , & y = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% normal % y , & z = self % face_j ( 1 : ni , 1 : nj , 1 : nk )% normal % z ) self % error % status = vtk % xml_writer % write_dataarray ( data_name = 'normals_k' , x = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% normal % x , & y = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% normal % y , & z = self % face_k ( 1 : ni , 1 : nj , 1 : nk )% normal % z ) self % error % status = vtk % xml_writer % write_dataarray ( location = 'cell' , action = 'close' ) endif self % error % status = vtk % xml_writer % write_piece () self % error % status = vtk % finalize () endassociate endsubroutine save_file_grid_vtk","tags":"","loc":"proc/save_file_grid_vtk.html","title":"save_file_grid_vtk – OFF"},{"text":"private subroutine save_nodes_into_file(self, file_unit, pos) Save nodes into file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. integer(kind=I4P), intent(in) :: file_unit File unit. integer(kind=I4P), intent(in) :: pos Position to start the loading. Source Code save_nodes_into_file Source Code subroutine save_nodes_into_file ( self , file_unit , pos ) !< Save nodes into file. class ( block_object ), intent ( inout ) :: self !< Block. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ), intent ( in ) :: pos !< Position to start the loading. write ( file_unit , pos = pos , iostat = self % error % status ) self % node % vertex % x , self % node % vertex % y , self % node % vertex % z endsubroutine save_nodes_into_file","tags":"","loc":"proc/save_nodes_into_file.html","title":"save_nodes_into_file – OFF"},{"text":"private elemental function cells_number(self, with_ghosts) result(cells_number_) Return the number of cells. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. Source Code cells_number Source Code elemental function cells_number ( self , with_ghosts ) result ( cells_number_ ) !< Return the number of cells. class ( block_signature_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: cells_number_ !< Number of cells. logical :: with_ghosts_ !< Take into account ghost cells, local variable. with_ghosts_ = . true . ; if ( present ( with_ghosts )) with_ghosts_ = with_ghosts if ( with_ghosts_ ) then cells_number_ = ( self % ni + self % gc ( 1 ) + self % gc ( 2 )) & * ( self % nj + self % gc ( 3 ) + self % gc ( 4 )) & * ( self % nk + self % gc ( 5 ) + self % gc ( 6 )) else cells_number_ = ( self % ni ) & * ( self % nj ) & * ( self % nk ) endif endfunction cells_number","tags":"","loc":"proc/cells_number~2.html","title":"cells_number – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of the block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~~CallsGraph proc~description description str str proc~description->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the block signature. class ( block_signature_object ), intent ( in ) :: self !< Block signature object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'id           : ' // trim ( str ( self % id , no_sign = . true .)) // NL desc = desc // prefix_ // 'level        : ' // trim ( str ( self % level , no_sign = . true .)) // NL desc = desc // prefix_ // 'gc           : ' // trim ( str ( self % gc , no_sign = . true .)) // NL desc = desc // prefix_ // 'ni           : ' // trim ( str ( self % ni , no_sign = . true .)) // NL desc = desc // prefix_ // 'nj           : ' // trim ( str ( self % nj , no_sign = . true .)) // NL desc = desc // prefix_ // 'nk           : ' // trim ( str ( self % nk , no_sign = . true .)) // NL desc = desc // prefix_ // 'emin         : ' // trim ( str ([ self % emin % x , self % emin % y , self % emin % z ] )) // NL desc = desc // prefix_ // 'emax         : ' // trim ( str ([ self % emax % x , self % emax % y , self % emax % z ] )) // NL desc = desc // prefix_ // 'is cartesian : ' // trim ( str ( self % is_cartesian )) // NL desc = desc // prefix_ // 'is null X    : ' // trim ( str ( self % is_null_x )) // NL desc = desc // prefix_ // 'is null Y    : ' // trim ( str ( self % is_null_y )) // NL desc = desc // prefix_ // 'is null Z    : ' // trim ( str ( self % is_null_z )) endfunction description","tags":"","loc":"proc/description.html","title":"description – OFF"},{"text":"private function iolength(self) Return the IO length storage. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. Return Value integer(kind=I4P) IO length storage. Source Code iolength Source Code function iolength ( self ) !< Return the IO length storage. class ( block_signature_object ), intent ( in ) :: self !< Block signature object. integer ( I4P ) :: iolength !< IO length storage. inquire ( iolength = iolength ) self % id , & self % level , & self % gc , & self % ni , & self % nj , & self % nk , & self % emin % x , self % emin % y , self % emin % z , & self % emax % x , self % emax % y , self % emax % z , & self % is_cartesian , & self % is_null_x , self % is_null_y , self % is_null_z endfunction iolength","tags":"","loc":"proc/iolength.html","title":"iolength – OFF"},{"text":"private elemental function nodes_number(self, with_ghosts) result(nodes_number_) Return the number of nodes. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of nodes. Source Code nodes_number Source Code elemental function nodes_number ( self , with_ghosts ) result ( nodes_number_ ) !< Return the number of nodes. class ( block_signature_object ), intent ( in ) :: self !< Block. logical , intent ( in ), optional :: with_ghosts !< Take into account ghost cells. integer ( I4P ) :: nodes_number_ !< Number of nodes. logical :: with_ghosts_ !< Take into account ghost cells, local variable. with_ghosts_ = . true . ; if ( present ( with_ghosts )) with_ghosts_ = with_ghosts if ( with_ghosts_ ) then nodes_number_ = ( self % ni + self % gc ( 1 ) + self % gc ( 2 ) + 1 ) & * ( self % nj + self % gc ( 3 ) + self % gc ( 4 ) + 1 ) & * ( self % nk + self % gc ( 5 ) + self % gc ( 6 ) + 1 ) else nodes_number_ = ( self % ni + 1 ) & * ( self % nj + 1 ) & * ( self % nk + 1 ) endif endfunction nodes_number","tags":"","loc":"proc/nodes_number~2.html","title":"nodes_number – OFF"},{"text":"private pure subroutine block_d_assign_block_d(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: lhs Left hand side. type( block_signature_object ), intent(in) :: rhs Right hand side. Source Code block_d_assign_block_d Source Code pure subroutine block_d_assign_block_d ( lhs , rhs ) !< Operator `=`. class ( block_signature_object ), intent ( inout ) :: lhs !< Left hand side. type ( block_signature_object ), intent ( in ) :: rhs !< Right hand side. lhs % id = rhs % id lhs % level = rhs % level lhs % gc = rhs % gc lhs % ni = rhs % ni lhs % nj = rhs % nj lhs % nk = rhs % nk lhs % emin = rhs % emin lhs % emax = rhs % emax lhs % is_cartesian = rhs % is_cartesian lhs % is_null_x = rhs % is_null_x lhs % is_null_y = rhs % is_null_y lhs % is_null_z = rhs % is_null_z endsubroutine block_d_assign_block_d","tags":"","loc":"proc/block_d_assign_block_d.html","title":"block_d_assign_block_d – OFF"},{"text":"private elemental subroutine destroy(self) Destroy block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy block signature. class ( block_signature_object ), intent ( inout ) :: self !< Block signature object. type ( block_signature_object ) :: fresh !< Fresh instance of block signature object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – OFF"},{"text":"private pure subroutine initialize(self, signature, id, level, gc, ni, nj, nk, emin, emax, is_cartesian, is_null_x, is_null_y, is_null_z) Initialize block signature. Note If both whole signature and single components like id, level, gc... are passed, the values of signature%id, signature%level, ... are overridden. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. type( block_signature_object ), intent(in), optional :: signature Block signature input. integer(kind=I8P), intent(in), optional :: id Unique (Morton) identification code. integer(kind=I4P), intent(in), optional :: level Grid refinement level. integer(kind=I4P), intent(in), optional :: gc (1:) Number of ghost cells along each frame. integer(kind=I4P), intent(in), optional :: ni Number of cells in I direction. integer(kind=I4P), intent(in), optional :: nj Number of cells in J direction. integer(kind=I4P), intent(in), optional :: nk Number of cells in K direction. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. logical, intent(in), optional :: is_cartesian Flag for checking if the block is Cartesian. logical, intent(in), optional :: is_null_x Nullify X direction (2D yz, 1D y or z domain). logical, intent(in), optional :: is_null_y Nullify Y direction (2D xy, 1D x or y domain). logical, intent(in), optional :: is_null_z Nullify Z direction (2D xy, 1D x or y domain). Source Code initialize Source Code pure subroutine initialize ( self , signature , & id , level , gc , ni , nj , nk , & emin , emax , is_cartesian , is_null_x , is_null_y , is_null_z ) !< Initialize block signature. !< !< @note If both whole `signature` and single components like `id, level, gc...` are passed, the values of !< `signature%id, signature%level, ...` are overridden. class ( block_signature_object ), intent ( inout ) :: self !< Block signature object. type ( block_signature_object ), intent ( in ), optional :: signature !< Block signature input. integer ( I8P ), intent ( in ), optional :: id !< Unique (Morton) identification code. integer ( I4P ), intent ( in ), optional :: level !< Grid refinement level. integer ( I4P ), intent ( in ), optional :: gc ( 1 :) !< Number of ghost cells along each frame. integer ( I4P ), intent ( in ), optional :: ni !< Number of cells in I direction. integer ( I4P ), intent ( in ), optional :: nj !< Number of cells in J direction. integer ( I4P ), intent ( in ), optional :: nk !< Number of cells in K direction. type ( vector ), intent ( in ), optional :: emin !< Coordinates of minimum abscissa of the block. type ( vector ), intent ( in ), optional :: emax !< Coordinates of maximum abscissa of the block. logical , intent ( in ), optional :: is_cartesian !< Flag for checking if the block is Cartesian. logical , intent ( in ), optional :: is_null_x !< Nullify X direction (2D yz, 1D y or z domain). logical , intent ( in ), optional :: is_null_y !< Nullify Y direction (2D xy, 1D x or y domain). logical , intent ( in ), optional :: is_null_z !< Nullify Z direction (2D xy, 1D x or y domain). call self % destroy if ( present ( signature )) self = signature if ( present ( id )) self % id = id if ( present ( level )) self % level = level if ( present ( gc )) self % gc = gc if ( present ( ni )) self % ni = ni if ( present ( nj )) self % nj = nj if ( present ( nk )) self % nk = nk if ( present ( emin )) self % emin = emin if ( present ( emax )) self % emax = emax if ( present ( is_cartesian )) self % is_cartesian = is_cartesian if ( present ( is_null_x )) self % is_null_x = is_null_x if ( present ( is_null_y )) self % is_null_y = is_null_y if ( present ( is_null_z )) self % is_null_z = is_null_z endsubroutine initialize","tags":"","loc":"proc/initialize~2.html","title":"initialize – OFF"},{"text":"private subroutine load_from_file(self, file_unit) Load block signature from file. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code load_from_file Source Code subroutine load_from_file ( self , file_unit ) !< Load block signature from file. class ( block_signature_object ), intent ( inout ) :: self !< Block signature object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. read ( unit = file_unit ) self % id , & self % level , & self % gc , & self % ni , & self % nj , & self % nk , & self % emin % x , self % emin % y , self % emin % z , & self % emax % x , self % emax % y , self % emax % z , & self % is_cartesian , & self % is_null_x , self % is_null_y , self % is_null_z endsubroutine load_from_file","tags":"","loc":"proc/load_from_file.html","title":"load_from_file – OFF"},{"text":"private subroutine save_into_file(self, file_unit) Load the block signature of all blocks from file. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code save_into_file Source Code subroutine save_into_file ( self , file_unit ) !< Load the block signature of all blocks from file. class ( block_signature_object ), intent ( in ) :: self !< Block signature object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. write ( unit = file_unit ) self % id , & self % level , & self % gc , & self % ni , & self % nj , & self % nk , & self % emin % x , self % emin % y , self % emin % z , & self % emax % x , self % emax % y , self % emax % z , & self % is_cartesian , & self % is_null_x , self % is_null_y , self % is_null_z endsubroutine save_into_file","tags":"","loc":"proc/save_into_file.html","title":"save_into_file – OFF"},{"text":"private pure subroutine cell_assign_cell(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: lhs Left hand side. type( cell_object ), intent(in) :: rhs Right hand side. Source Code cell_assign_cell Source Code pure subroutine cell_assign_cell ( lhs , rhs ) !< Operator `=`. class ( cell_object ), intent ( inout ) :: lhs !< Left hand side. type ( cell_object ), intent ( in ) :: rhs !< Right hand side. lhs % center = rhs % center lhs % volume = rhs % volume endsubroutine cell_assign_cell","tags":"","loc":"proc/cell_assign_cell.html","title":"cell_assign_cell – OFF"},{"text":"private elemental subroutine destroy(self) Destroy cell. Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: self Cell object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy cell. class ( cell_object ), intent ( inout ) :: self !< Cell object. type ( cell_object ) :: fresh !< Fresh instance of cell object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – OFF"},{"text":"private elemental subroutine initialize(self) Initialize cell. Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: self Cell object. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize cell. class ( cell_object ), intent ( inout ) :: self !< Cell object. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~3.html","title":"initialize – OFF"},{"text":"private subroutine check(self, message, is_severe) Check error status. If errors occurred, a warn is printed. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. character(len=*), intent(in), optional :: message Error message. logical, intent(in), optional :: is_severe Enable severe error. Calls proc~~check~~CallsGraph proc~check check str str proc~check->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check Source Code subroutine check ( self , message , is_severe ) !< Check error status. !< !< If errors occurred, a warn is printed. class ( error_object ), intent ( inout ) :: self !< Error object. character ( * ), intent ( in ), optional :: message !< Error message. logical , intent ( in ), optional :: is_severe !< Enable severe error. logical :: is_severe_ !< Enable severe error, local variable. if ( self % status /= 0 ) then is_severe_ = . false . ; if ( present ( is_severe )) is_severe_ = is_severe if ( present ( message )) then self % message = 'error [' // trim ( str ( self % status )) // ']: ' // message else self % message = 'error [' // trim ( str ( self % status )) // ']' endif write ( stderr , '(A)' ) self % message if ( is_severe_ ) stop endif endsubroutine check","tags":"","loc":"proc/check.html","title":"check – OFF"},{"text":"private elemental subroutine destroy(self) Destroy error. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy error. class ( error_object ), intent ( inout ) :: self !< Error object. type ( error_object ) :: fresh !< Fresh instance of error object. self = fresh if ( allocated ( self % message )) deallocate ( self % message ) endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – OFF"},{"text":"private pure subroutine err_assign_err(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: lhs Left hand side. type( error_object ), intent(in) :: rhs Right hand side. Source Code err_assign_err Source Code pure subroutine err_assign_err ( lhs , rhs ) !< Operator `=`. class ( error_object ), intent ( inout ) :: lhs !< Left hand side. type ( error_object ), intent ( in ) :: rhs !< Right hand side. lhs % status = rhs % status if ( allocated ( rhs % message )) lhs % message = rhs % message endsubroutine err_assign_err","tags":"","loc":"proc/err_assign_err.html","title":"err_assign_err – OFF"},{"text":"private elemental subroutine initialize(self) Initialize error. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize error. class ( error_object ), intent ( inout ) :: self !< Error object. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~4.html","title":"initialize – OFF"},{"text":"private elemental subroutine compute_metrics(self, pt1, pt2, pt3, pt4, signd) Compute face metrics. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face. type(vector), intent(in) :: pt1 Point 1 of face. type(vector), intent(in) :: pt2 Point 2 of face. type(vector), intent(in) :: pt3 Point 3 of face. type(vector), intent(in) :: pt4 Point 4 of face. real(kind=R8P), intent(in) :: signd Sign of direction along normal coordinate. Source Code compute_metrics Source Code elemental subroutine compute_metrics ( self , pt1 , pt2 , pt3 , pt4 , signd ) !< Compute face metrics. class ( face_object ), intent ( inout ) :: self !< Face. type ( vector ), intent ( in ) :: pt1 !< Point 1 of face. type ( vector ), intent ( in ) :: pt2 !< Point 2 of face. type ( vector ), intent ( in ) :: pt3 !< Point 3 of face. type ( vector ), intent ( in ) :: pt4 !< Point 4 of face. real ( R8P ), intent ( in ) :: signd !< Sign of direction along normal coordinate. self % normal = self % normal % face_normal4 ( pt1 = pt1 , pt2 = pt2 , pt3 = pt3 , pt4 = pt4 ) * signd self % area = self % normal % normL2 () call self % normal % normalize endsubroutine compute_metrics","tags":"","loc":"proc/compute_metrics~2.html","title":"compute_metrics – OFF"},{"text":"private elemental subroutine destroy(self) Destroy face. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy face. class ( face_object ), intent ( inout ) :: self !< Face object. type ( face_object ) :: fresh !< Fresh instance of face object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – OFF"},{"text":"private pure subroutine face_assign_face(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: lhs Left hand side. type( face_object ), intent(in) :: rhs Right hand side. Source Code face_assign_face Source Code pure subroutine face_assign_face ( lhs , rhs ) !< Operator `=`. class ( face_object ), intent ( inout ) :: lhs !< Left hand side. type ( face_object ), intent ( in ) :: rhs !< Right hand side. lhs % area = rhs % area lhs % normal = rhs % normal endsubroutine face_assign_face","tags":"","loc":"proc/face_assign_face.html","title":"face_assign_face – OFF"},{"text":"private pure subroutine initialize(self) Initialize face. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face object. Source Code initialize Source Code pure subroutine initialize ( self ) !< Initialize face. class ( face_object ), intent ( inout ) :: self !< Face object. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~5.html","title":"initialize – OFF"},{"text":"private subroutine load_grid_dimensions_from_file(self, grid_dimensions, file_name) Load the grid dimensions of all blocks from file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(inout) :: grid_dimensions Grid dimensions off all blocks into file. character(len=*), intent(in), optional :: file_name File name. Source Code load_grid_dimensions_from_file Source Code subroutine load_grid_dimensions_from_file ( self , grid_dimensions , file_name ) !< Load the grid dimensions of all blocks from file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( inout ) :: grid_dimensions !< Grid dimensions off all blocks into file. character ( * ), intent ( in ), optional :: file_name !< File name. call self % open ( file_name = file_name , action = 'read' ) call grid_dimensions % load_from_file ( file_unit = self % file_unit ) call self % close endsubroutine load_grid_dimensions_from_file","tags":"","loc":"proc/load_grid_dimensions_from_file.html","title":"load_grid_dimensions_from_file – OFF"},{"text":"private subroutine load_nodes_from_file(self, grid_dimensions, blocks, file_name) Load nodes coordinates from file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. type( block_object ), intent(inout) :: blocks (1:) Blocks storage. character(len=*), intent(in), optional :: file_name File name. Source Code load_nodes_from_file Source Code subroutine load_nodes_from_file ( self , grid_dimensions , blocks , file_name ) !< Load nodes coordinates from file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( in ) :: grid_dimensions !< Grid dimensions off all blocks into file. type ( block_object ), intent ( inout ) :: blocks ( 1 :) !< Blocks storage. character ( * ), intent ( in ), optional :: file_name !< File name. integer ( I4P ) :: b !< Counter. call self % open ( file_name = file_name , action = 'read' ) do b = 1 , size ( blocks , dim = 1 ) call blocks ( b )% load_nodes_from_file ( file_unit = self % file_unit , pos = grid_dimensions % iopos_block_nodes ( b = b )) enddo call self % close endsubroutine load_nodes_from_file","tags":"","loc":"proc/load_nodes_from_file~2.html","title":"load_nodes_from_file – OFF"},{"text":"private subroutine save_grid_dimensions_into_file(self, grid_dimensions) Load the grid dimensions of all blocks into file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. Source Code save_grid_dimensions_into_file Source Code subroutine save_grid_dimensions_into_file ( self , grid_dimensions ) !< Load the grid dimensions of all blocks into file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( in ) :: grid_dimensions !< Grid dimensions off all blocks into file. call self % open ( action = 'write' ) call grid_dimensions % save_into_file ( file_unit = self % file_unit ) call self % close endsubroutine save_grid_dimensions_into_file","tags":"","loc":"proc/save_grid_dimensions_into_file.html","title":"save_grid_dimensions_into_file – OFF"},{"text":"private subroutine save_nodes_into_file(self, grid_dimensions, blocks) Save nodes coordinates into file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. type( block_object ), intent(inout) :: blocks (1:) Blocks storage. Source Code save_nodes_into_file Source Code subroutine save_nodes_into_file ( self , grid_dimensions , blocks ) !< Save nodes coordinates into file. class ( file_grid_object ), intent ( inout ) :: self !< File object. type ( grid_dimensions_object ), intent ( in ) :: grid_dimensions !< Grid dimensions off all blocks into file. type ( block_object ), intent ( inout ) :: blocks ( 1 :) !< Blocks storage. integer ( I4P ) :: b !< Counter. call self % open ( action = 'write' ) do b = 1 , size ( blocks , dim = 1 ) call blocks ( b )% save_nodes_into_file ( file_unit = self % file_unit , pos = grid_dimensions % iopos_block_nodes ( b = b )) enddo call self % close endsubroutine save_nodes_into_file","tags":"","loc":"proc/save_nodes_into_file~2.html","title":"save_nodes_into_file – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of the file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(in) :: self Files collection. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the file. class ( file_object ), intent ( in ) :: self !< Files collection. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' if ( allocated ( self % file_name )) desc = desc // prefix_ // 'File name: ' // self % file_name endfunction description","tags":"","loc":"proc/description~2.html","title":"description – OFF"},{"text":"private subroutine close(self) Close file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. Source Code close Source Code subroutine close ( self ) !< Close file. class ( file_object ), intent ( inout ) :: self !< File object. if ( self % is_initialized ) then if ( self % is_connected ) then close ( unit = self % file_unit ) self % file_unit = 0 self % is_connected = . false . else write ( stderr , '(A)' ) 'error: file \"' // self % file_name // '\" is not connected, thus its unit cannot be closed' self % error % status = ERROR_NOT_CONNECTED endif else write ( stderr , '(A)' ) 'error: file is not initialized, thus its unit cannot be closed' self % error % status = ERROR_NOT_INITIALIZED endif endsubroutine close","tags":"","loc":"proc/close.html","title":"close – OFF"},{"text":"private elemental subroutine destroy(self) Destroy file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy file. class ( file_object ), intent ( inout ) :: self !< File object. type ( file_object ) :: fresh !< Fresh instance of file object. self = fresh if ( allocated ( self % file_name )) deallocate ( self % file_name ) endsubroutine destroy","tags":"","loc":"proc/destroy~6.html","title":"destroy – OFF"},{"text":"private pure subroutine file_assign_file(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: lhs Left hand side. type( file_object ), intent(in) :: rhs Right hand side. Source Code file_assign_file Source Code pure subroutine file_assign_file ( lhs , rhs ) !< Operator `=`. class ( file_object ), intent ( inout ) :: lhs !< Left hand side. type ( file_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error if ( allocated ( rhs % file_name )) lhs % file_name = rhs % file_name lhs % file_unit = rhs % file_unit lhs % is_initialized = rhs % is_initialized lhs % is_connected = rhs % is_connected endsubroutine file_assign_file","tags":"","loc":"proc/file_assign_file.html","title":"file_assign_file – OFF"},{"text":"private elemental subroutine initialize(self, file_name) Initialize File. Note Leading and trailing white spaces are removed from file name. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. Source Code initialize Source Code elemental subroutine initialize ( self , file_name ) !< Initialize File. !< !< @note Leading and trailing white spaces are removed from file name. class ( file_object ), intent ( inout ) :: self !< File object. character ( len =* ), intent ( in ), optional :: file_name !< File name. call self % destroy call self % error % initialize if ( present ( file_name )) then self % file_name = trim ( adjustl ( file_name )) else self % file_name = UNSET_FILE_NAME endif self % is_initialized = . true . endsubroutine initialize","tags":"","loc":"proc/initialize~6.html","title":"initialize – OFF"},{"text":"private subroutine load_file_name_from_file(self, fini, section_name, option_name, go_on_fail) Load file name from file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file. logical, intent(in), optional :: go_on_fail Go on if load fails. Source Code load_file_name_from_file Source Code subroutine load_file_name_from_file ( self , fini , section_name , option_name , go_on_fail ) !< Load file name from file. class ( file_object ), intent ( inout ) :: self !< File object. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. character ( * ), intent ( in ) :: section_name !< Option name into the ini file. character ( * ), intent ( in ) :: option_name !< Option name into the ini file. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. character ( 999 ) :: buffer !< Buffer string. call fini % get ( section_name = section_name , option_name = option_name , val = buffer , error = self % error % status ) if ( present ( go_on_fail )) then if (. not . go_on_fail ) & call self % error % check ( message = 'failed to load [' // section_name // '].(' // option_name // ')' , is_severe = . not . go_on_fail ) endif if ( self % error % status <= 0 ) self % file_name = trim ( adjustl ( buffer )) endsubroutine load_file_name_from_file","tags":"","loc":"proc/load_file_name_from_file.html","title":"load_file_name_from_file – OFF"},{"text":"private subroutine open(self, file_name, format, action, access) Open file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: format File format. character(len=*), intent(in), optional :: action File action. character(len=*), intent(in), optional :: access File access. Source Code open Source Code subroutine open ( self , file_name , format , action , access ) !< Open file. class ( file_object ), intent ( inout ) :: self !< File object. character ( len =* ), intent ( in ), optional :: file_name !< File name. character ( len =* ), intent ( in ), optional :: format !< File format. character ( len =* ), intent ( in ), optional :: action !< File action. character ( len =* ), intent ( in ), optional :: access !< File access. character ( len = :), allocatable :: file_name_ !< File name, local variable. character ( len = :), allocatable :: format_ !< File format, local variable. character ( len = :), allocatable :: action_ !< File action, local variable. character ( len = :), allocatable :: access_ !< File access, local variable. format_ = 'unformatted' ; if ( present ( format )) format_ = format action_ = 'readwrite' ; if ( present ( action )) action_ = action access_ = 'stream' ; if ( present ( access )) access_ = access if ( self % is_initialized ) then file_name_ = self % file_name ; if ( present ( file_name )) file_name_ = trim ( adjustl ( file_name )) if (. not . self % is_connected ) then open ( newunit = self % file_unit , file = file_name_ , form = format_ , action = action_ , access = access_ ) self % is_connected = . true . else write ( stderr , '(A)' ) 'error: file \"' // self % file_name // '\" is already connected, thus its unit cannot be re-open' self % error % status = ERROR_ALREADY_CONNECTED endif else write ( stderr , '(A)' ) 'error: file is not initialized, thus it cannot be open' self % error % status = ERROR_NOT_INITIALIZED endif endsubroutine open","tags":"","loc":"proc/open.html","title":"open – OFF"},{"text":"private subroutine save_file_name_into_file(self, fini, section_name, option_name) Save file name into file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file. Source Code save_file_name_into_file Source Code subroutine save_file_name_into_file ( self , fini , section_name , option_name ) !< Save file name into file. class ( file_object ), intent ( inout ) :: self !< File object. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. character ( * ), intent ( in ) :: section_name !< Option name into the ini file. character ( * ), intent ( in ) :: option_name !< Option name into the ini file. call fini % add ( section_name = section_name , option_name = option_name , val = self % file_name , error = self % error % status ) endsubroutine save_file_name_into_file","tags":"","loc":"proc/save_file_name_into_file.html","title":"save_file_name_into_file – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of the files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(in) :: self Files collection. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the files collection. class ( files_collection_object ), intent ( in ) :: self !< Files collection. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix // 'Boundary conditions file:' // NL desc = desc // prefix // self % boundary_conditions % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Grid file:' // NL desc = desc // prefix // self % grid % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Initial conditions file:' // NL desc = desc // prefix // self % initial_conditions % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Logging file:' // NL desc = desc // prefix // self % logging % description ( prefix = '  ' ) // NL desc = desc // prefix // 'Solution file:' // NL desc = desc // prefix // self % solution % description ( prefix = '  ' ) endfunction description","tags":"","loc":"proc/description~3.html","title":"description – OFF"},{"text":"private elemental subroutine destroy(self) Destroy files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy files collection. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. call self % boundary_conditions % destroy call self % grid % destroy call self % initial_conditions % destroy call self % logging % destroy call self % solution % destroy endsubroutine destroy","tags":"","loc":"proc/destroy~7.html","title":"destroy – OFF"},{"text":"private elemental subroutine initialize(self) Initialize Files collection. Todo Complete this. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize Files collection. !< !< @TODO Complete this. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. call self % destroy call self % boundary_conditions % initialize call self % grid % initialize call self % initial_conditions % initialize call self % logging % initialize call self % solution % initialize endsubroutine initialize","tags":"","loc":"proc/initialize~7.html","title":"initialize – OFF"},{"text":"private subroutine load_from_file(self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails.. Source Code load_from_file Source Code subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails.. call self % boundary_conditions % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'boundary_conditions' , & go_on_fail = go_on_fail ) call self % grid % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'grid' , & go_on_fail = go_on_fail ) call self % initial_conditions % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'initial_conditions' , & go_on_fail = go_on_fail ) call self % logging % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'log' , & go_on_fail = go_on_fail ) call self % solution % load_file_name_from_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'solution' , & go_on_fail = go_on_fail ) endsubroutine load_from_file","tags":"","loc":"proc/load_from_file~2.html","title":"load_from_file – OFF"},{"text":"private subroutine save_into_file(self, fini) Save from file. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code save_into_file Source Code subroutine save_into_file ( self , fini ) !< Save from file. class ( files_collection_object ), intent ( inout ) :: self !< Files collection. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call self % boundary_conditions % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'boundary_conditions' ) call self % grid % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'grid' ) call self % initial_conditions % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'initial_conditions' ) call self % logging % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'log' ) call self % solution % save_file_name_into_file ( fini = fini , & section_name = INI_SECTION_NAME , & option_name = 'solution' ) endsubroutine save_into_file","tags":"","loc":"proc/save_into_file~2.html","title":"save_into_file – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of the free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(in) :: self Free conditions. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~4~~CallsGraph proc~description~4 description str str proc~description~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the free conditions. class ( free_conditions_object ), intent ( in ) :: self !< Free conditions. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'velocity : ' // trim ( str ([ self % velocity % x , self % velocity % y , self % velocity % z ])) endfunction description","tags":"","loc":"proc/description~4.html","title":"description – OFF"},{"text":"private elemental subroutine destroy(self) Destroy free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy free conditions. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. type ( free_conditions_object ) :: fresh !< Fresh free conditions. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~8.html","title":"destroy – OFF"},{"text":"private pure subroutine free_assign_free(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: lhs Left hand side. type( free_conditions_object ), intent(in) :: rhs Right hand side. Source Code free_assign_free Source Code pure subroutine free_assign_free ( lhs , rhs ) !< Operator `=`. class ( free_conditions_object ), intent ( inout ) :: lhs !< Left hand side. type ( free_conditions_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % velocity = rhs % velocity endsubroutine free_assign_free","tags":"","loc":"proc/free_assign_free.html","title":"free_assign_free – OFF"},{"text":"private elemental subroutine initialize(self) Initialize free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize free conditions. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~8.html","title":"initialize – OFF"},{"text":"private subroutine load_from_file(self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. Source Code load_from_file Source Code subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. real ( R8P ) :: velocity ( 1 : 3 ) !< Velocity loading buffer. call fini % get ( section_name = INI_SECTION_NAME , option_name = 'velocity' , val = velocity , error = self % error % status ) if ( present ( go_on_fail )) then if (. not . go_on_fail ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(velocity)' , is_severe = . not . go_on_fail ) endif if ( self % error % status <= 0 ) self % velocity = ex * velocity ( 1 ) + ey * velocity ( 2 ) + ez * velocity ( 3 ) endsubroutine load_from_file","tags":"","loc":"proc/load_from_file~3.html","title":"load_from_file – OFF"},{"text":"private subroutine save_into_file(self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code save_into_file Source Code subroutine save_into_file ( self , fini ) !< Save into file. class ( free_conditions_object ), intent ( inout ) :: self !< Free conditions. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'velocity' , val = [ self % velocity % x , self % velocity % y , self % velocity % z ], & error = self % error % status ) endsubroutine save_into_file","tags":"","loc":"proc/save_into_file~3.html","title":"save_into_file – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of the grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the grid dimensions. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. integer ( I4P ) :: b !< Counter. desc = '' if ( self % blocks_number > 0 ) then do b = 1 , self % blocks_number - 1 desc = desc // self % block_signature ( b )% description ( prefix = prefix ) // NL // NL enddo desc = desc // self % block_signature ( self % blocks_number )% description ( prefix = prefix ) endif endfunction description","tags":"","loc":"proc/description~5.html","title":"description – OFF"},{"text":"private function iolength(self) Return the IO length storage. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. Return Value integer(kind=I4P) IO length storage. Source Code iolength Source Code function iolength ( self ) !< Return the IO length storage. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. integer ( I4P ) :: iolength !< IO length storage. inquire ( iolength = iolength ) self % blocks_number if ( self % blocks_number > 0 ) iolength = iolength + self % blocks_number * self % block_signature ( 1 )% iolength () endfunction iolength","tags":"","loc":"proc/iolength~2.html","title":"iolength – OFF"},{"text":"private function iopos_block_nodes(self, b) Return the IO position where nodes of block b-th are stored. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: b Block index. Return Value integer(kind=I4P) IO position where nodes of block b-th are stored. Source Code iopos_block_nodes Source Code function iopos_block_nodes ( self , b ) !< Return the IO position where nodes of block b-th are stored. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. integer ( I4P ), intent ( in ) :: b !< Block index. integer ( I4P ) :: iopos_block_nodes !< IO position where nodes of block b-th are stored. type ( vector ) :: node !< A node coordinate prototype. integer ( I4P ) :: node_iolength !< Node IO length storage. integer ( I4P ) :: bb !< Counter. inquire ( iolength = node_iolength ) node % x , node % y , node % z iopos_block_nodes = self % iolength () ! file header length if ( self % blocks_number > 0 ) then if ( b > 1. and . b <= self % blocks_number ) then ! b-th block, there are the file header and [1:b-1] blocks before its nodes do bb = 1 , b - 1 iopos_block_nodes = iopos_block_nodes + self % block_signature ( bb )% nodes_number () * node_iolength enddo iopos_block_nodes = iopos_block_nodes + 1 else ! first block, there is only the file header before its nodes iopos_block_nodes = iopos_block_nodes + 1 endif endif endfunction iopos_block_nodes","tags":"","loc":"proc/iopos_block_nodes.html","title":"iopos_block_nodes – OFF"},{"text":"private elemental subroutine destroy(self) Destroy grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy grid dimensions. class ( grid_dimensions_object ), intent ( inout ) :: self !< Grid dimensions object. type ( grid_dimensions_object ) :: fresh !< Fresh instance of grid dimensions object. self = fresh if ( allocated ( self % block_signature )) then call self % block_signature % destroy deallocate ( self % block_signature ) endif endsubroutine destroy","tags":"","loc":"proc/destroy~9.html","title":"destroy – OFF"},{"text":"private pure subroutine grid_d_assign_grid_d(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: lhs Left hand side. type( grid_dimensions_object ), intent(in) :: rhs Right hand side. Source Code grid_d_assign_grid_d Source Code pure subroutine grid_d_assign_grid_d ( lhs , rhs ) !< Operator `=`. class ( grid_dimensions_object ), intent ( inout ) :: lhs !< Left hand side. type ( grid_dimensions_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % block_signature )) then call lhs % destroy lhs % blocks_number = rhs % blocks_number allocate ( lhs % block_signature , source = rhs % block_signature ) endif endsubroutine grid_d_assign_grid_d","tags":"","loc":"proc/grid_d_assign_grid_d.html","title":"grid_d_assign_grid_d – OFF"},{"text":"private pure subroutine initialize(self, block_signature) Initialize grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. type( block_signature_object ), intent(in), optional :: block_signature (1:) Dimensions of each block. Source Code initialize Source Code pure subroutine initialize ( self , block_signature ) !< Initialize grid dimensions. class ( grid_dimensions_object ), intent ( inout ) :: self !< Grid dimensions object. type ( block_signature_object ), intent ( in ), optional :: block_signature ( 1 :) !< Dimensions of each block. call self % destroy if ( present ( block_signature )) then self % blocks_number = size ( block_signature , dim = 1 ) allocate ( self % block_signature ( 1 : self % blocks_number ), source = block_signature ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~9.html","title":"initialize – OFF"},{"text":"private subroutine load_from_file(self, file_unit) Load grid dimensions from file. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code load_from_file Source Code subroutine load_from_file ( self , file_unit ) !< Load grid dimensions from file. class ( grid_dimensions_object ), intent ( inout ) :: self !< Grid dimensions object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ) :: b !< Counter. call self % destroy read ( unit = file_unit ) self % blocks_number if ( self % blocks_number > 0 ) then allocate ( self % block_signature ( 1 : self % blocks_number )) do b = 1 , self % blocks_number call self % block_signature ( b )% load_from_file ( file_unit = file_unit ) enddo endif endsubroutine load_from_file","tags":"","loc":"proc/load_from_file~4.html","title":"load_from_file – OFF"},{"text":"private subroutine save_into_file(self, file_unit) Load the grid dimensions of all blocks from file. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: file_unit File unit. Source Code save_into_file Source Code subroutine save_into_file ( self , file_unit ) !< Load the grid dimensions of all blocks from file. class ( grid_dimensions_object ), intent ( in ) :: self !< Grid dimensions object. integer ( I4P ), intent ( in ) :: file_unit !< File unit. integer ( I4P ) :: b !< Counter. if ( self % blocks_number > 0 ) then write ( unit = file_unit ) self % blocks_number do b = 1 , self % blocks_number call self % block_signature ( b )% save_into_file ( file_unit = file_unit ) enddo endif endsubroutine save_into_file","tags":"","loc":"proc/save_into_file~4.html","title":"save_into_file – OFF"},{"text":"private elemental subroutine destroy(self) Destroy node. Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: self Node object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy node. class ( node_object ), intent ( inout ) :: self !< Node object. type ( node_object ) :: fresh !< Fresh instance of node object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~10.html","title":"destroy – OFF"},{"text":"private pure subroutine initialize(self) Initialize node. Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: self Node object. Source Code initialize Source Code pure subroutine initialize ( self ) !< Initialize node. class ( node_object ), intent ( inout ) :: self !< Node object. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~10.html","title":"initialize – OFF"},{"text":"private pure subroutine node_assign_node(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: lhs Left hand side. type( node_object ), intent(in) :: rhs Right hand side. Source Code node_assign_node Source Code pure subroutine node_assign_node ( lhs , rhs ) !< Operator `=`. class ( node_object ), intent ( inout ) :: lhs !< Left hand side. type ( node_object ), intent ( in ) :: rhs !< Right hand side. lhs % vertex = rhs % vertex endsubroutine node_assign_node","tags":"","loc":"proc/node_assign_node.html","title":"node_assign_node – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of the numbers. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(in) :: self Non dimensional numbers. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~6~~CallsGraph proc~description~6 description str str proc~description~6->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the numbers. class ( non_dimensional_numbers_object ), intent ( in ) :: self !< Non dimensional numbers. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'Re      : ' // trim ( str ( n = self % Re )) // NL desc = desc // prefix_ // 'Fr      : ' // trim ( str ( n = self % Fr )) // NL desc = desc // prefix_ // 'We      : ' // trim ( str ( n = self % We )) // NL desc = desc // prefix_ // 'Ma      : ' // trim ( str ( n = self % Ma )) // NL desc = desc // prefix_ // 'Pr      : ' // trim ( str ( n = self % Pr )) // NL desc = desc // prefix_ // 'L0      : ' // trim ( str ( n = self % L0 )) // NL desc = desc // prefix_ // 'r0      : ' // trim ( str ( n = self % r0 )) // NL desc = desc // prefix_ // 'v0      : ' // trim ( str ( n = self % v0 )) // NL desc = desc // prefix_ // 'c0      : ' // trim ( str ( n = self % c0 )) // NL desc = desc // prefix_ // 'mu0     : ' // trim ( str ( n = self % mu0 )) // NL desc = desc // prefix_ // 'f0      : ' // trim ( str ( n = self % f0 )) // NL desc = desc // prefix_ // 'k0      : ' // trim ( str ( n = self % k0 )) // NL desc = desc // prefix_ // 'Dt0     : ' // trim ( str ( n = self % Dt0 )) // NL desc = desc // prefix_ // 'p0      : ' // trim ( str ( n = self % p0 )) // NL desc = desc // prefix_ // 'a0      : ' // trim ( str ( n = self % a0 )) // NL desc = desc // prefix_ // 'T0      : ' // trim ( str ( n = self % T0 )) // NL desc = desc // prefix_ // 'E0      : ' // trim ( str ( n = self % E0 )) // NL desc = desc // prefix_ // 'q0      : ' // trim ( str ( n = self % q0 )) // NL desc = desc // prefix_ // 'Re_inv  : ' // trim ( str ( n = self % Re_inv )) // NL desc = desc // prefix_ // 'Fr2_inv : ' // trim ( str ( n = self % Fr2_inv )) // NL desc = desc // prefix_ // 'PrRe_inv: ' // trim ( str ( n = self % PrRe_inv )) endfunction description","tags":"","loc":"proc/description~6.html","title":"description – OFF"},{"text":"private pure subroutine adim_assign_adim(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: lhs Left hand side. type( non_dimensional_numbers_object ), intent(in) :: rhs Right hand side. Source Code adim_assign_adim Source Code pure subroutine adim_assign_adim ( lhs , rhs ) !< Operator `=`. class ( non_dimensional_numbers_object ), intent ( inout ) :: lhs !< Left hand side. type ( non_dimensional_numbers_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % Re = rhs % Re lhs % Fr = rhs % Fr lhs % We = rhs % We lhs % Ma = rhs % Ma lhs % Pr = rhs % Pr lhs % L0 = rhs % L0 lhs % r0 = rhs % r0 lhs % v0 = rhs % v0 lhs % c0 = rhs % c0 lhs % mu0 = rhs % mu0 lhs % f0 = rhs % f0 lhs % k0 = rhs % k0 lhs % Dt0 = rhs % Dt0 lhs % p0 = rhs % p0 lhs % a0 = rhs % a0 lhs % T0 = rhs % T0 lhs % E0 = rhs % E0 lhs % q0 = rhs % q0 lhs % Re_inv = rhs % Re_inv lhs % Fr2_inv = rhs % Fr2_inv lhs % PrRe_inv = rhs % PrRe_inv endsubroutine adim_assign_adim","tags":"","loc":"proc/adim_assign_adim.html","title":"adim_assign_adim – OFF"},{"text":"private elemental subroutine compute_reference_values(self) Compute derived reference values. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. Source Code compute_reference_values Source Code elemental subroutine compute_reference_values ( self ) !< Compute derived reference values. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. self % mu0 = ( self % r0 * self % v0 * self % L0 ) / self % Re self % f0 = ( self % v0 * self % v0 ) / ( self % L0 * self % Fr * self % Fr ) self % k0 = ( self % mu0 * self % c0 ) / self % Pr self % Dt0 = self % L0 / self % v0 self % p0 = self % r0 * self % v0 * self % v0 self % a0 = self % v0 self % T0 = ( self % v0 * self % v0 ) / self % c0 self % E0 = self % v0 * self % v0 self % q0 = ( self % v0 * self % v0 * self % v0 ) / self % L0 self % Re_inv = 1._R8P / self % Re self % Fr2_inv = 1._R8P / ( self % Fr * self % Fr ) self % PrRe_inv = 1._R8P / ( self % Pr * self % Re ) endsubroutine compute_reference_values","tags":"","loc":"proc/compute_reference_values.html","title":"compute_reference_values – OFF"},{"text":"private elemental subroutine destroy(self) Destroy numbers value. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy numbers value. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. type ( non_dimensional_numbers_object ) :: fresh !< Fresh instance of non dimensional numbers. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~11.html","title":"destroy – OFF"},{"text":"private elemental subroutine initialize(self) Initialize numbers value. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize numbers value. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~11.html","title":"initialize – OFF"},{"text":"private subroutine load_from_file(self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. Source Code load_from_file Source Code subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Non dimensional numbers. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Re' , val = self % Re , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Re)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Fr' , val = self % Fr , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Fr)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'We' , val = self % We , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(We)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Ma' , val = self % Ma , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Me)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'Pr' , val = self % Pr , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(Pr)' , is_severe = . not . go_on_fail_ ) call self % compute_reference_values endsubroutine load_from_file","tags":"","loc":"proc/load_from_file~5.html","title":"load_from_file – OFF"},{"text":"private subroutine save_into_file(self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Simulation parameters. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code save_into_file Source Code subroutine save_into_file ( self , fini ) !< Save into file. class ( non_dimensional_numbers_object ), intent ( inout ) :: self !< Simulation parameters. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Re' , val = self % Re , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Fr' , val = self % Fr , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'We' , val = self % We , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Ma' , val = self % Ma , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'Pr' , val = self % Pr , error = self % error % status ) endsubroutine save_into_file","tags":"","loc":"proc/save_into_file~5.html","title":"save_into_file – OFF"},{"text":"private subroutine cp(self, file_name, dir_name) Copy files/directories. Note leading and trailing white spaces are trimmed out. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: dir_name Dir name. Source Code cp Source Code subroutine cp ( self , file_name , dir_name ) !< Copy files/directories. !< !< @note leading and trailing white spaces are trimmed out. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ), optional :: file_name !< File name. character ( * ), intent ( in ), optional :: dir_name !< Dir name. if ( present ( file_name )) then call execute_command_line ( command = self % cp_file_command // ' ' // trim ( adjustl ( file_name )), exitstat = self % error % status ) elseif ( present ( dir_name )) then call execute_command_line ( command = self % cp_dir_command // ' ' // trim ( adjustl ( dir_name )), exitstat = self % error % status ) else self % error % status = ERROR_CP_FAILED endif endsubroutine cp","tags":"","loc":"proc/cp.html","title":"cp – OFF"},{"text":"private elemental subroutine destroy(self) Destroy OS… not your :-) Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy OS... not your :-) class ( os_object ), intent ( inout ) :: self !< OS. type ( os_object ) :: fresh !< Fresh instance of OS. self = fresh if ( allocated ( self % path_separator )) deallocate ( self % path_separator ) if ( allocated ( self % cp_dir_command )) deallocate ( self % cp_dir_command ) if ( allocated ( self % cp_file_command )) deallocate ( self % cp_file_command ) if ( allocated ( self % mkdir_command )) deallocate ( self % mkdir_command ) if ( allocated ( self % rm_dir_command )) deallocate ( self % rm_dir_command ) if ( allocated ( self % rm_file_command )) deallocate ( self % rm_file_command ) endsubroutine destroy","tags":"","loc":"proc/destroy~12.html","title":"destroy – OFF"},{"text":"private elemental subroutine initialize(self, system) Initialize OS. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: system System name, valid [unix, windows]. Source Code initialize Source Code elemental subroutine initialize ( self , system ) !< Initialize OS. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ), optional :: system !< System name, valid [unix, windows]. type ( string ) :: system_ !< System name. self % error % status = 0 system_ = 'UNIX' if ( present ( system )) then system_ = trim ( adjustl ( system )) system_ = system_ % upper () endif select case ( system_ % chars ()) case ( 'UNIX' ) call self % initialize_unix case ( 'WINDOWS' ) call self % initialize_windows case default call self % initialize_unix self % error % status = ERROR_FALLBACK_INIT endselect endsubroutine initialize","tags":"","loc":"proc/initialize~12.html","title":"initialize – OFF"},{"text":"private elemental subroutine initialize_unix(self) Initialize OS as unix-like system. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. Source Code initialize_unix Source Code elemental subroutine initialize_unix ( self ) !< Initialize OS as unix-like system. class ( os_object ), intent ( inout ) :: self !< OS. call self % destroy self % path_separator = char ( 47 ) self % cp_dir_command = 'cp -r' self % cp_file_command = 'cp' self % mkdir_command = 'mkdir -p' self % rm_dir_command = 'rm -fr' self % rm_file_command = 'rm -f' endsubroutine initialize_unix","tags":"","loc":"proc/initialize_unix.html","title":"initialize_unix – OFF"},{"text":"private elemental subroutine initialize_windows(self) Initialize OS as windows-like system. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. Source Code initialize_windows Source Code elemental subroutine initialize_windows ( self ) !< Initialize OS as windows-like system. class ( os_object ), intent ( inout ) :: self !< OS. call self % destroy self % path_separator = char ( 92 ) self % cp_dir_command = 'copy' self % cp_file_command = 'copy' self % mkdir_command = 'mkdir' self % rm_dir_command = 'del' self % rm_file_command = 'del' endsubroutine initialize_windows","tags":"","loc":"proc/initialize_windows.html","title":"initialize_windows – OFF"},{"text":"private subroutine mkdir(self, dir_name) Make directoriy. Note leading and trailing white spaces are trimmed out. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in) :: dir_name Dir name. Source Code mkdir Source Code subroutine mkdir ( self , dir_name ) !< Make directoriy. !< !< @note leading and trailing white spaces are trimmed out. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ) :: dir_name !< Dir name. call execute_command_line ( command = self % mkdir_command // ' ' // trim ( adjustl ( dir_name )), exitstat = self % error % status ) endsubroutine mkdir","tags":"","loc":"proc/mkdir.html","title":"mkdir – OFF"},{"text":"private pure subroutine os_assign_os(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: lhs Left hand side. type( os_object ), intent(in) :: rhs Right hand side. Source Code os_assign_os Source Code pure subroutine os_assign_os ( lhs , rhs ) !< Operator `=`. class ( os_object ), intent ( inout ) :: lhs !< Left hand side. type ( os_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error if ( allocated ( rhs % path_separator )) lhs % path_separator = rhs % path_separator if ( allocated ( rhs % cp_dir_command )) lhs % cp_dir_command = rhs % cp_dir_command if ( allocated ( rhs % cp_file_command )) lhs % cp_file_command = rhs % cp_file_command if ( allocated ( rhs % mkdir_command )) lhs % mkdir_command = rhs % mkdir_command if ( allocated ( rhs % rm_dir_command )) lhs % rm_dir_command = rhs % rm_dir_command if ( allocated ( rhs % rm_file_command )) lhs % rm_file_command = rhs % rm_file_command endsubroutine os_assign_os","tags":"","loc":"proc/os_assign_os.html","title":"os_assign_os – OFF"},{"text":"private subroutine rm(self, file_name, dir_name) Remove files/directories. Note leading and trailing white spaces are trimmed out. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: dir_name Dir name. Source Code rm Source Code subroutine rm ( self , file_name , dir_name ) !< Remove files/directories. !< !< @note leading and trailing white spaces are trimmed out. class ( os_object ), intent ( inout ) :: self !< OS. character ( * ), intent ( in ), optional :: file_name !< File name. character ( * ), intent ( in ), optional :: dir_name !< Dir name. if ( present ( file_name )) then call execute_command_line ( command = self % rm_file_command // ' ' // trim ( adjustl ( file_name )), exitstat = self % error % status ) elseif ( present ( dir_name )) then call execute_command_line ( command = self % rm_dir_command // ' ' // trim ( adjustl ( dir_name )), exitstat = self % error % status ) else self % error % status = ERROR_RM_FAILED endif endsubroutine rm","tags":"","loc":"proc/rm.html","title":"rm – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of the simulation. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(in) :: self Simulation parameters. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of the simulation. class ( simulation_object ), intent ( in ) :: self !< Simulation parameters. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' ! desc = desc//prefix_//'Files:'//NL ! desc = desc//prefix//self%files_collection%description(prefix='  ')//NL desc = desc // prefix_ // 'Non dimensional numbers:' // NL desc = desc // prefix_ // self % adimensionals % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Free stream conditions:' // NL desc = desc // prefix_ // self % free_conditions % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Solver models:' // NL desc = desc // prefix_ // self % solver % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Time:' // NL desc = desc // prefix_ // self % time % description ( prefix = prefix_ // '  ' ) // NL desc = desc // prefix_ // 'Grid dimensions:' // NL desc = desc // prefix_ // self % grid_dimensions % description ( prefix = prefix_ // '  ' ) endfunction description","tags":"","loc":"proc/description~7.html","title":"description – OFF"},{"text":"private subroutine allocate_blocks(self) Allocate blocks accordingly to grid dimensions. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation data. Source Code allocate_blocks Source Code subroutine allocate_blocks ( self ) !< Allocate blocks accordingly to grid dimensions. class ( simulation_object ), intent ( inout ) :: self !< Simulation data. integer ( I4P ) :: b !< Counter. if ( self % grid_dimensions % blocks_number > 0 ) then if ( allocated ( self % blocks )) then call self % blocks % destroy deallocate ( self % blocks ) endif allocate ( self % blocks ( 1 : self % grid_dimensions % blocks_number )) do b = 1 , self % grid_dimensions % blocks_number call self % blocks ( b )% initialize ( signature = self % grid_dimensions % block_signature ( b )) enddo endif endsubroutine allocate_blocks","tags":"","loc":"proc/allocate_blocks.html","title":"allocate_blocks – OFF"},{"text":"private elemental subroutine destroy(self) Destroy simulation data. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation data. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy simulation data. class ( simulation_object ), intent ( inout ) :: self !< Simulation data. call self % error % destroy call self % cli % free call self % adimensionals % destroy call self % file_grid % destroy call self % free_conditions % destroy call self % os % destroy call self % solver % destroy call self % time % destroy call self % grid_dimensions % destroy if ( allocated ( self % blocks )) then call self % blocks % destroy deallocate ( self % blocks ) endif self % is_cli_parsed = . false . self % file_parameters = '' self % is_output_verbose = . false . self % go_on_fail = . false . endsubroutine destroy","tags":"","loc":"proc/destroy~13.html","title":"destroy – OFF"},{"text":"private subroutine initialize(self, blocks, parse_cli, load_files) Initialize simulation. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. type( block_object ), intent(in), optional :: blocks (1:) Blocks structure. logical, intent(in), optional :: parse_cli Enable CLI parsing. logical, intent(in), optional :: load_files Enable files loading. Source Code initialize Source Code subroutine initialize ( self , blocks , parse_cli , load_files ) !< Initialize simulation. class ( simulation_object ), intent ( inout ) :: self !< simulation data. type ( block_object ), intent ( in ), optional :: blocks ( 1 :) !< Blocks structure. logical , intent ( in ), optional :: parse_cli !< Enable CLI parsing. logical , intent ( in ), optional :: load_files !< Enable files loading. logical :: parse_cli_ !< Enable CLI parsing, local variable. logical :: load_files_ !< Enable files loading, local variable. parse_cli_ = . false . ; if ( present ( parse_cli )) parse_cli_ = parse_cli load_files_ = . false . ; if ( present ( load_files )) load_files_ = load_files call self % destroy call self % error % initialize call self % adimensionals % initialize call self % file_grid % initialize call self % free_conditions % initialize call self % os % initialize call self % solver % initialize call self % time % initialize call self % grid_dimensions % initialize if ( parse_cli_ ) call self % parse_command_line_interface if ( load_files_ ) call self % load_input_files if ( present ( blocks )) then call self % grid_dimensions % initialize ( block_signature = blocks % signature ) allocate ( self % blocks ( 1 : size ( blocks , dim = 1 )), source = blocks ) endif if ( self % is_output_verbose ) print '(A)' , self % description () endsubroutine initialize","tags":"","loc":"proc/initialize~13.html","title":"initialize – OFF"},{"text":"private subroutine integrate(self) Integrate the equations. Todo Implement this. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. Source Code integrate Source Code subroutine integrate ( self ) !< Integrate the equations. !< !< @TODO Implement this. class ( simulation_object ), intent ( inout ) :: self !< simulation data. error stop 'error: simulation_object%integrate to be implemented' endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – OFF"},{"text":"private subroutine load_file_grid(self, file_basename) Load grid file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. character(len=*), intent(in) :: file_basename File basename. Source Code load_file_grid Source Code subroutine load_file_grid ( self , file_basename ) !< Load grid file. class ( simulation_object ), intent ( inout ) :: self !< simulation data. character ( * ), intent ( in ) :: file_basename !< File basename. call self % file_grid % load_grid_dimensions_from_file ( file_name = trim ( adjustl ( file_basename )) // '.grd' , & grid_dimensions = self % grid_dimensions ) call self % allocate_blocks call self % file_grid % load_nodes_from_file ( file_name = trim ( adjustl ( file_basename )) // '.grd' , & grid_dimensions = self % grid_dimensions , blocks = self % blocks ) endsubroutine load_file_grid","tags":"","loc":"proc/load_file_grid.html","title":"load_file_grid – OFF"},{"text":"private subroutine load_file_parameters(self, file_name, go_on_fail) Load file parameters. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation object. character(len=*), intent(in) :: file_name File name. logical, intent(in), optional :: go_on_fail Go on if load fails. Source Code load_file_parameters Source Code subroutine load_file_parameters ( self , file_name , go_on_fail ) !< Load file parameters. class ( simulation_object ), intent ( inout ) :: self !< Simulation object. character ( * ), intent ( in ) :: file_name !< File name. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. type ( file_ini ) :: fini !< Simulation parameters ini file handler. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % load ( filename = file_name , error = self % error % status ) call self % error % check ( message = 'failed to load \"' // trim ( adjustl ( file_name )) // '\"' , is_severe = . not . go_on_fail_ ) if ( self % error % status /= 0 ) then write ( stderr , '(A)' ) 'Using default simulation parameters values' return endif call self % file_grid % load_file_name_from_file ( fini = fini , section_name = 'files' , option_name = 'grid' , go_on_fail = go_on_fail ) ! call self%files_collection%load_from_file(fini=fini, go_on_fail=go_on_fail_) call self % adimensionals % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) call self % free_conditions % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) call self % solver % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) call self % time % load_from_file ( fini = fini , go_on_fail = go_on_fail_ ) endsubroutine load_file_parameters","tags":"","loc":"proc/load_file_parameters.html","title":"load_file_parameters – OFF"},{"text":"private subroutine load_input_files(self) Load from file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. Source Code load_input_files Source Code subroutine load_input_files ( self ) !< Load from file. class ( simulation_object ), intent ( inout ) :: self !< simulation data. if ( self % is_cli_parsed ) then if ( self % is_output_verbose ) print '(A)' , 'load file \"' // trim ( adjustl ( self % file_parameters )) // '\"' call self % load_file_parameters ( file_name = self % file_parameters , go_on_fail = self % go_on_fail ) else error stop 'error: before loading input files, Command Line Interface must be parsed!' endif endsubroutine load_input_files","tags":"","loc":"proc/load_input_files.html","title":"load_input_files – OFF"},{"text":"private subroutine parse_command_line_interface(self) Parse command line interface. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. Source Code parse_command_line_interface Source Code subroutine parse_command_line_interface ( self ) !< Parse command line interface. class ( simulation_object ), intent ( inout ) :: self !< simulation data. integer ( I4P ) :: error !< Error trapping flag. call self % set_command_line_interface call self % cli % parse ( error = error ) ; if ( error /= 0 ) stop call self % cli % get ( switch = '--parameters_file' , val = self % file_parameters , error = error ) ; if ( error /= 0 ) stop call self % cli % get ( switch = '--go-on-fail' , val = self % go_on_fail , error = error ) ; if ( error /= 0 ) stop call self % cli % get ( switch = '--verbose' , val = self % is_output_verbose , error = error ) ; if ( error /= 0 ) stop self % is_cli_parsed = . true . endsubroutine parse_command_line_interface","tags":"","loc":"proc/parse_command_line_interface.html","title":"parse_command_line_interface – OFF"},{"text":"private subroutine save_file_grid(self, file_basename, ascii, metrics, off, tecplot, vtk) Save grid file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. character(len=*), intent(in) :: file_basename File basename. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. logical, intent(in), optional :: off Save in OFF format sentinel. logical, intent(in), optional :: tecplot Tecplot output format sentinel. logical, intent(in), optional :: vtk VTK output format sentinel. Calls proc~~save_file_grid~2~~CallsGraph proc~save_file_grid~2 save_file_grid str str proc~save_file_grid~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_file_grid Source Code subroutine save_file_grid ( self , file_basename , ascii , metrics , off , tecplot , vtk ) !< Save grid file. class ( simulation_object ), intent ( inout ) :: self !< simulation data. character ( * ), intent ( in ) :: file_basename !< File basename. logical , intent ( in ), optional :: ascii !< Ascii/binary output. logical , intent ( in ), optional :: metrics !< Save also metrics data. logical , intent ( in ), optional :: off !< Save in OFF format sentinel. logical , intent ( in ), optional :: tecplot !< Tecplot output format sentinel. logical , intent ( in ), optional :: vtk !< VTK output format sentinel. integer ( I4P ) :: b !< Counter. logical :: off_ !< OFF format sentinel, local variable. logical :: vtk_ !< VTK format sentinel, local variable. character ( len = :), allocatable :: file_name !< File name buffer. off_ = . true . ; if ( present ( off )) off_ = off vtk_ = . false . ; if ( present ( vtk )) vtk_ = vtk if ( off_ ) then call self % file_grid % initialize ( file_name = trim ( adjustl ( file_basename )) // '.grd' ) call self % file_grid % save_grid_dimensions_into_file ( grid_dimensions = self % grid_dimensions ) call self % file_grid % save_nodes_into_file ( grid_dimensions = self % grid_dimensions , blocks = self % blocks ) endif if ( vtk_ ) then do b = 1 , self % grid_dimensions % blocks_number file_name = trim ( adjustl ( file_basename )) // '-block' // & '-id_' // trim ( str ( n = self % blocks ( b )% signature % id , no_sign = . true .)) // & '-lv_' // trim ( str ( n = self % blocks ( b )% signature % level , no_sign = . true .)) // '.vts' call self % blocks ( b )% save_file_grid ( file_name = file_name , ascii = ascii , metrics = metrics , vtk = vtk ) enddo endif endsubroutine save_file_grid","tags":"","loc":"proc/save_file_grid~2.html","title":"save_file_grid – OFF"},{"text":"private subroutine save_file_parameters(self, file_name) Save file parameters. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation object. character(len=*), intent(in) :: file_name File name. Source Code save_file_parameters Source Code subroutine save_file_parameters ( self , file_name ) !< Save file parameters. class ( simulation_object ), intent ( inout ) :: self !< Simulation object. character ( * ), intent ( in ) :: file_name !< File name. type ( file_ini ) :: fini !< Simulation parameters ini file handler. ! call self%files_collection%save_into_file(fini=fini) call self % adimensionals % save_into_file ( fini = fini ) call self % free_conditions % save_into_file ( fini = fini ) call self % solver % save_into_file ( fini = fini ) call self % time % save_into_file ( fini = fini ) call fini % save ( filename = trim ( adjustl ( file_name ))) endsubroutine save_file_parameters","tags":"","loc":"proc/save_file_parameters.html","title":"save_file_parameters – OFF"},{"text":"private subroutine set_command_line_interface(self) Set command line interface. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. Source Code set_command_line_interface Source Code subroutine set_command_line_interface ( self ) !< Set command line interface. class ( simulation_object ), intent ( inout ) :: self !< simulation data. integer ( I4P ) :: error !< Error trapping flag. call self % cli % init ( progname = 'off' , & version = 'v0.0.1' , & authors = 'G. Rossi, S. Zaghi' , & help = 'Usage: ' , & description = 'CNR-INSEAN CFD code' , & examples = [ \"off --parameters sim_parameters.ini --verbose\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call self % cli % add ( switch = '--parameters_file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . false ., & act = 'store' , & def = 'simulation_parameters.ini' , & error = error ) if ( error /= 0 ) stop call self % cli % add ( switch = '--go-on-fail' , & switch_ab = '-gof' , & help = 'go-on if parameters load fails somewhere' , & required = . false ., & def = '.false.' , & act = 'store' ) if ( error /= 0 ) stop call self % cli % add ( switch = '--verbose' , & help = 'enable verbose output' , & required = . false ., & act = 'store_true' , & def = '.false.' , & error = error ) if ( error /= 0 ) stop endsubroutine set_command_line_interface","tags":"","loc":"proc/set_command_line_interface.html","title":"set_command_line_interface – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of solver parameters. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(in) :: self Solver object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~8~~CallsGraph proc~description~8 description str str proc~description~8->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of solver parameters. class ( solver_object ), intent ( in ) :: self !< Solver object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' if ( allocated ( self % time_integrator )) desc = desc // prefix_ // 'time integrator       : ' // self % time_integrator // NL if ( allocated ( self % convective_operator )) desc = desc // prefix_ // 'convective operator   : ' // self % convective_operator // NL if ( allocated ( self % diffusive_operator )) desc = desc // prefix_ // 'diffusive operator    : ' // self % diffusive_operator // NL if ( allocated ( self % turbulence_model )) desc = desc // prefix_ // 'turbulence model      : ' // self % turbulence_model // NL desc = desc // prefix_ // 'artificial viscosity  : ' // trim ( str ( self % artificial_viscosity )) // NL desc = desc // prefix_ // 'residuals tolerance   : ' // trim ( str ( self % residuals_tolerance )) // NL desc = desc // prefix_ // 'pseudo compressibility: ' // trim ( str ( self % pseudo_compressibility )) // NL desc = desc // prefix_ // 'chimera forcing       : ' // trim ( str ( self % chimera_forcing )) endfunction description","tags":"","loc":"proc/description~8.html","title":"description – OFF"},{"text":"private elemental subroutine destroy(self) Destroy solver. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy solver. class ( solver_object ), intent ( inout ) :: self !< Solver object. type ( solver_object ) :: fresh !< Fresh instance of solver object. self = fresh if ( allocated ( self % time_integrator )) deallocate ( self % time_integrator ) if ( allocated ( self % convective_operator )) deallocate ( self % convective_operator ) if ( allocated ( self % diffusive_operator )) deallocate ( self % diffusive_operator ) if ( allocated ( self % turbulence_model )) deallocate ( self % turbulence_model ) endsubroutine destroy","tags":"","loc":"proc/destroy~14.html","title":"destroy – OFF"},{"text":"private elemental subroutine initialize(self) Initialize solver. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize solver. class ( solver_object ), intent ( inout ) :: self !< Solver object. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~14.html","title":"initialize – OFF"},{"text":"private subroutine load_from_file(self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. Source Code load_from_file Source Code subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( solver_object ), intent ( inout ) :: self !< Solver object. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. character ( 999 ) :: buffer !< Buffer string. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'time_integrator' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(time_integrator)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % time_integrator = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'convective_operator' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(convective_operator)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % convective_operator = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'diffusive_operator' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(diffusive_operator)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % diffusive_operator = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'turbulence_model' , & val = buffer , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(turbulence_model)' , is_severe = . not . go_on_fail_ ) if ( self % error % status <= 0 ) self % turbulence_model = trim ( adjustl ( buffer )) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'artificial_viscosity' , & val = self % artificial_viscosity , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(artificial_viscosity)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'residuals_tolerance' , & val = self % residuals_tolerance , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(residuals_tolerance)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'pseudo_compressibility' , & val = self % pseudo_compressibility , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(pseudo_compressibility)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , & option_name = 'chimera_forcing' , & val = self % chimera_forcing , & error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(chimera_forcing)' , is_severe = . not . go_on_fail_ ) endsubroutine load_from_file","tags":"","loc":"proc/load_from_file~6.html","title":"load_from_file – OFF"},{"text":"private subroutine save_into_file(self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code save_into_file Source Code subroutine save_into_file ( self , fini ) !< Save into file. class ( solver_object ), intent ( inout ) :: self !< Solver object. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'time_integrator' , val = self % time_integrator , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'convective_operator' , val = self % convective_operator , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'diffusive_operator' , val = self % diffusive_operator , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'turbulence_model' , val = self % turbulence_model , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'artificial_viscosity' , val = self % artificial_viscosity , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'residuals_tolerance' , val = self % residuals_tolerance , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'pseudo_compressibility' , val = self % pseudo_compressibility , & error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'chimera_forcing' , val = self % chimera_forcing , error = self % error % status ) endsubroutine save_into_file","tags":"","loc":"proc/save_into_file~6.html","title":"save_into_file – OFF"},{"text":"private pure subroutine solver_assign_solver(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: lhs Left hand side. type( solver_object ), intent(in) :: rhs Right hand side. Source Code solver_assign_solver Source Code pure subroutine solver_assign_solver ( lhs , rhs ) !< Operator `=`. class ( solver_object ), intent ( inout ) :: lhs !< Left hand side. type ( solver_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error if ( allocated ( rhs % time_integrator )) lhs % time_integrator = rhs % time_integrator if ( allocated ( rhs % convective_operator )) lhs % convective_operator = rhs % convective_operator if ( allocated ( rhs % diffusive_operator )) lhs % diffusive_operator = rhs % diffusive_operator if ( allocated ( rhs % turbulence_model )) lhs % turbulence_model = rhs % turbulence_model lhs % artificial_viscosity = rhs % artificial_viscosity lhs % residuals_tolerance = rhs % residuals_tolerance lhs % pseudo_compressibility = rhs % pseudo_compressibility lhs % chimera_forcing = rhs % chimera_forcing endsubroutine solver_assign_solver","tags":"","loc":"proc/solver_assign_solver.html","title":"solver_assign_solver – OFF"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted description of time parameters. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~9~~CallsGraph proc~description~9 description str str proc~description~9->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted description of time parameters. class ( time_object ), intent ( in ) :: self !< Time object. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' if ( self % is_unsteady ) then desc = desc // prefix_ // 'timing: unsteady' // NL else desc = desc // prefix_ // 'timing: steady' // NL endif desc = desc // prefix_ // 'n     : ' // trim ( str ( n = self % n )) // NL desc = desc // prefix_ // 't     : ' // trim ( str ( n = self % t )) // NL desc = desc // prefix_ // 'n_max : ' // trim ( str ( n = self % n_max )) // NL desc = desc // prefix_ // 't_max : ' // trim ( str ( n = self % t_max )) // NL desc = desc // prefix_ // 'CFL   : ' // trim ( str ( n = self % CFL )) endfunction description","tags":"","loc":"proc/description~9.html","title":"description – OFF"},{"text":"private elemental function is_the_end(self) result(yes) Return true if the end of simulation is reached. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. Return Value logical Test result. Source Code is_the_end Source Code elemental function is_the_end ( self ) result ( yes ) !< Return true if the end of simulation is reached. class ( time_object ), intent ( in ) :: self !< Time object. logical :: yes !< Test result. yes = (( self % t == self % t_max ). or .( self % n == self % n_max )) endfunction is_the_end","tags":"","loc":"proc/is_the_end.html","title":"is_the_end – OFF"},{"text":"private elemental function progress(self) result(prog) Return the progress of simulation. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. Return Value real(kind=R8P) Actual progress value. Source Code progress Source Code elemental function progress ( self ) result ( prog ) !< Return the progress of simulation. class ( time_object ), intent ( in ) :: self !< Time object. real ( R8P ) :: prog !< Actual progress value. if ( self % n_max > 0 ) then prog = self % n * 100 / ( self % n_max * 1._R8P ) elseif ( self % t_max > 0._R8P ) then prog = 100 * self % t / self % t_max else prog = 0._R8P endif endfunction progress","tags":"","loc":"proc/progress.html","title":"progress – OFF"},{"text":"private elemental subroutine destroy(self) Destroy time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy time. class ( time_object ), intent ( inout ) :: self !< Time object. type ( time_object ) :: fresh !< Fresh instance of time object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~15.html","title":"destroy – OFF"},{"text":"private elemental subroutine initialize(self) Initialize time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. Source Code initialize Source Code elemental subroutine initialize ( self ) !< Initialize time. class ( time_object ), intent ( inout ) :: self !< Time object. call self % destroy endsubroutine initialize","tags":"","loc":"proc/initialize~15.html","title":"initialize – OFF"},{"text":"private subroutine load_from_file(self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. Source Code load_from_file Source Code subroutine load_from_file ( self , fini , go_on_fail ) !< Load from file. class ( time_object ), intent ( inout ) :: self !< Time object. type ( file_ini ), intent ( in ) :: fini !< Simulation parameters ini file handler. logical , intent ( in ), optional :: go_on_fail !< Go on if load fails. logical :: go_on_fail_ !< Go on if load fails, local variable. go_on_fail_ = . true . ; if ( present ( go_on_fail )) go_on_fail_ = go_on_fail call fini % get ( section_name = INI_SECTION_NAME , option_name = 'is_unsteady' , val = self % is_unsteady , error = self % error % status ) if (. not . go_on_fail_ ) & call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(is_unsteady)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'n_max' , val = self % n_max , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(n_max)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 't_max' , val = self % t_max , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(t_max)' , is_severe = . not . go_on_fail_ ) call fini % get ( section_name = INI_SECTION_NAME , option_name = 'cfl' , val = self % CFL , error = self % error % status ) if (. not . go_on_fail_ ) call self % error % check ( message = 'failed to load [' // INI_SECTION_NAME // '].(cfl)' , is_severe = . not . go_on_fail_ ) endsubroutine load_from_file","tags":"","loc":"proc/load_from_file~7.html","title":"load_from_file – OFF"},{"text":"private subroutine save_into_file(self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. Source Code save_into_file Source Code subroutine save_into_file ( self , fini ) !< Save into file. class ( time_object ), intent ( inout ) :: self !< Time object. type ( file_ini ), intent ( inout ) :: fini !< Simulation parameters ini file handler. call fini % add ( section_name = INI_SECTION_NAME , option_name = 'is_unsteady' , val = self % is_unsteady , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'n_max' , val = self % n_max , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 't_max' , val = self % t_max , error = self % error % status ) call fini % add ( section_name = INI_SECTION_NAME , option_name = 'cfl' , val = self % cfl , error = self % error % status ) endsubroutine save_into_file","tags":"","loc":"proc/save_into_file~7.html","title":"save_into_file – OFF"},{"text":"private elemental subroutine set_stop(self) Set simulation stop condition. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. Source Code set_stop Source Code elemental subroutine set_stop ( self ) !< Set simulation stop condition. class ( time_object ), intent ( inout ) :: self !< Time object. if ( self % is_unsteady ) then if ( self % n_max > 0_I8P ) then self % t_max = - 1._R8P ! the value of t_max is ignored because n_max>0 else self % n_max = - 1_I8P endif else self % t_max = - 1._R8P ! the value of t_max is ignored because steady simulation endif endsubroutine set_stop","tags":"","loc":"proc/set_stop.html","title":"set_stop – OFF"},{"text":"private pure subroutine time_assign_time(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: lhs Left hand side. type( time_object ), intent(in) :: rhs Right hand side. Source Code time_assign_time Source Code pure subroutine time_assign_time ( lhs , rhs ) !< Operator `=`. class ( time_object ), intent ( inout ) :: lhs !< Left hand side. type ( time_object ), intent ( in ) :: rhs !< Right hand side. lhs % error = rhs % error lhs % n = rhs % n lhs % t = rhs % t lhs % n_max = rhs % n_max lhs % t_max = rhs % t_max lhs % CFL = rhs % CFL lhs % is_unsteady = rhs % is_unsteady endsubroutine time_assign_time","tags":"","loc":"proc/time_assign_time.html","title":"time_assign_time – OFF"},{"text":"private elemental subroutine update(self, global_min_dt) Update time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. real(kind=R8P), intent(inout) :: global_min_dt Global (all processes/images, all blocks) minimum time step. Source Code update Source Code elemental subroutine update ( self , global_min_dt ) !< Update time. class ( time_object ), intent ( inout ) :: self !< Time object. real ( R8P ), intent ( inout ) :: global_min_dt !< Global (all processes/images, all blocks) minimum time step. if ( self % is_unsteady ) then ! for an unsteady accurate simulation each cell is updated by means of global minimum time step ! control for the last iterate if ( self % n_max <= 0 ) then if (( self % t + global_min_dt ) > self % t_max ) then ! the global minimum time step is so high that the last iteration will go over t_max ! it is decreased in order to achieve exactly t_max global_min_dt = abs ( self % t_max - self % t ) endif endif self % t = self % t + global_min_dt endif endsubroutine update","tags":"","loc":"proc/update.html","title":"update – OFF"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~~CalledByGraph proc~cli_parse cli_parse program~off_test_load_file_parameters off_test_load_file_parameters program~off_test_load_file_parameters->proc~cli_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_load_file_parameters' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_load_file_parameters --parameters sim_parameters.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--parameters-file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . true ., & act = 'store' ) call cli % add ( switch = '--go-on-fail' , & switch_ab = '-gof' , & help = 'go-on if load fails somewhere' , & required = . false ., & def = '.false.' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--parameters-file' , val = file_parameters ) call cli % get ( switch = '--go-on-fail' , val = go_on_fail ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse.html","title":"cli_parse – OFF"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~2~~CalledByGraph proc~cli_parse~2 cli_parse program~off_test_save_load_file_grid off_test_save_load_file_grid program~off_test_save_load_file_grid->proc~cli_parse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_save_load_file_grid' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_save_load_file_grid --grid-basename grid\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--grid-basename' , & switch_ab = '-g' , & help = 'basename of grid file' , & required = . false ., & def = 'grid' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--grid-basename' , val = file_basename ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse~2.html","title":"cli_parse – OFF"},{"text":"subroutine cli_parse() Build and parse test cli. Arguments None Called By proc~~cli_parse~3~~CalledByGraph proc~cli_parse~3 cli_parse program~off_test_save_load_file_parameters off_test_save_load_file_parameters program~off_test_save_load_file_parameters->proc~cli_parse~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_save_load_file_parameters' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_save_load_file_parameters --parameters sim_parameters.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--parameters-file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . true ., & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--parameters-file' , val = file_parameters ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse~3.html","title":"cli_parse – OFF"},{"text":"Uses: iso_fortran_env off_block_signature_object off_cell_object off_error_object off_face_object off_node_object penf vecfor vtk_fortran module~~off_block_object~~UsesGraph module~off_block_object off_block_object module~off_error_object off_error_object module~off_error_object->module~off_block_object module~off_cell_object off_cell_object module~off_cell_object->module~off_block_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_block_object iso_fortran_env->module~off_error_object module~off_block_signature_object off_block_signature_object module~off_block_signature_object->module~off_block_object module~off_node_object off_node_object module~off_node_object->module~off_block_object penf penf penf->module~off_block_object penf->module~off_error_object penf->module~off_cell_object penf->module~off_block_signature_object module~off_face_object off_face_object penf->module~off_face_object module~off_face_object->module~off_block_object vecfor vecfor vecfor->module~off_block_object vecfor->module~off_cell_object vecfor->module~off_block_signature_object vecfor->module~off_node_object vecfor->module~off_face_object vtk_fortran vtk_fortran vtk_fortran->module~off_block_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF block object definition and implementation. block_object is a Finite Volume block-structured class. It allows the easy handling of metrics data for the robust and efficient computation of numerical spatial\n operators in the framework of Finite Volume Methods (FVM). Let us assume that the fluid domain D is decomposed in N_b structured blocks D&#94;b, each subdivided in\n N_i \\times N_j \\times N_k disjoint hexahedrons D_{ijk}&#94;b such that \\bigcup D_{ijk}&#94;b = D&#94;b.\n The block class is designed to aid the computations of the spatial operators into each block:\n \n\\frac{\\partial}{{\\partial t}}\\int\\limits_{V_{ijk}} {\\overrightarrow U dV}  =\n-\\sum\\limits_{s = 1}&#94;6 {\\int\\limits_{S_s} {\\left(\\overline{\\overline {F}}\\right) \\cdot \\overrightarrow n dS}} +\n \\int\\limits_{V_{ijk}} {\\overrightarrow {{Q}} dV}\\label{eq:rans-cons-num}\n \n where S_s is the s&#94;{th} face of the finite volume D_{ijk} whose measure is V_{ijk}. A structured block is composed of hexahedron finite volumes with quadrilateral faces using the\n following internal numeration for nodes and faces: /|\\Z\n  |                            F(4)         _ F(6)\n  |                            /|\\          /!\n  |                        7    |          /    8\n  |                         *------------------*\n  |                        /|   |        /    /|\n  |                       / |   |       /    / |\n  |                      /  |   |      /    /  |\n  |                     /   |   |     /    /   |\n  |                    /    |   |    +    /    |\n  |                   /     |   |        /     |\n  |                  /      |   +       /      |\n  |                 /      3|          /       |4\n  |                /        * --------/--------*\n  |      F(1)<----/----+   /         /        /\n  |              *------------------*    +-------->F(2)\n  |             5|       /          |6      /\n  |              |      /           |      /\n  |              |     /        +   |     /\n  |              |    /         |   |    /\n  |              |   /      +   |   |   /\n  |              |  /      /    |   |  /\n  |              | /      /     |   | /\n  |              |/      /      |   |/\n  |              *------------------*\n  |             1      /        |    2\n  |                   /        \\|/\n  |   _ Y           |/_       F(3)\n  |   /|         F(5)\n  |  /\n  | /\n  |/                                                    X\n  O-----------------------------------------------------> Each hexadron cells is faces-connected to its neighboring, thus the cells build a structured block with implicit\n connectivity, e.g. in 2D space a block could be as the following: _ J\n                 /|                          _____\n               5+ ...*----*----*----*----*...     |\n               /    /    /    /    /    /         |\n              /    /    /    /    /    /          |\n            4+ ...*----*----*----*----*...        |\n            /    /    /    /    /    /            |\n           /    /    /    /    /    /             |\n         3+ ...*----*----*----*----*...           |  Structured block of 4x4 Finite Volumes\n         /    /    / FV /    /    /               |\n        /    /    /    /    /    /                |\n      2+ ...*----*----*----*----*...              |\n      /    /    /    /    /    /                  |\n     /    /    /    /    /    /                   |\n   1+ ...*----*----*----*----*...                 |\n   /     .    .    .    .    .                    |\n  /      .    .    .    .    .               _____\n O-------+----+----+----+----+-------------> I\n         1    2    3    4    5 The nodes of cells are not required to be on the Cartesian coordinates, thus allowing a general\n curvilinear mesh: the are 3 implicit coordinate lines, i , j and k that are not required to be orthogonal. Used By module~~off_block_object~~UsedByGraph module~off_block_object off_block_object module~off_simulation_object off_simulation_object module~off_block_object->module~off_simulation_object module~off_file_grid_object off_file_grid_object module~off_block_object->module~off_file_grid_object module~off_objects off_objects module~off_block_object->module~off_objects module~off_simulation_object->module~off_objects module~off_file_grid_object->module~off_simulation_object module~off_file_grid_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid var panmoduleoff_block_objectUsedByGraph = svgPanZoom('#moduleoff_block_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ERROR_BLOCK_COMPUTE_EXTENTS_FAILED ERROR_BLOCK_CREATE_FAILED ERROR_BLOCK_CREATE_LINSPACE_FAILED ERROR_BLOCK_DESTROY_FAILED NO_ERROR Derived Types block_object Functions cells_number node_to_center nodes_number Subroutines block_assign_block compute_extents compute_faces_metrics compute_metrics compute_space_operator compute_volumes correct_metrics create_linspace destroy initialize interpolate_at_nodes load_nodes_from_file nullify_normals save_file_grid save_file_grid_tec save_file_grid_vtk save_nodes_into_file Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: ERROR_BLOCK_COMPUTE_EXTENTS_FAILED = 1 Failed to compute block extents. integer(kind=I4P), private, parameter :: ERROR_BLOCK_CREATE_FAILED = 2 Failed to create block. integer(kind=I4P), private, parameter :: ERROR_BLOCK_CREATE_LINSPACE_FAILED = 4 Failed to create a uniform-spaced linear block. integer(kind=I4P), private, parameter :: ERROR_BLOCK_DESTROY_FAILED = 3 Failed to destroy block. integer(kind=I4P), private, parameter :: NO_ERROR = 0 No errors occurred. Derived Types type, public :: block_object Block object class. Components Type Visibility Attributes Name Initial type( cell_object ), public, allocatable :: cell (:,:,:) Cell. type( error_object ), public :: error Errors handler. type( face_object ), public, allocatable :: face_i (:,:,:) Faces along I direction. type( face_object ), public, allocatable :: face_j (:,:,:) Faces along I direction. type( face_object ), public, allocatable :: face_k (:,:,:) Faces along I direction. type( node_object ), public, allocatable :: node (:,:,:) Cell. type( block_signature_object ), public :: signature Signature, namely id, level, dimensions, etc… Type-Bound Procedures generic, public :: assignment(=) => block_assign_block Overload = . procedure, private, pass(lhs) :: block_assign_block Operator = . procedure, public, pass(self) :: cells_number Return the number of cells. procedure, private, pass(self) :: compute_extents Compute block extents. procedure, private, pass(self) :: compute_faces_metrics Compute block faces metrics. procedure, private, pass(self) :: compute_metrics Compute block metrics. procedure, public, pass(self) :: compute_space_operator Compute space operator. procedure, private, pass(self) :: compute_volumes Compute block volumes. procedure, private, pass(self) :: correct_metrics Correct block metrics. procedure, public, pass(self) :: create_linspace Create a Cartesian block with linearly spaced nodes. procedure, public, pass(self) :: destroy Destroy block. procedure, public, pass(self) :: initialize Initialize block. procedure, public, pass(self) :: interpolate_at_nodes Interpolate cell-centered variable at nodes. procedure, public, pass(self) :: load_nodes_from_file Load nodes from file. procedure, private, pass(self) :: node_to_center Compute cell centers coordinates from cell nodes. procedure, public, pass(self) :: nodes_number Return the number of nodes. procedure, private, pass(self) :: nullify_normals Nullify normals for 2D or 1D domains. procedure, public, pass(self) :: save_file_grid Save gird file. procedure, private, pass(self) :: save_file_grid_tec Save grid file in Tecplot format. procedure, private, pass(self) :: save_file_grid_vtk Save grid file in VTK format. procedure, public, pass(self) :: save_nodes_into_file Save nodes into file. Functions private elemental function cells_number (self, with_ghosts) result(cells_number_) Return the number of cells. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. private pure function node_to_center (self) result(center) Compute cell centers coordinates from cell nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. Return Value type(vector),\n  allocatable, (:,:,:) Cell centers coordinates. private elemental function nodes_number (self, with_ghosts) result(nodes_number_) Return the number of nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. Subroutines private pure subroutine block_assign_block (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: lhs Left hand side. type( block_object ), intent(in) :: rhs Right hand side. private elemental subroutine compute_extents (self) Compute block extents. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. private elemental subroutine compute_faces_metrics (self) Compute block faces metrics. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. private subroutine compute_metrics (self) Compute block metrics. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. private subroutine compute_space_operator (self) Compute space operator. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. private elemental subroutine compute_volumes (self) Compute block volumes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. private subroutine correct_metrics (self) Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Correct the metrics. private subroutine create_linspace (self, emin, emax) Create a Cartesian block with linearly spaced nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. private elemental subroutine destroy (self) Destroy block. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. private subroutine initialize (self, signature, id, level, gc, ni, nj, nk, emin, emax, is_cartesian, is_null_x, is_null_y, is_null_z) Initialize block. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. type( block_signature_object ), intent(in), optional :: signature Signature, namely id, level, dimensions, etc… integer(kind=I8P), intent(in), optional :: id Unique (Morton) identification code. integer(kind=I4P), intent(in), optional :: level Grid refinement level. integer(kind=I4P), intent(in), optional :: gc (1:) Number of ghost cells along each frame. integer(kind=I4P), intent(in), optional :: ni Number of cells in I direction. integer(kind=I4P), intent(in), optional :: nj Number of cells in J direction. integer(kind=I4P), intent(in), optional :: nk Number of cells in K direction. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. logical, intent(in), optional :: is_cartesian Flag for checking if the block is Cartesian. logical, intent(in), optional :: is_null_x Nullify X direction (2D yz, 1D y or z domain). logical, intent(in), optional :: is_null_y Nullify Y direction (2D xy, 1D x or y domain). logical, intent(in), optional :: is_null_z Nullify Z direction (2D xy, 1D x or y domain). private pure subroutine interpolate_at_nodes (self, var_cell, var_node) Interpolate cell-centered variable at nodes. Arguments Type Intent Optional Attributes Name class( block_object ), intent(in) :: self Block. real(kind=R8P), intent(in) :: var_cell (1-self%signature%gc(1):,1-self%signature%gc(3):,1-self%signature%gc(5):) Cell-centered variable. real(kind=R8P), intent(out) :: var_node (0-self%signature%gc(1):,0-self%signature%gc(3):,0-self%signature%gc(5):) Node-centered variable. private subroutine load_nodes_from_file (self, file_unit, pos) Load nodes from file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. integer(kind=I4P), intent(in) :: file_unit File unit. integer(kind=I4P), intent(in) :: pos Position to start the loading. private elemental subroutine nullify_normals (self) Nullify normals for 2D or 1D domains. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. private subroutine save_file_grid (self, file_name, ascii, metrics, tecplot, vtk) Save grid file file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name File name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. logical, intent(in), optional :: tecplot Tecplot output format sentinel. logical, intent(in), optional :: vtk VTK output format sentinel. private subroutine save_file_grid_tec (self, file_name, ascii, metrics) Save grid file in Tecplot format. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name Output file name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. private subroutine save_file_grid_vtk (self, file_name, ascii, metrics) Save mesh data into VTK file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. character(len=*), intent(in) :: file_name Output file name. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. private subroutine save_nodes_into_file (self, file_unit, pos) Save nodes into file. Arguments Type Intent Optional Attributes Name class( block_object ), intent(inout) :: self Block. integer(kind=I4P), intent(in) :: file_unit File unit. integer(kind=I4P), intent(in) :: pos Position to start the loading.","tags":"","loc":"module/off_block_object.html","title":"off_block_object – OFF"},{"text":"Uses: penf vecfor module~~off_block_signature_object~~UsesGraph module~off_block_signature_object off_block_signature_object vecfor vecfor vecfor->module~off_block_signature_object penf penf penf->module~off_block_signature_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF block signature object definition and implementation. Used By module~~off_block_signature_object~~UsedByGraph module~off_block_signature_object off_block_signature_object module~off_objects off_objects module~off_block_signature_object->module~off_objects module~off_block_object off_block_object module~off_block_signature_object->module~off_block_object module~off_grid_dimensions_object off_grid_dimensions_object module~off_block_signature_object->module~off_grid_dimensions_object program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid module~off_block_object->module~off_objects module~off_simulation_object off_simulation_object module~off_block_object->module~off_simulation_object module~off_file_grid_object off_file_grid_object module~off_block_object->module~off_file_grid_object module~off_grid_dimensions_object->module~off_objects module~off_grid_dimensions_object->module~off_simulation_object module~off_grid_dimensions_object->module~off_file_grid_object module~off_simulation_object->module~off_objects module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object var panmoduleoff_block_signature_objectUsedByGraph = svgPanZoom('#moduleoff_block_signature_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types block_signature_object Functions cells_number description iolength nodes_number Subroutines block_d_assign_block_d destroy initialize load_from_file save_into_file Derived Types type, public :: block_signature_object Block signature object class. Components Type Visibility Attributes Name Initial type(vector), public :: emax Coordinates of maximum abscissa (extent) of the block. type(vector), public :: emin Coordinates of minimum abscissa (extent) of the block. integer(kind=I4P), public :: gc (1:6) = [0, 0, 0, 0, 0, 0] Number of ghost cells along each frame. integer(kind=I8P), public :: id = 0 Unique (Morton) identification code. logical, public :: is_cartesian = .false. Flag for checking if the block is Cartesian. logical, public :: is_null_x = .false. Nullify X direction (2D yz, 1D y or z domain). logical, public :: is_null_y = .false. Nullify Y direction (2D xy, 1D x or y domain). logical, public :: is_null_z = .false. Nullify Z direction (2D xy, 1D x or y domain). integer(kind=I4P), public :: level = 0 block refinement level. integer(kind=I4P), public :: ni = 0 Number of cells in I direction. integer(kind=I4P), public :: nj = 0 Number of cells in J direction. integer(kind=I4P), public :: nk = 0 Number of cells in K direction. Type-Bound Procedures generic, public :: assignment(=) => block_d_assign_block_d Overload = . procedure, public, pass(lhs) :: block_d_assign_block_d Operator = . procedure, public, pass(self) :: cells_number Return the number of cells. procedure, public, pass(self) :: description Return a pretty-formatted description of block signature. procedure, public, pass(self) :: destroy Destroy block signature. procedure, public, pass(self) :: initialize Initialize block signature. procedure, public, pass(self) :: iolength Return the IO length storage. procedure, public, pass(self) :: load_from_file Load block signature from file. procedure, public, pass(self) :: nodes_number Return the number of nodes. procedure, public, pass(self) :: save_into_file Save block signature into file. Functions private elemental function cells_number (self, with_ghosts) result(cells_number_) Return the number of cells. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of cells. private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private function iolength (self) Return the IO length storage. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. Return Value integer(kind=I4P) IO length storage. private elemental function nodes_number (self, with_ghosts) result(nodes_number_) Return the number of nodes. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block. logical, intent(in), optional :: with_ghosts Take into account ghost cells. Return Value integer(kind=I4P) Number of nodes. Subroutines private pure subroutine block_d_assign_block_d (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: lhs Left hand side. type( block_signature_object ), intent(in) :: rhs Right hand side. private elemental subroutine destroy (self) Destroy block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. private pure subroutine initialize (self, signature, id, level, gc, ni, nj, nk, emin, emax, is_cartesian, is_null_x, is_null_y, is_null_z) Initialize block signature. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. type( block_signature_object ), intent(in), optional :: signature Block signature input. integer(kind=I8P), intent(in), optional :: id Unique (Morton) identification code. integer(kind=I4P), intent(in), optional :: level Grid refinement level. integer(kind=I4P), intent(in), optional :: gc (1:) Number of ghost cells along each frame. integer(kind=I4P), intent(in), optional :: ni Number of cells in I direction. integer(kind=I4P), intent(in), optional :: nj Number of cells in J direction. integer(kind=I4P), intent(in), optional :: nk Number of cells in K direction. type(vector), intent(in), optional :: emin Coordinates of minimum abscissa of the block. type(vector), intent(in), optional :: emax Coordinates of maximum abscissa of the block. logical, intent(in), optional :: is_cartesian Flag for checking if the block is Cartesian. logical, intent(in), optional :: is_null_x Nullify X direction (2D yz, 1D y or z domain). logical, intent(in), optional :: is_null_y Nullify Y direction (2D xy, 1D x or y domain). logical, intent(in), optional :: is_null_z Nullify Z direction (2D xy, 1D x or y domain). private subroutine load_from_file (self, file_unit) Load block signature from file. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(inout) :: self Block signature object. integer(kind=I4P), intent(in) :: file_unit File unit. private subroutine save_into_file (self, file_unit) Load the block signature of all blocks from file. Arguments Type Intent Optional Attributes Name class( block_signature_object ), intent(in) :: self Block signature object. integer(kind=I4P), intent(in) :: file_unit File unit.","tags":"","loc":"module/off_block_signature_object.html","title":"off_block_signature_object – OFF"},{"text":"Uses: penf vecfor module~~off_cell_object~~UsesGraph module~off_cell_object off_cell_object vecfor vecfor vecfor->module~off_cell_object penf penf penf->module~off_cell_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF cell object definition and implementation. Used By module~~off_cell_object~~UsedByGraph module~off_cell_object off_cell_object module~off_block_object off_block_object module~off_cell_object->module~off_block_object module~off_objects off_objects module~off_cell_object->module~off_objects module~off_block_object->module~off_objects module~off_simulation_object off_simulation_object module~off_block_object->module~off_simulation_object module~off_file_grid_object off_file_grid_object module~off_block_object->module~off_file_grid_object program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid module~off_simulation_object->module~off_objects module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object var panmoduleoff_cell_objectUsedByGraph = svgPanZoom('#moduleoff_cell_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types cell_object Subroutines cell_assign_cell destroy initialize Derived Types type, public :: cell_object Cell object class. Components Type Visibility Attributes Name Initial type(vector), public :: center Cell center. real(kind=R8P), public :: volume = 0._R8P Cell volume. Type-Bound Procedures generic, public :: assignment(=) => cell_assign_cell Overload = . procedure, public, pass(lhs) :: cell_assign_cell Operator = . procedure, public, pass(self) :: destroy Destroy cell. procedure, public, pass(self) :: initialize Initialize cell. Subroutines private pure subroutine cell_assign_cell (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: lhs Left hand side. type( cell_object ), intent(in) :: rhs Right hand side. private elemental subroutine destroy (self) Destroy cell. Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: self Cell object. private elemental subroutine initialize (self) Initialize cell. Arguments Type Intent Optional Attributes Name class( cell_object ), intent(inout) :: self Cell object.","tags":"","loc":"module/off_cell_object.html","title":"off_cell_object – OFF"},{"text":"Uses: iso_fortran_env penf module~~off_error_object~~UsesGraph module~off_error_object off_error_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object penf penf penf->module~off_error_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF error object definition and implementation. Used By module~~off_error_object~~UsedByGraph module~off_error_object off_error_object module~off_solver_object off_solver_object module~off_error_object->module~off_solver_object module~off_simulation_object off_simulation_object module~off_error_object->module~off_simulation_object module~off_file_object off_file_object module~off_error_object->module~off_file_object module~off_time_object off_time_object module~off_error_object->module~off_time_object module~off_block_object off_block_object module~off_error_object->module~off_block_object module~off_free_conditions_object off_free_conditions_object module~off_error_object->module~off_free_conditions_object module~off_os_object off_os_object module~off_error_object->module~off_os_object module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object module~off_error_object->module~off_non_dimensional_numbers_object module~off_objects off_objects module~off_error_object->module~off_objects module~off_solver_object->module~off_simulation_object module~off_solver_object->module~off_objects module~off_simulation_object->module~off_objects module~off_file_object->module~off_objects module~off_files_collection_object off_files_collection_object module~off_file_object->module~off_files_collection_object module~off_file_grid_object off_file_grid_object module~off_file_object->module~off_file_grid_object module~off_time_object->module~off_simulation_object module~off_time_object->module~off_objects module~off_block_object->module~off_simulation_object module~off_block_object->module~off_objects module~off_block_object->module~off_file_grid_object module~off_free_conditions_object->module~off_simulation_object module~off_free_conditions_object->module~off_objects module~off_os_object->module~off_simulation_object module~off_os_object->module~off_objects module~off_non_dimensional_numbers_object->module~off_simulation_object module~off_non_dimensional_numbers_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid module~off_files_collection_object->module~off_objects module~off_file_grid_object->module~off_simulation_object module~off_file_grid_object->module~off_objects var panmoduleoff_error_objectUsedByGraph = svgPanZoom('#moduleoff_error_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types error_object Subroutines check destroy err_assign_err initialize Derived Types type, public :: error_object Error object class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Error message. integer(kind=I4P), public :: status = 0_I4P Error status. Type-Bound Procedures generic, public :: assignment(=) => err_assign_err Overload = . procedure, public, pass(self) :: check Check error status. procedure, public, pass(self) :: destroy Destroy error. procedure, public, pass(lhs) :: err_assign_err Operator = . procedure, public, pass(self) :: initialize Initialize error. Subroutines private subroutine check (self, message, is_severe) Check error status. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. character(len=*), intent(in), optional :: message Error message. logical, intent(in), optional :: is_severe Enable severe error. private elemental subroutine destroy (self) Destroy error. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object. private pure subroutine err_assign_err (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: lhs Left hand side. type( error_object ), intent(in) :: rhs Right hand side. private elemental subroutine initialize (self) Initialize error. Arguments Type Intent Optional Attributes Name class( error_object ), intent(inout) :: self Error object.","tags":"","loc":"module/off_error_object.html","title":"off_error_object – OFF"},{"text":"Uses: penf vecfor module~~off_face_object~~UsesGraph module~off_face_object off_face_object vecfor vecfor vecfor->module~off_face_object penf penf penf->module~off_face_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF face object definition and implementation. Used By module~~off_face_object~~UsedByGraph module~off_face_object off_face_object module~off_block_object off_block_object module~off_face_object->module~off_block_object module~off_objects off_objects module~off_face_object->module~off_objects module~off_block_object->module~off_objects module~off_simulation_object off_simulation_object module~off_block_object->module~off_simulation_object module~off_file_grid_object off_file_grid_object module~off_block_object->module~off_file_grid_object program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid module~off_simulation_object->module~off_objects module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object var panmoduleoff_face_objectUsedByGraph = svgPanZoom('#moduleoff_face_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types face_object Subroutines compute_metrics destroy face_assign_face initialize Derived Types type, public :: face_object Face object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: area = 0._R8P Area. type(vector), public :: normal Normal versor. Type-Bound Procedures generic, public :: assignment(=) => face_assign_face Overload = . procedure, public, pass(self) :: compute_metrics Compute face metrics. procedure, public, pass(self) :: destroy Destroy face. procedure, public, pass(lhs) :: face_assign_face Operator = . procedure, public, pass(self) :: initialize Initialize face. Subroutines private elemental subroutine compute_metrics (self, pt1, pt2, pt3, pt4, signd) Compute face metrics. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face. type(vector), intent(in) :: pt1 Point 1 of face. type(vector), intent(in) :: pt2 Point 2 of face. type(vector), intent(in) :: pt3 Point 3 of face. type(vector), intent(in) :: pt4 Point 4 of face. real(kind=R8P), intent(in) :: signd Sign of direction along normal coordinate. private elemental subroutine destroy (self) Destroy face. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face object. private pure subroutine face_assign_face (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: lhs Left hand side. type( face_object ), intent(in) :: rhs Right hand side. private pure subroutine initialize (self) Initialize face. Arguments Type Intent Optional Attributes Name class( face_object ), intent(inout) :: self Face object.","tags":"","loc":"module/off_face_object.html","title":"off_face_object – OFF"},{"text":"Uses: iso_fortran_env off_block_object off_grid_dimensions_object off_file_object penf module~~off_file_grid_object~~UsesGraph module~off_file_grid_object off_file_grid_object module~off_file_object off_file_object module~off_file_object->module~off_file_grid_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_file_grid_object iso_fortran_env->module~off_file_object module~off_block_object off_block_object iso_fortran_env->module~off_block_object module~off_error_object off_error_object iso_fortran_env->module~off_error_object module~off_block_object->module~off_file_grid_object penf penf penf->module~off_file_grid_object penf->module~off_file_object penf->module~off_block_object module~off_grid_dimensions_object off_grid_dimensions_object penf->module~off_grid_dimensions_object penf->module~off_error_object module~off_cell_object off_cell_object penf->module~off_cell_object module~off_block_signature_object off_block_signature_object penf->module~off_block_signature_object module~off_face_object off_face_object penf->module~off_face_object module~off_grid_dimensions_object->module~off_file_grid_object finer finer finer->module~off_file_object module~off_error_object->module~off_file_object module~off_error_object->module~off_block_object module~off_cell_object->module~off_block_object module~off_block_signature_object->module~off_block_object module~off_block_signature_object->module~off_grid_dimensions_object module~off_node_object off_node_object module~off_node_object->module~off_block_object module~off_face_object->module~off_block_object vecfor vecfor vecfor->module~off_block_object vecfor->module~off_grid_dimensions_object vecfor->module~off_cell_object vecfor->module~off_block_signature_object vecfor->module~off_node_object vecfor->module~off_face_object vtk_fortran vtk_fortran vtk_fortran->module~off_block_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF file grid object definition and implementation. The file grid is an unformatted, stream file containing the nodes coordinates of the whole grid.\n It skeleton is the following # header\n blocks_number\n # for each block\n id, level, gc, ni, nj, nk\n # core\n # for each block (for all nodes of block)\n node%vertex%x, node%vertex%y, node%vertex%z file_grid_object provides standard API for loading and saving this file. Used By module~~off_file_grid_object~~UsedByGraph module~off_file_grid_object off_file_grid_object module~off_simulation_object off_simulation_object module~off_file_grid_object->module~off_simulation_object module~off_objects off_objects module~off_file_grid_object->module~off_objects module~off_simulation_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types file_grid_object Subroutines load_grid_dimensions_from_file load_nodes_from_file save_grid_dimensions_into_file save_nodes_into_file Derived Types type, public, extends( file_object ) :: file_grid_object File grid object class. Components Type Visibility Attributes Name Initial type( error_object ), public :: error Errors handler. character(len=:), public, allocatable :: file_name File name. integer(kind=I4P), public :: file_unit = 0 File unit. logical, public :: is_connected = .false. Sentinel to check if file is connected. logical, public :: is_initialized = .false. Sentinel to check if file is initialized. Type-Bound Procedures generic, public :: assignment(=) => file_assign_file Overload = . procedure, public, pass(self) :: close Close file. procedure, public, pass(self) :: description Return a pretty-formatted description of the file. procedure, public, pass(self) :: destroy Destroy file. procedure, public, pass(lhs) :: file_assign_file Operator = . procedure, public, pass(self) :: initialize Initialize file. procedure, public, pass(self) :: load_file_name_from_file Load file name from file. procedure, public, pass(self) :: load_grid_dimensions_from_file Load the grid dimensions of all blocks from file. procedure, public, pass(self) :: load_nodes_from_file Load nodes coordinates from file. procedure, public, pass(self) :: open Open file. procedure, public, pass(self) :: save_file_name_into_file Save file name into file. procedure, public, pass(self) :: save_grid_dimensions_into_file Save the grid dimensions of all blocks into file. procedure, public, pass(self) :: save_nodes_into_file Save nodes coordinates into file. Subroutines private subroutine load_grid_dimensions_from_file (self, grid_dimensions, file_name) Load the grid dimensions of all blocks from file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(inout) :: grid_dimensions Grid dimensions off all blocks into file. character(len=*), intent(in), optional :: file_name File name. private subroutine load_nodes_from_file (self, grid_dimensions, blocks, file_name) Load nodes coordinates from file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. type( block_object ), intent(inout) :: blocks (1:) Blocks storage. character(len=*), intent(in), optional :: file_name File name. private subroutine save_grid_dimensions_into_file (self, grid_dimensions) Load the grid dimensions of all blocks into file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. private subroutine save_nodes_into_file (self, grid_dimensions, blocks) Save nodes coordinates into file. Arguments Type Intent Optional Attributes Name class( file_grid_object ), intent(inout) :: self File object. type( grid_dimensions_object ), intent(in) :: grid_dimensions Grid dimensions off all blocks into file. type( block_object ), intent(inout) :: blocks (1:) Blocks storage.","tags":"","loc":"module/off_file_grid_object.html","title":"off_file_grid_object – OFF"},{"text":"Uses: iso_fortran_env off_error_object finer penf module~~off_file_object~~UsesGraph module~off_file_object off_file_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_file_object module~off_error_object off_error_object iso_fortran_env->module~off_error_object finer finer finer->module~off_file_object penf penf penf->module~off_file_object penf->module~off_error_object module~off_error_object->module~off_file_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF file object definition and implementation. Used By module~~off_file_object~~UsedByGraph module~off_file_object off_file_object module~off_files_collection_object off_files_collection_object module~off_file_object->module~off_files_collection_object module~off_file_grid_object off_file_grid_object module~off_file_object->module~off_file_grid_object module~off_objects off_objects module~off_file_object->module~off_objects module~off_files_collection_object->module~off_objects module~off_file_grid_object->module~off_objects module~off_simulation_object off_simulation_object module~off_file_grid_object->module~off_simulation_object program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid module~off_simulation_object->module~off_objects var panmoduleoff_file_objectUsedByGraph = svgPanZoom('#moduleoff_file_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ERROR_ALREADY_CONNECTED ERROR_NOT_CONNECTED ERROR_NOT_INITIALIZED UNSET_FILE_NAME Derived Types file_object Functions description Subroutines close destroy file_assign_file initialize load_file_name_from_file open save_file_name_into_file Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: ERROR_ALREADY_CONNECTED = 1 Already connected error code. integer(kind=I4P), public, parameter :: ERROR_NOT_CONNECTED = 2 Not connected error code. integer(kind=I4P), public, parameter :: ERROR_NOT_INITIALIZED = 3 Not initialized error code. character(len=5), private, parameter :: UNSET_FILE_NAME = 'unset' Default, unset file name. Derived Types type, public :: file_object File object class. Components Type Visibility Attributes Name Initial type( error_object ), public :: error Errors handler. character(len=:), public, allocatable :: file_name File name. integer(kind=I4P), public :: file_unit = 0 File unit. logical, public :: is_connected = .false. Sentinel to check if file is connected. logical, public :: is_initialized = .false. Sentinel to check if file is initialized. Type-Bound Procedures generic, public :: assignment(=) => file_assign_file Overload = . procedure, public, pass(self) :: close Close file. procedure, public, pass(self) :: description Return a pretty-formatted description of the file. procedure, public, pass(self) :: destroy Destroy file. procedure, public, pass(lhs) :: file_assign_file Operator = . procedure, public, pass(self) :: initialize Initialize file. procedure, public, pass(self) :: load_file_name_from_file Load file name from file. procedure, public, pass(self) :: open Open file. procedure, public, pass(self) :: save_file_name_into_file Save file name into file. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(in) :: self Files collection. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private subroutine close (self) Close file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. private elemental subroutine destroy (self) Destroy file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. private pure subroutine file_assign_file (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: lhs Left hand side. type( file_object ), intent(in) :: rhs Right hand side. private elemental subroutine initialize (self, file_name) Initialize File. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. private subroutine load_file_name_from_file (self, fini, section_name, option_name, go_on_fail) Load file name from file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file. logical, intent(in), optional :: go_on_fail Go on if load fails. private subroutine open (self, file_name, format, action, access) Open file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: format File format. character(len=*), intent(in), optional :: action File action. character(len=*), intent(in), optional :: access File access. private subroutine save_file_name_into_file (self, fini, section_name, option_name) Save file name into file. Arguments Type Intent Optional Attributes Name class( file_object ), intent(inout) :: self File object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. character(len=*), intent(in) :: section_name Option name into the ini file. character(len=*), intent(in) :: option_name Option name into the ini file.","tags":"","loc":"module/off_file_object.html","title":"off_file_object – OFF"},{"text":"Uses: off_file_object finer penf module~~off_files_collection_object~~UsesGraph module~off_files_collection_object off_files_collection_object module~off_file_object off_file_object module~off_file_object->module~off_files_collection_object finer finer finer->module~off_files_collection_object finer->module~off_file_object penf penf penf->module~off_files_collection_object penf->module~off_file_object module~off_error_object off_error_object penf->module~off_error_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_file_object iso_fortran_env->module~off_error_object module~off_error_object->module~off_file_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF files collection object definition and implementation. Used By module~~off_files_collection_object~~UsedByGraph module~off_files_collection_object off_files_collection_object module~off_objects off_objects module~off_files_collection_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables INI_SECTION_NAME Derived Types files_collection_object Functions description Subroutines destroy initialize load_from_file save_into_file Variables Type Visibility Attributes Name Initial character(len=5), private, parameter :: INI_SECTION_NAME = 'files' INI (config) file section name containing the collection file names. Derived Types type, public :: files_collection_object Files collection object class. Components Type Visibility Attributes Name Initial type( file_object ), public :: boundary_conditions Boundary conditions file. type( file_object ), public :: grid Grid file. type( file_object ), public :: initial_conditions Initial conditions file. type( file_object ), public :: logging Logging file. type( file_object ), public :: solution Solution file. Type-Bound Procedures procedure, public, pass(self) :: description Return a pretty-formatted description of the files collection. procedure, public, pass(self) :: destroy Destroy files collection. procedure, public, pass(self) :: initialize Initialize files collection. procedure, public, pass(self) :: load_from_file Load from file. procedure, public, pass(self) :: save_into_file Save into file. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(in) :: self Files collection. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private elemental subroutine destroy (self) Destroy files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. private elemental subroutine initialize (self) Initialize Files collection. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails.. private subroutine save_into_file (self, fini) Save from file. Arguments Type Intent Optional Attributes Name class( files_collection_object ), intent(inout) :: self Files collection. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler.","tags":"","loc":"module/off_files_collection_object.html","title":"off_files_collection_object – OFF"},{"text":"Uses: off_error_object finer penf vecfor module~~off_free_conditions_object~~UsesGraph module~off_free_conditions_object off_free_conditions_object module~off_error_object off_error_object module~off_error_object->module~off_free_conditions_object finer finer finer->module~off_free_conditions_object vecfor vecfor vecfor->module~off_free_conditions_object penf penf penf->module~off_free_conditions_object penf->module~off_error_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF free conditions object definition and implementation. Used By module~~off_free_conditions_object~~UsedByGraph module~off_free_conditions_object off_free_conditions_object module~off_simulation_object off_simulation_object module~off_free_conditions_object->module~off_simulation_object module~off_objects off_objects module~off_free_conditions_object->module~off_objects module~off_simulation_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables INI_SECTION_NAME Derived Types free_conditions_object Functions description Subroutines destroy free_assign_free initialize load_from_file save_into_file Variables Type Visibility Attributes Name Initial character(len=15), private, parameter :: INI_SECTION_NAME = 'free_conditions' INI (config) file section name containing the\n free stream conditions. Derived Types type, public :: free_conditions_object Free conditions object class. Components Type Visibility Attributes Name Initial type( error_object ), public :: error Errors handler. type(vector), public :: velocity Velocity. Type-Bound Procedures generic, public :: assignment(=) => free_assign_free Overload = . procedure, public, pass(self) :: description Return a pretty-formatted description of the free conditions. procedure, public, pass(self) :: destroy Destroy free conditions. procedure, public, pass(lhs) :: free_assign_free Operator = . procedure, public, pass(self) :: initialize Initialize free conditions. procedure, public, pass(self) :: load_from_file Load from file. procedure, public, pass(self) :: save_into_file Save into file. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(in) :: self Free conditions. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private elemental subroutine destroy (self) Destroy free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. private pure subroutine free_assign_free (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: lhs Left hand side. type( free_conditions_object ), intent(in) :: rhs Right hand side. private elemental subroutine initialize (self) Initialize free conditions. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( free_conditions_object ), intent(inout) :: self Free conditions. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler.","tags":"","loc":"module/off_free_conditions_object.html","title":"off_free_conditions_object – OFF"},{"text":"Uses: off_block_signature_object penf vecfor module~~off_grid_dimensions_object~~UsesGraph module~off_grid_dimensions_object off_grid_dimensions_object vecfor vecfor vecfor->module~off_grid_dimensions_object module~off_block_signature_object off_block_signature_object vecfor->module~off_block_signature_object module~off_block_signature_object->module~off_grid_dimensions_object penf penf penf->module~off_grid_dimensions_object penf->module~off_block_signature_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF grid dimensions object definition and implementation. Used By module~~off_grid_dimensions_object~~UsedByGraph module~off_grid_dimensions_object off_grid_dimensions_object module~off_simulation_object off_simulation_object module~off_grid_dimensions_object->module~off_simulation_object module~off_file_grid_object off_file_grid_object module~off_grid_dimensions_object->module~off_file_grid_object module~off_objects off_objects module~off_grid_dimensions_object->module~off_objects module~off_simulation_object->module~off_objects module~off_file_grid_object->module~off_simulation_object module~off_file_grid_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid var panmoduleoff_grid_dimensions_objectUsedByGraph = svgPanZoom('#moduleoff_grid_dimensions_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types grid_dimensions_object Functions description iolength iopos_block_nodes Subroutines destroy grid_d_assign_grid_d initialize load_from_file save_into_file Derived Types type, public :: grid_dimensions_object Grid dimensions object class. Components Type Visibility Attributes Name Initial type( block_signature_object ), public, allocatable :: block_signature (:) Signature of each block. integer(kind=I4P), public :: blocks_number = 0 Number of blocks, blobal (whole) number on all process/image. Type-Bound Procedures generic, public :: assignment(=) => grid_d_assign_grid_d Overload = . procedure, public, pass(self) :: description Return a pretty-formatted description of grid dimensions. procedure, public, pass(self) :: destroy Destroy grid dimensions. procedure, public, pass(lhs) :: grid_d_assign_grid_d Operator = . procedure, public, pass(self) :: initialize Initialize grid dimensions. procedure, public, pass(self) :: iolength Return the IO length storage. procedure, public, pass(self) :: iopos_block_nodes Return the IO position where nodes of block b-th are stored. procedure, public, pass(self) :: load_from_file Load grid dimensions from file. procedure, public, pass(self) :: save_into_file Save grid dimensions into file. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private function iolength (self) Return the IO length storage. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. Return Value integer(kind=I4P) IO length storage. private function iopos_block_nodes (self, b) Return the IO position where nodes of block b-th are stored. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: b Block index. Return Value integer(kind=I4P) IO position where nodes of block b-th are stored. Subroutines private elemental subroutine destroy (self) Destroy grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. private pure subroutine grid_d_assign_grid_d (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: lhs Left hand side. type( grid_dimensions_object ), intent(in) :: rhs Right hand side. private pure subroutine initialize (self, block_signature) Initialize grid dimensions. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. type( block_signature_object ), intent(in), optional :: block_signature (1:) Dimensions of each block. private subroutine load_from_file (self, file_unit) Load grid dimensions from file. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(inout) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: file_unit File unit. private subroutine save_into_file (self, file_unit) Load the grid dimensions of all blocks from file. Arguments Type Intent Optional Attributes Name class( grid_dimensions_object ), intent(in) :: self Grid dimensions object. integer(kind=I4P), intent(in) :: file_unit File unit.","tags":"","loc":"module/off_grid_dimensions_object.html","title":"off_grid_dimensions_object – OFF"},{"text":"Uses: vecfor module~~off_node_object~~UsesGraph module~off_node_object off_node_object vecfor vecfor vecfor->module~off_node_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF node object definition and implementation. Used By module~~off_node_object~~UsedByGraph module~off_node_object off_node_object module~off_block_object off_block_object module~off_node_object->module~off_block_object module~off_objects off_objects module~off_node_object->module~off_objects module~off_block_object->module~off_objects module~off_simulation_object off_simulation_object module~off_block_object->module~off_simulation_object module~off_file_grid_object off_file_grid_object module~off_block_object->module~off_file_grid_object program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid module~off_simulation_object->module~off_objects module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object var panmoduleoff_node_objectUsedByGraph = svgPanZoom('#moduleoff_node_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types node_object Subroutines destroy initialize node_assign_node Derived Types type, public :: node_object Node object class. Components Type Visibility Attributes Name Initial type(vector), public :: vertex Vertex coordinates. Type-Bound Procedures generic, public :: assignment(=) => node_assign_node Overload = . procedure, public, pass(self) :: destroy Destroy node. procedure, public, pass(self) :: initialize Initialize node. procedure, public, pass(lhs) :: node_assign_node Operator = . Subroutines private elemental subroutine destroy (self) Destroy node. Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: self Node object. private pure subroutine initialize (self) Initialize node. Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: self Node object. private pure subroutine node_assign_node (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( node_object ), intent(inout) :: lhs Left hand side. type( node_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/off_node_object.html","title":"off_node_object – OFF"},{"text":"Uses: off_error_object finer penf module~~off_non_dimensional_numbers_object~~UsesGraph module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object module~off_error_object off_error_object module~off_error_object->module~off_non_dimensional_numbers_object finer finer finer->module~off_non_dimensional_numbers_object penf penf penf->module~off_non_dimensional_numbers_object penf->module~off_error_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF non dimensional numbers object definition and implementation. Used By module~~off_non_dimensional_numbers_object~~UsedByGraph module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object module~off_simulation_object off_simulation_object module~off_non_dimensional_numbers_object->module~off_simulation_object module~off_objects off_objects module~off_non_dimensional_numbers_object->module~off_objects module~off_simulation_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid var panmoduleoff_non_dimensional_numbers_objectUsedByGraph = svgPanZoom('#moduleoff_non_dimensional_numbers_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables INI_SECTION_NAME Derived Types non_dimensional_numbers_object Functions description Subroutines adim_assign_adim compute_reference_values destroy initialize load_from_file save_into_file Variables Type Visibility Attributes Name Initial character(len=23), private, parameter :: INI_SECTION_NAME = 'non_dimensional_numbers' INI (config) file section name containing the values\n of non dimensional numbers. Derived Types type, public :: non_dimensional_numbers_object Non dimensional numbers object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: Dt0 = 1._R8P Dt_0=\\frac{L_0}{v_0} Reference time interval. real(kind=R8P), public :: E0 = 1._R8P E_0=v_0&#94;2 Reference specific energy. real(kind=R8P), public :: Fr = 1._R8P \\rm{Fr}=\\sqrt{\\frac{v_0&#94;2}{f_0 L_0}} Froude number. real(kind=R8P), public :: Fr2_inv = 1._R8P \\frac{1}{\\rm{Fr}&#94;2} Inverse of square of Froude number (coefficient of volume forces). real(kind=R8P), public :: L0 = 1._R8P Reference length. real(kind=R8P), public :: Ma = 1._R8P \\rm{We}=\\sqrt{\\frac{v_0}{a_0}} Mach number. real(kind=R8P), public :: Pr = 1._R8P \\rm{Pr}=\\frac{\\mu_0 c_p}{k_0} Prandtl number. real(kind=R8P), public :: PrRe_inv = 1._R8P \\frac{1}{\\rm{Pr Re}} Inverse of Prandtl and Reynolds numbers (coef. of condution terms). real(kind=R8P), public :: Re = 1._R8P \\rm{Re}=\\frac{\\rho_0 v_0 L_0}{\\mu_0} Reynolds number. real(kind=R8P), public :: Re_inv = 1._R8P \\frac{1}{\\rm{Re}} Inverse of Reynolds number (coefficient of viscous terms). real(kind=R8P), public :: T0 = 1._R8P T_0=\\frac{v_0&#94;2}{c_0} Reference temperature. real(kind=R8P), public :: We = 1._R8P \\rm{We}=\\sqrt{\\frac{\\rho_0 v_0&#94;2 L_0}{\\sigma_0}} Weber number. real(kind=R8P), public :: a0 = 1._R8P a_0=v_0 Reference speed of sound. real(kind=R8P), public :: c0 = 1._R8P Reference specific heats (\\f$cp_0 = cv_0 = R_0 = c_0\\f$). type( error_object ), public :: error Errors handler. real(kind=R8P), public :: f0 = 1._R8P f_0= \\frac{v_0&#94;2}{L_0 \\rm{Fr}&#94;2} Reference specific force. real(kind=R8P), public :: k0 = 1._R8P k_0= \\frac{\\mu_0 c_0}{\\rm{Pr}} Reference thermal conductivity coefficient. real(kind=R8P), public :: mu0 = 1._R8P \\mu_0= \\frac{\\rho_0 v_0 L_0}{\\rm{Re}} Reference dynamic viscosity. real(kind=R8P), public :: p0 = 1._R8P p_0=\\rho_0 v_0&#94;2 Reference pressure. real(kind=R8P), public :: q0 = 1._R8P q_0=\\frac{v_0&#94;3}{L_0} Reference specific heat. real(kind=R8P), public :: r0 = 1._R8P Reference density. real(kind=R8P), public :: v0 = 1._R8P Reference velocity. Type-Bound Procedures procedure, public, pass(lhs) :: adim_assign_adim Operator = . generic, public :: assignment(=) => adim_assign_adim Overload = . procedure, public, pass(self) :: compute_reference_values Compute derived reference values. procedure, public, pass(self) :: description Return a pretty-formatted description of the numbers. procedure, public, pass(self) :: destroy Destroy numbers value. procedure, public, pass(self) :: initialize Initialize numbers value. procedure, public, pass(self) :: load_from_file Load from file. procedure, public, pass(self) :: save_into_file Save into file. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the numbers. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(in) :: self Non dimensional numbers. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private pure subroutine adim_assign_adim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: lhs Left hand side. type( non_dimensional_numbers_object ), intent(in) :: rhs Right hand side. private elemental subroutine compute_reference_values (self) Compute derived reference values. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. private elemental subroutine destroy (self) Destroy numbers value. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. private elemental subroutine initialize (self) Initialize numbers value. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Non dimensional numbers. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( non_dimensional_numbers_object ), intent(inout) :: self Simulation parameters. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler.","tags":"","loc":"module/off_non_dimensional_numbers_object.html","title":"off_non_dimensional_numbers_object – OFF"},{"text":"Uses: off_block_object off_block_signature_object off_cell_object off_error_object off_face_object off_file_object off_file_grid_object off_files_collection_object off_free_conditions_object off_grid_dimensions_object off_node_object off_non_dimensional_numbers_object off_os_object off_simulation_object off_solver_object off_time_object module~~off_objects~~UsesGraph module~off_objects off_objects module~off_os_object off_os_object module~off_os_object->module~off_objects module~off_simulation_object off_simulation_object module~off_os_object->module~off_simulation_object module~off_error_object off_error_object module~off_error_object->module~off_objects module~off_error_object->module~off_os_object module~off_file_object off_file_object module~off_error_object->module~off_file_object module~off_time_object off_time_object module~off_error_object->module~off_time_object module~off_free_conditions_object off_free_conditions_object module~off_error_object->module~off_free_conditions_object module~off_error_object->module~off_simulation_object module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object module~off_error_object->module~off_non_dimensional_numbers_object module~off_solver_object off_solver_object module~off_error_object->module~off_solver_object module~off_block_object off_block_object module~off_error_object->module~off_block_object module~off_file_grid_object off_file_grid_object module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object module~off_files_collection_object off_files_collection_object module~off_files_collection_object->module~off_objects module~off_file_object->module~off_objects module~off_file_object->module~off_file_grid_object module~off_file_object->module~off_files_collection_object module~off_time_object->module~off_objects module~off_time_object->module~off_simulation_object module~off_block_signature_object off_block_signature_object module~off_block_signature_object->module~off_objects module~off_block_signature_object->module~off_block_object module~off_grid_dimensions_object off_grid_dimensions_object module~off_block_signature_object->module~off_grid_dimensions_object module~off_node_object off_node_object module~off_node_object->module~off_objects module~off_node_object->module~off_block_object module~off_free_conditions_object->module~off_objects module~off_free_conditions_object->module~off_simulation_object module~off_simulation_object->module~off_objects module~off_cell_object off_cell_object module~off_cell_object->module~off_objects module~off_cell_object->module~off_block_object module~off_face_object off_face_object module~off_face_object->module~off_objects module~off_face_object->module~off_block_object module~off_non_dimensional_numbers_object->module~off_objects module~off_non_dimensional_numbers_object->module~off_simulation_object module~off_solver_object->module~off_objects module~off_solver_object->module~off_simulation_object module~off_block_object->module~off_objects module~off_block_object->module~off_file_grid_object module~off_block_object->module~off_simulation_object module~off_grid_dimensions_object->module~off_objects module~off_grid_dimensions_object->module~off_file_grid_object module~off_grid_dimensions_object->module~off_simulation_object penf penf penf->module~off_os_object penf->module~off_error_object penf->module~off_file_grid_object penf->module~off_files_collection_object penf->module~off_file_object penf->module~off_time_object penf->module~off_block_signature_object penf->module~off_free_conditions_object penf->module~off_simulation_object penf->module~off_cell_object penf->module~off_face_object penf->module~off_non_dimensional_numbers_object penf->module~off_solver_object penf->module~off_block_object penf->module~off_grid_dimensions_object stringifor stringifor stringifor->module~off_os_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object iso_fortran_env->module~off_file_grid_object iso_fortran_env->module~off_file_object iso_fortran_env->module~off_simulation_object iso_fortran_env->module~off_block_object finer finer finer->module~off_files_collection_object finer->module~off_file_object finer->module~off_time_object finer->module~off_free_conditions_object finer->module~off_simulation_object finer->module~off_non_dimensional_numbers_object finer->module~off_solver_object vecfor vecfor vecfor->module~off_block_signature_object vecfor->module~off_node_object vecfor->module~off_free_conditions_object vecfor->module~off_cell_object vecfor->module~off_face_object vecfor->module~off_block_object vecfor->module~off_grid_dimensions_object flap flap flap->module~off_simulation_object vtk_fortran vtk_fortran vtk_fortran->module~off_block_object var panmoduleoff_objectsUsesGraph = svgPanZoom('#moduleoff_objectsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF objects collection. This is convenient entry point to access all OFF objects. Used By module~~off_objects~~UsedByGraph module~off_objects off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/off_objects.html","title":"off_objects – OFF"},{"text":"Uses: off_error_object penf stringifor module~~off_os_object~~UsesGraph module~off_os_object off_os_object module~off_error_object off_error_object module~off_error_object->module~off_os_object penf penf penf->module~off_os_object penf->module~off_error_object stringifor stringifor stringifor->module~off_os_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF OS object definition and implementation. Used By module~~off_os_object~~UsedByGraph module~off_os_object off_os_object module~off_simulation_object off_simulation_object module~off_os_object->module~off_simulation_object module~off_objects off_objects module~off_os_object->module~off_objects module~off_simulation_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ERROR_CP_FAILED ERROR_FALLBACK_INIT ERROR_MKDIR_FAILED ERROR_RM_FAILED NO_ERROR Derived Types os_object Subroutines cp destroy initialize initialize_unix initialize_windows mkdir os_assign_os rm Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: ERROR_CP_FAILED = 1 Failed to copy files/directories. integer(kind=I4P), private, parameter :: ERROR_FALLBACK_INIT = 4 Failed to set custom OS, used fallback system (unix). integer(kind=I4P), private, parameter :: ERROR_MKDIR_FAILED = 2 Failed to create directory. integer(kind=I4P), private, parameter :: ERROR_RM_FAILED = 3 Failed to remove files/directories. integer(kind=I4P), private, parameter :: NO_ERROR = 0 No errors occurred. Derived Types type, public :: os_object OS object class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cp_dir_command Copy directory command. character(len=:), public, allocatable :: cp_file_command Copy file command. type( error_object ), public :: error Error handler. character(len=:), public, allocatable :: mkdir_command Make directory command. character(len=:), public, allocatable :: path_separator Path seperator, e.g. \"/\" for unix-like systems. character(len=:), public, allocatable :: rm_dir_command Remove directory command. character(len=:), public, allocatable :: rm_file_command Remove file command. Type-Bound Procedures generic, public :: assignment(=) => os_assign_os Overload = . procedure, public, pass(self) :: cp Copy files/directories. procedure, public, pass(self) :: destroy Destroy OS… not your :-) procedure, public, pass(self) :: initialize Initialze OS. procedure, public, pass(self) :: initialize_unix Initialze OS as unix-like system. procedure, public, pass(self) :: initialize_windows Initialze OS as windows-like system. procedure, public, pass(self) :: mkdir Make directory. procedure, public, pass(lhs) :: os_assign_os Operator = . procedure, public, pass(self) :: rm Remove files/directories. Subroutines private subroutine cp (self, file_name, dir_name) Copy files/directories. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: dir_name Dir name. private elemental subroutine destroy (self) Destroy OS… not your :-) Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. private elemental subroutine initialize (self, system) Initialize OS. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: system System name, valid [unix, windows]. private elemental subroutine initialize_unix (self) Initialize OS as unix-like system. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. private elemental subroutine initialize_windows (self) Initialize OS as windows-like system. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. private subroutine mkdir (self, dir_name) Make directoriy. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in) :: dir_name Dir name. private pure subroutine os_assign_os (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: lhs Left hand side. type( os_object ), intent(in) :: rhs Right hand side. private subroutine rm (self, file_name, dir_name) Remove files/directories. Arguments Type Intent Optional Attributes Name class( os_object ), intent(inout) :: self OS. character(len=*), intent(in), optional :: file_name File name. character(len=*), intent(in), optional :: dir_name Dir name.","tags":"","loc":"module/off_os_object.html","title":"off_os_object – OFF"},{"text":"Uses: iso_fortran_env off_block_object off_error_object off_free_conditions_object off_file_grid_object off_grid_dimensions_object off_non_dimensional_numbers_object off_os_object off_solver_object off_time_object finer flap penf module~~off_simulation_object~~UsesGraph module~off_simulation_object off_simulation_object module~off_error_object off_error_object module~off_error_object->module~off_simulation_object module~off_solver_object off_solver_object module~off_error_object->module~off_solver_object module~off_time_object off_time_object module~off_error_object->module~off_time_object module~off_free_conditions_object off_free_conditions_object module~off_error_object->module~off_free_conditions_object module~off_os_object off_os_object module~off_error_object->module~off_os_object module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object module~off_error_object->module~off_non_dimensional_numbers_object module~off_block_object off_block_object module~off_error_object->module~off_block_object module~off_file_object off_file_object module~off_error_object->module~off_file_object module~off_grid_dimensions_object off_grid_dimensions_object module~off_grid_dimensions_object->module~off_simulation_object module~off_file_grid_object off_file_grid_object module~off_grid_dimensions_object->module~off_file_grid_object module~off_solver_object->module~off_simulation_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_simulation_object iso_fortran_env->module~off_error_object iso_fortran_env->module~off_block_object iso_fortran_env->module~off_file_grid_object iso_fortran_env->module~off_file_object module~off_time_object->module~off_simulation_object module~off_free_conditions_object->module~off_simulation_object finer finer finer->module~off_simulation_object finer->module~off_solver_object finer->module~off_time_object finer->module~off_free_conditions_object finer->module~off_non_dimensional_numbers_object finer->module~off_file_object module~off_os_object->module~off_simulation_object module~off_non_dimensional_numbers_object->module~off_simulation_object flap flap flap->module~off_simulation_object module~off_block_object->module~off_simulation_object module~off_block_object->module~off_file_grid_object penf penf penf->module~off_simulation_object penf->module~off_error_object penf->module~off_grid_dimensions_object penf->module~off_solver_object penf->module~off_time_object penf->module~off_free_conditions_object penf->module~off_os_object penf->module~off_non_dimensional_numbers_object penf->module~off_block_object penf->module~off_file_grid_object module~off_block_signature_object off_block_signature_object penf->module~off_block_signature_object module~off_cell_object off_cell_object penf->module~off_cell_object module~off_face_object off_face_object penf->module~off_face_object penf->module~off_file_object module~off_file_grid_object->module~off_simulation_object vecfor vecfor vecfor->module~off_grid_dimensions_object vecfor->module~off_free_conditions_object vecfor->module~off_block_object vecfor->module~off_block_signature_object vecfor->module~off_cell_object module~off_node_object off_node_object vecfor->module~off_node_object vecfor->module~off_face_object module~off_block_signature_object->module~off_grid_dimensions_object module~off_block_signature_object->module~off_block_object stringifor stringifor stringifor->module~off_os_object module~off_cell_object->module~off_block_object module~off_node_object->module~off_block_object module~off_face_object->module~off_block_object vtk_fortran vtk_fortran vtk_fortran->module~off_block_object module~off_file_object->module~off_file_grid_object var panmoduleoff_simulation_objectUsesGraph = svgPanZoom('#moduleoff_simulation_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF simulation object definition and implementation. Used By module~~off_simulation_object~~UsedByGraph module~off_simulation_object off_simulation_object module~off_objects off_objects module~off_simulation_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types simulation_object Functions description Subroutines allocate_blocks destroy initialize integrate load_file_grid load_file_parameters load_input_files parse_command_line_interface save_file_grid save_file_parameters set_command_line_interface Derived Types type, public :: simulation_object Simulation object class. Components Type Visibility Attributes Name Initial type( non_dimensional_numbers_object ), public :: adimensionals Non dimensional numbers. type( block_object ), public, allocatable :: blocks (:) Blocks list. type(command_line_interface), public :: cli Command line interface. type( error_object ), public :: error Errors handler. type( file_grid_object ), public :: file_grid Grid file handler. character(len=999), public :: file_parameters = '' Name of simulation parameters file. type( free_conditions_object ), public :: free_conditions Free stream conditions. logical, public :: go_on_fail = .false. Allow/disallow parameters loading failure. type( grid_dimensions_object ), public :: grid_dimensions Grid dimensions. logical, public :: is_cli_parsed = .false. Sentinel of CLI parsing. logical, public :: is_output_verbose = .false. Verbose output. type( os_object ), public :: os Running Operating System. type( solver_object ), public :: solver solver models parameters. type( time_object ), public :: time Timing conditions. Type-Bound Procedures procedure, public, pass(self) :: allocate_blocks Allocate blocks accordingly to grid dimensions. procedure, public, pass(self) :: description Return a pretty-formatted description of the simulation. procedure, public, pass(self) :: destroy Destroy simulation data. procedure, public, pass(self) :: initialize Initialize simulation. procedure, public, pass(self) :: integrate Integrate the equations. procedure, public, pass(self) :: load_file_grid Load grid file. procedure, public, pass(self) :: load_file_parameters Load file parameters. procedure, public, pass(self) :: load_input_files Load input files. procedure, public, pass(self) :: parse_command_line_interface Parse command line interface. procedure, public, pass(self) :: save_file_grid Save grid file. procedure, public, pass(self) :: save_file_parameters Save file parameters. procedure, private, pass(self) :: set_command_line_interface Set command line interface. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of the simulation. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(in) :: self Simulation parameters. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private subroutine allocate_blocks (self) Allocate blocks accordingly to grid dimensions. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation data. private elemental subroutine destroy (self) Destroy simulation data. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation data. private subroutine initialize (self, blocks, parse_cli, load_files) Initialize simulation. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. type( block_object ), intent(in), optional :: blocks (1:) Blocks structure. logical, intent(in), optional :: parse_cli Enable CLI parsing. logical, intent(in), optional :: load_files Enable files loading. private subroutine integrate (self) Integrate the equations. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. private subroutine load_file_grid (self, file_basename) Load grid file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. character(len=*), intent(in) :: file_basename File basename. private subroutine load_file_parameters (self, file_name, go_on_fail) Load file parameters. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation object. character(len=*), intent(in) :: file_name File name. logical, intent(in), optional :: go_on_fail Go on if load fails. private subroutine load_input_files (self) Load from file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. private subroutine parse_command_line_interface (self) Parse command line interface. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. private subroutine save_file_grid (self, file_basename, ascii, metrics, off, tecplot, vtk) Save grid file. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data. character(len=*), intent(in) :: file_basename File basename. logical, intent(in), optional :: ascii Ascii/binary output. logical, intent(in), optional :: metrics Save also metrics data. logical, intent(in), optional :: off Save in OFF format sentinel. logical, intent(in), optional :: tecplot Tecplot output format sentinel. logical, intent(in), optional :: vtk VTK output format sentinel. private subroutine save_file_parameters (self, file_name) Save file parameters. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self Simulation object. character(len=*), intent(in) :: file_name File name. private subroutine set_command_line_interface (self) Set command line interface. Arguments Type Intent Optional Attributes Name class( simulation_object ), intent(inout) :: self simulation data.","tags":"","loc":"module/off_simulation_object.html","title":"off_simulation_object – OFF"},{"text":"Uses: off_error_object finer penf module~~off_solver_object~~UsesGraph module~off_solver_object off_solver_object module~off_error_object off_error_object module~off_error_object->module~off_solver_object finer finer finer->module~off_solver_object penf penf penf->module~off_solver_object penf->module~off_error_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF solver object definition and implementation. Used By module~~off_solver_object~~UsedByGraph module~off_solver_object off_solver_object module~off_simulation_object off_simulation_object module~off_solver_object->module~off_simulation_object module~off_objects off_objects module~off_solver_object->module~off_objects module~off_simulation_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables INI_SECTION_NAME Derived Types solver_object Functions description Subroutines destroy initialize load_from_file save_into_file solver_assign_solver Variables Type Visibility Attributes Name Initial character(len=6), private, parameter :: INI_SECTION_NAME = 'solver' INI (config) file section name containing the solver parameters. Derived Types type, public :: solver_object Solver object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: artificial_viscosity = 0._R8P Artifiical viscosity. real(kind=R8P), public :: chimera_forcing = 0._R8P Chimera forcing coefficient. character(len=:), public, allocatable :: convective_operator Convective operator model: tvd, eno3, weno3(5-17)… character(len=:), public, allocatable :: diffusive_operator Diffusive operator model: centered2(4-10)… type( error_object ), public :: error Errors handler. real(kind=R8P), public :: pseudo_compressibility = 0._R8P Pseudo compressibility. real(kind=R8P), public :: residuals_tolerance = 0._R8P Tolerance on residuals value. character(len=:), public, allocatable :: time_integrator Time integrator model: euler, rk2(3-10), ab2(3-12)… character(len=:), public, allocatable :: turbulence_model Turbulence_model: k-e, k-w, less… Type-Bound Procedures generic, public :: assignment(=) => solver_assign_solver Overload = . procedure, public, pass(self) :: description Return a pretty-formatted description of solver parameters. procedure, public, pass(self) :: destroy Destroy solver. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: load_from_file Load from file. procedure, public, pass(self) :: save_into_file Save into file. procedure, public, pass(lhs) :: solver_assign_solver Operator = . Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of solver parameters. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(in) :: self Solver object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private elemental subroutine destroy (self) Destroy solver. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. private elemental subroutine initialize (self) Initialize solver. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: self Solver object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. private pure subroutine solver_assign_solver (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( solver_object ), intent(inout) :: lhs Left hand side. type( solver_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/off_solver_object.html","title":"off_solver_object – OFF"},{"text":"Uses: off_error_object finer penf module~~off_time_object~~UsesGraph module~off_time_object off_time_object module~off_error_object off_error_object module~off_error_object->module~off_time_object finer finer finer->module~off_time_object penf penf penf->module~off_time_object penf->module~off_error_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF time object definition and implementation. Used By module~~off_time_object~~UsedByGraph module~off_time_object off_time_object module~off_simulation_object off_simulation_object module~off_time_object->module~off_simulation_object module~off_objects off_objects module~off_time_object->module~off_objects module~off_simulation_object->module~off_objects program~off_test_save_load_file_parameters off_test_save_load_file_parameters module~off_objects->program~off_test_save_load_file_parameters program~off_test_load_file_parameters off_test_load_file_parameters module~off_objects->program~off_test_load_file_parameters program~off_test_save_load_file_grid off_test_save_load_file_grid module~off_objects->program~off_test_save_load_file_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables INI_SECTION_NAME Derived Types time_object Functions description is_the_end progress Subroutines destroy initialize load_from_file save_into_file set_stop time_assign_time update Variables Type Visibility Attributes Name Initial character(len=4), private, parameter :: INI_SECTION_NAME = 'time' INI (config) file section name containing the time parameters. Derived Types type, public :: time_object Time object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: CFL = 0.3_R8P Courant-Friedrichs-Lewy stability coefficient. type( error_object ), public :: error Errors handler. logical, public :: is_unsteady = .true. Type of simulation: unsteady or steady. integer(kind=I8P), public :: n = 0 Time steps counter. integer(kind=I8P), public :: n_max = 0 Maximum number of time steps computed. real(kind=R8P), public :: t = 0._R8P Time. real(kind=R8P), public :: t_max = 0._R8P Maximum time of integration, ignored if n_max>0 . Type-Bound Procedures generic, public :: assignment(=) => time_assign_time Overload = . procedure, public, pass(self) :: description Return a pretty-formatted description of time parameters. procedure, public, pass(self) :: destroy Destroy time. procedure, public, pass(self) :: initialize Initialize time. procedure, public, pass(self) :: is_the_end Return true if the end of simulation is reached. procedure, public, pass(self) :: load_from_file Load from file. procedure, public, pass(self) :: progress Return the progress of simulation. procedure, public, pass(self) :: save_into_file Save into file. procedure, public, pass(self) :: set_stop Set simulation stop condition. procedure, public, pass(lhs) :: time_assign_time Operator = . procedure, public, pass(self) :: update Update time. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted description of time parameters. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function is_the_end (self) result(yes) Return true if the end of simulation is reached. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. Return Value logical Test result. private elemental function progress (self) result(prog) Return the progress of simulation. Arguments Type Intent Optional Attributes Name class( time_object ), intent(in) :: self Time object. Return Value real(kind=R8P) Actual progress value. Subroutines private elemental subroutine destroy (self) Destroy time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. private elemental subroutine initialize (self) Initialize time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. private subroutine load_from_file (self, fini, go_on_fail) Load from file. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. type(file_ini), intent(in) :: fini Simulation parameters ini file handler. logical, intent(in), optional :: go_on_fail Go on if load fails. private subroutine save_into_file (self, fini) Save into file. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. type(file_ini), intent(inout) :: fini Simulation parameters ini file handler. private elemental subroutine set_stop (self) Set simulation stop condition. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. private pure subroutine time_assign_time (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: lhs Left hand side. type( time_object ), intent(in) :: rhs Right hand side. private elemental subroutine update (self, global_min_dt) Update time. Arguments Type Intent Optional Attributes Name class( time_object ), intent(inout) :: self Time object. real(kind=R8P), intent(inout) :: global_min_dt Global (all processes/images, all blocks) minimum time step.","tags":"","loc":"module/off_time_object.html","title":"off_time_object – OFF"},{"text":"Uses: off_objects flap penf program~~off_test_load_file_parameters~~UsesGraph program~off_test_load_file_parameters off_test_load_file_parameters flap flap flap->program~off_test_load_file_parameters module~off_simulation_object off_simulation_object flap->module~off_simulation_object module~off_objects off_objects module~off_objects->program~off_test_load_file_parameters penf penf penf->program~off_test_load_file_parameters module~off_os_object off_os_object penf->module~off_os_object module~off_error_object off_error_object penf->module~off_error_object module~off_file_grid_object off_file_grid_object penf->module~off_file_grid_object module~off_files_collection_object off_files_collection_object penf->module~off_files_collection_object module~off_file_object off_file_object penf->module~off_file_object module~off_time_object off_time_object penf->module~off_time_object module~off_block_signature_object off_block_signature_object penf->module~off_block_signature_object module~off_free_conditions_object off_free_conditions_object penf->module~off_free_conditions_object penf->module~off_simulation_object module~off_cell_object off_cell_object penf->module~off_cell_object module~off_face_object off_face_object penf->module~off_face_object module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object penf->module~off_non_dimensional_numbers_object module~off_solver_object off_solver_object penf->module~off_solver_object module~off_block_object off_block_object penf->module~off_block_object module~off_grid_dimensions_object off_grid_dimensions_object penf->module~off_grid_dimensions_object module~off_os_object->module~off_objects module~off_os_object->module~off_simulation_object module~off_error_object->module~off_objects module~off_error_object->module~off_os_object module~off_error_object->module~off_file_object module~off_error_object->module~off_time_object module~off_error_object->module~off_free_conditions_object module~off_error_object->module~off_simulation_object module~off_error_object->module~off_non_dimensional_numbers_object module~off_error_object->module~off_solver_object module~off_error_object->module~off_block_object module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object module~off_files_collection_object->module~off_objects module~off_file_object->module~off_objects module~off_file_object->module~off_file_grid_object module~off_file_object->module~off_files_collection_object module~off_time_object->module~off_objects module~off_time_object->module~off_simulation_object module~off_block_signature_object->module~off_objects module~off_block_signature_object->module~off_block_object module~off_block_signature_object->module~off_grid_dimensions_object module~off_node_object off_node_object module~off_node_object->module~off_objects module~off_node_object->module~off_block_object module~off_free_conditions_object->module~off_objects module~off_free_conditions_object->module~off_simulation_object module~off_simulation_object->module~off_objects module~off_cell_object->module~off_objects module~off_cell_object->module~off_block_object module~off_face_object->module~off_objects module~off_face_object->module~off_block_object module~off_non_dimensional_numbers_object->module~off_objects module~off_non_dimensional_numbers_object->module~off_simulation_object module~off_solver_object->module~off_objects module~off_solver_object->module~off_simulation_object module~off_block_object->module~off_objects module~off_block_object->module~off_file_grid_object module~off_block_object->module~off_simulation_object module~off_grid_dimensions_object->module~off_objects module~off_grid_dimensions_object->module~off_file_grid_object module~off_grid_dimensions_object->module~off_simulation_object stringifor stringifor stringifor->module~off_os_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object iso_fortran_env->module~off_file_grid_object iso_fortran_env->module~off_file_object iso_fortran_env->module~off_simulation_object iso_fortran_env->module~off_block_object finer finer finer->module~off_files_collection_object finer->module~off_file_object finer->module~off_time_object finer->module~off_free_conditions_object finer->module~off_simulation_object finer->module~off_non_dimensional_numbers_object finer->module~off_solver_object vecfor vecfor vecfor->module~off_block_signature_object vecfor->module~off_node_object vecfor->module~off_free_conditions_object vecfor->module~off_cell_object vecfor->module~off_face_object vecfor->module~off_block_object vecfor->module~off_grid_dimensions_object vtk_fortran vtk_fortran vtk_fortran->module~off_block_object var panprogramoff_test_load_file_parametersUsesGraph = svgPanZoom('#programoff_test_load_file_parametersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF test: load file of simulation parameters. Calls program~~off_test_load_file_parameters~~CallsGraph program~off_test_load_file_parameters off_test_load_file_parameters proc~cli_parse cli_parse program~off_test_load_file_parameters->proc~cli_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed file_parameters go_on_fail simulation Subroutines cli_parse Source Code off_test_load_file_parameters Variables Type Attributes Name Initial logical :: are_tests_passed (1) Result of tests check. character(len=999) :: file_parameters Name of simulation parameters. logical :: go_on_fail Go on if load fails. type( simulation_object ) :: simulation Simulation data. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program off_test_load_file_parameters !< OFF test: load file of simulation parameters. use off_objects , only : simulation_object use flap , only : command_line_interface use penf , only : I4P implicit none character ( 999 ) :: file_parameters !< Name of simulation parameters. logical :: go_on_fail !< Go on if load fails. type ( simulation_object ) :: simulation !< Simulation data. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call simulation % load_file_parameters ( file_name = file_parameters , go_on_fail = go_on_fail ) are_tests_passed ( 1 ) = simulation % solver % time_integrator == 'rk5' print '(A)' , simulation % description () print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_load_file_parameters' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_load_file_parameters --parameters sim_parameters.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--parameters-file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . true ., & act = 'store' ) call cli % add ( switch = '--go-on-fail' , & switch_ab = '-gof' , & help = 'go-on if load fails somewhere' , & required = . false ., & def = '.false.' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--parameters-file' , val = file_parameters ) call cli % get ( switch = '--go-on-fail' , val = go_on_fail ) endsubroutine cli_parse endprogram off_test_load_file_parameters","tags":"","loc":"program/off_test_load_file_parameters.html","title":"off_test_load_file_parameters – OFF"},{"text":"Uses: off_objects flap penf vecfor program~~off_test_save_load_file_grid~~UsesGraph program~off_test_save_load_file_grid off_test_save_load_file_grid flap flap flap->program~off_test_save_load_file_grid module~off_simulation_object off_simulation_object flap->module~off_simulation_object module~off_objects off_objects module~off_objects->program~off_test_save_load_file_grid vecfor vecfor vecfor->program~off_test_save_load_file_grid module~off_block_signature_object off_block_signature_object vecfor->module~off_block_signature_object module~off_node_object off_node_object vecfor->module~off_node_object module~off_free_conditions_object off_free_conditions_object vecfor->module~off_free_conditions_object module~off_cell_object off_cell_object vecfor->module~off_cell_object module~off_face_object off_face_object vecfor->module~off_face_object module~off_block_object off_block_object vecfor->module~off_block_object module~off_grid_dimensions_object off_grid_dimensions_object vecfor->module~off_grid_dimensions_object penf penf penf->program~off_test_save_load_file_grid module~off_os_object off_os_object penf->module~off_os_object module~off_error_object off_error_object penf->module~off_error_object module~off_file_grid_object off_file_grid_object penf->module~off_file_grid_object module~off_files_collection_object off_files_collection_object penf->module~off_files_collection_object module~off_file_object off_file_object penf->module~off_file_object module~off_time_object off_time_object penf->module~off_time_object penf->module~off_block_signature_object penf->module~off_free_conditions_object penf->module~off_simulation_object penf->module~off_cell_object penf->module~off_face_object module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object penf->module~off_non_dimensional_numbers_object module~off_solver_object off_solver_object penf->module~off_solver_object penf->module~off_block_object penf->module~off_grid_dimensions_object module~off_os_object->module~off_objects module~off_os_object->module~off_simulation_object module~off_error_object->module~off_objects module~off_error_object->module~off_os_object module~off_error_object->module~off_file_object module~off_error_object->module~off_time_object module~off_error_object->module~off_free_conditions_object module~off_error_object->module~off_simulation_object module~off_error_object->module~off_non_dimensional_numbers_object module~off_error_object->module~off_solver_object module~off_error_object->module~off_block_object module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object module~off_files_collection_object->module~off_objects module~off_file_object->module~off_objects module~off_file_object->module~off_file_grid_object module~off_file_object->module~off_files_collection_object module~off_time_object->module~off_objects module~off_time_object->module~off_simulation_object module~off_block_signature_object->module~off_objects module~off_block_signature_object->module~off_block_object module~off_block_signature_object->module~off_grid_dimensions_object module~off_node_object->module~off_objects module~off_node_object->module~off_block_object module~off_free_conditions_object->module~off_objects module~off_free_conditions_object->module~off_simulation_object module~off_simulation_object->module~off_objects module~off_cell_object->module~off_objects module~off_cell_object->module~off_block_object module~off_face_object->module~off_objects module~off_face_object->module~off_block_object module~off_non_dimensional_numbers_object->module~off_objects module~off_non_dimensional_numbers_object->module~off_simulation_object module~off_solver_object->module~off_objects module~off_solver_object->module~off_simulation_object module~off_block_object->module~off_objects module~off_block_object->module~off_file_grid_object module~off_block_object->module~off_simulation_object module~off_grid_dimensions_object->module~off_objects module~off_grid_dimensions_object->module~off_file_grid_object module~off_grid_dimensions_object->module~off_simulation_object stringifor stringifor stringifor->module~off_os_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object iso_fortran_env->module~off_file_grid_object iso_fortran_env->module~off_file_object iso_fortran_env->module~off_simulation_object iso_fortran_env->module~off_block_object finer finer finer->module~off_files_collection_object finer->module~off_file_object finer->module~off_time_object finer->module~off_free_conditions_object finer->module~off_simulation_object finer->module~off_non_dimensional_numbers_object finer->module~off_solver_object vtk_fortran vtk_fortran vtk_fortran->module~off_block_object var panprogramoff_test_save_load_file_gridUsesGraph = svgPanZoom('#programoff_test_save_load_file_gridUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF test: save (and re-load for checking) file grid. Calls program~~off_test_save_load_file_grid~~CallsGraph program~off_test_save_load_file_grid off_test_save_load_file_grid proc~cli_parse~2 cli_parse program~off_test_save_load_file_grid->proc~cli_parse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed blocks file_basename simulation Subroutines cli_parse Source Code off_test_save_load_file_grid Variables Type Attributes Name Initial logical :: are_tests_passed (1) Result of tests check. type( block_object ) :: blocks (2) A block. character(len=999) :: file_basename Basename of grid file. type( simulation_object ) :: simulation Simulation data. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program off_test_save_load_file_grid !< OFF test: save (and re-load for checking) file grid. use off_objects , only : block_object , simulation_object use flap , only : command_line_interface use penf , only : I4P , I8P use vecfor , only : ex , ey , ez implicit none character ( 999 ) :: file_basename !< Basename of grid file. type ( simulation_object ) :: simulation !< Simulation data. type ( block_object ) :: blocks ( 2 ) !< A block. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . call cli_parse call blocks ( 1 )% initialize ( id = 1_I8P , level = 1 , gc = [ 2 , 2 , 2 , 2 , 2 , 2 ], ni = 8 , nj = 16 , nk = 32 ) call blocks ( 1 )% create_linspace ( emin = ( 0 * ex ), emax = ( ex + ey + ez )) call blocks ( 2 )% initialize ( id = 2_I8P , level = 1 , gc = [ 2 , 2 , 2 , 2 , 2 , 2 ], ni = 16 , nj = 32 , nk = 64 ) call blocks ( 2 )% create_linspace ( emin = ( 1 * ex ), emax = ( 2 * ex + ey + ez )) call simulation % initialize ( blocks = blocks ) call simulation % save_file_grid ( file_basename = trim ( adjustl ( file_basename )), metrics = . true ., off = . true ., vtk = . true .) ! re-load for checking call simulation % initialize call simulation % load_file_grid ( file_basename = trim ( adjustl ( file_basename ))) are_tests_passed ( 1 ) = simulation % blocks ( 2 )% cells_number ( with_ghosts = . false .) == 16_I4P * 32_I4P * 64_I4P print '(A)' , simulation % description () print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) ! remove temporary files grid call simulation % os % rm ( file_name = trim ( adjustl ( file_basename )) // '.grd' ) call simulation % os % rm ( file_name = trim ( adjustl ( file_basename )) // '*.vts' ) contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_save_load_file_grid' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_save_load_file_grid --grid-basename grid\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--grid-basename' , & switch_ab = '-g' , & help = 'basename of grid file' , & required = . false ., & def = 'grid' , & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--grid-basename' , val = file_basename ) endsubroutine cli_parse endprogram off_test_save_load_file_grid","tags":"","loc":"program/off_test_save_load_file_grid.html","title":"off_test_save_load_file_grid – OFF"},{"text":"Uses: off_objects flap penf program~~off_test_save_load_file_parameters~~UsesGraph program~off_test_save_load_file_parameters off_test_save_load_file_parameters flap flap flap->program~off_test_save_load_file_parameters module~off_simulation_object off_simulation_object flap->module~off_simulation_object module~off_objects off_objects module~off_objects->program~off_test_save_load_file_parameters penf penf penf->program~off_test_save_load_file_parameters module~off_os_object off_os_object penf->module~off_os_object module~off_error_object off_error_object penf->module~off_error_object module~off_file_grid_object off_file_grid_object penf->module~off_file_grid_object module~off_files_collection_object off_files_collection_object penf->module~off_files_collection_object module~off_file_object off_file_object penf->module~off_file_object module~off_time_object off_time_object penf->module~off_time_object module~off_block_signature_object off_block_signature_object penf->module~off_block_signature_object module~off_free_conditions_object off_free_conditions_object penf->module~off_free_conditions_object penf->module~off_simulation_object module~off_cell_object off_cell_object penf->module~off_cell_object module~off_face_object off_face_object penf->module~off_face_object module~off_non_dimensional_numbers_object off_non_dimensional_numbers_object penf->module~off_non_dimensional_numbers_object module~off_solver_object off_solver_object penf->module~off_solver_object module~off_block_object off_block_object penf->module~off_block_object module~off_grid_dimensions_object off_grid_dimensions_object penf->module~off_grid_dimensions_object module~off_os_object->module~off_objects module~off_os_object->module~off_simulation_object module~off_error_object->module~off_objects module~off_error_object->module~off_os_object module~off_error_object->module~off_file_object module~off_error_object->module~off_time_object module~off_error_object->module~off_free_conditions_object module~off_error_object->module~off_simulation_object module~off_error_object->module~off_non_dimensional_numbers_object module~off_error_object->module~off_solver_object module~off_error_object->module~off_block_object module~off_file_grid_object->module~off_objects module~off_file_grid_object->module~off_simulation_object module~off_files_collection_object->module~off_objects module~off_file_object->module~off_objects module~off_file_object->module~off_file_grid_object module~off_file_object->module~off_files_collection_object module~off_time_object->module~off_objects module~off_time_object->module~off_simulation_object module~off_block_signature_object->module~off_objects module~off_block_signature_object->module~off_block_object module~off_block_signature_object->module~off_grid_dimensions_object module~off_node_object off_node_object module~off_node_object->module~off_objects module~off_node_object->module~off_block_object module~off_free_conditions_object->module~off_objects module~off_free_conditions_object->module~off_simulation_object module~off_simulation_object->module~off_objects module~off_cell_object->module~off_objects module~off_cell_object->module~off_block_object module~off_face_object->module~off_objects module~off_face_object->module~off_block_object module~off_non_dimensional_numbers_object->module~off_objects module~off_non_dimensional_numbers_object->module~off_simulation_object module~off_solver_object->module~off_objects module~off_solver_object->module~off_simulation_object module~off_block_object->module~off_objects module~off_block_object->module~off_file_grid_object module~off_block_object->module~off_simulation_object module~off_grid_dimensions_object->module~off_objects module~off_grid_dimensions_object->module~off_file_grid_object module~off_grid_dimensions_object->module~off_simulation_object stringifor stringifor stringifor->module~off_os_object iso_fortran_env iso_fortran_env iso_fortran_env->module~off_error_object iso_fortran_env->module~off_file_grid_object iso_fortran_env->module~off_file_object iso_fortran_env->module~off_simulation_object iso_fortran_env->module~off_block_object finer finer finer->module~off_files_collection_object finer->module~off_file_object finer->module~off_time_object finer->module~off_free_conditions_object finer->module~off_simulation_object finer->module~off_non_dimensional_numbers_object finer->module~off_solver_object vecfor vecfor vecfor->module~off_block_signature_object vecfor->module~off_node_object vecfor->module~off_free_conditions_object vecfor->module~off_cell_object vecfor->module~off_face_object vecfor->module~off_block_object vecfor->module~off_grid_dimensions_object vtk_fortran vtk_fortran vtk_fortran->module~off_block_object var panprogramoff_test_save_load_file_parametersUsesGraph = svgPanZoom('#programoff_test_save_load_file_parametersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. OFF test: save (and re-load for checking) file of simulation parameters. Calls program~~off_test_save_load_file_parameters~~CallsGraph program~off_test_save_load_file_parameters off_test_save_load_file_parameters proc~cli_parse~3 cli_parse program~off_test_save_load_file_parameters->proc~cli_parse~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed file_parameters simulation Subroutines cli_parse Source Code off_test_save_load_file_parameters Variables Type Attributes Name Initial logical :: are_tests_passed (1) Result of tests check. character(len=999) :: file_parameters Name of simulation parameters. type( simulation_object ) :: simulation Simulation data. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program off_test_save_load_file_parameters !< OFF test: save (and re-load for checking) file of simulation parameters. use off_objects , only : simulation_object use flap , only : command_line_interface use penf , only : I4P , R8P implicit none character ( 999 ) :: file_parameters !< Name of simulation parameters. type ( simulation_object ) :: simulation !< Simulation data. logical :: are_tests_passed ( 1 ) !< Result of tests check. are_tests_passed = . false . simulation % adimensionals % Ma = 3._R8P call cli_parse call simulation % save_file_parameters ( file_name = file_parameters ) call simulation % initialize ! re-initialize call simulation % load_file_parameters ( file_name = file_parameters ) are_tests_passed ( 1 ) = simulation % adimensionals % Ma == 3._R8P print '(A)' , simulation % description () print '(A,L1)' , 'Are all tests passed? ' , all ( are_tests_passed ) call simulation % os % rm ( file_name = trim ( file_parameters )) ! remove temporary file parameters contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'off_test_save_load_file_parameters' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"off_test_save_load_file_parameters --parameters sim_parameters.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--parameters-file' , & switch_ab = '-par' , & help = 'name of simulation parameters file' , & required = . true ., & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--parameters-file' , val = file_parameters ) endsubroutine cli_parse endprogram off_test_save_load_file_parameters","tags":"","loc":"program/off_test_save_load_file_parameters.html","title":"off_test_save_load_file_parameters – OFF"}]}